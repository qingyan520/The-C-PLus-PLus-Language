# 深入理解C++类和对象



### 初识C++

###### 1.指针和应用的区别：

> 1.引用必须进行初始化，而指针不用进行初始化
> 2.引用自增增加的是源数据本身，而指针自增为增加源数据大小的步长
> 3.指针可以为空，引用不可以为空
> 4.指针和引用的大小不同，指针的大小只与操作系统有关，32为系统下为4字节，64位系统下位8字节，而引用的大小为源数据的大小
> 5.有多级指针，但是没有多级引用
> 6.访问实体方式不同，指针需要解引用，而引用编译器自动处理
> 7.引用在初始化一个实体之后就不能再引用其他实体，而指针可以指向任意同类型实体
> 8.引用比指针更加安全

###### 2.为为什么不推荐使用宏函数

> 1.使用宏函数不支持调试
> 2.宏语法复杂，容易出错，代码可读性差，维护性差
> 3.宏常量没有类型
> c++中那些技术替代了宏函数
> 1.常量定义利用const修饰
> 2.函数定义为内联函数

###### 3.那么内联函数这么好用，要不要每个函数都加inline函数使之变成内联函数呢，答案是否定的

> 1.inline是一种以空间换时间的做法，省去调用函数数额开销，所以代码过长
> 或者有循环/递归时不推荐使用内联函数
> 2.inline对编译器来说只是一个建议，编译器会自动进行优化，如果函数体内代码过长或者使用循环/递归
> 编译器会自动忽略内联
> 3.inline不建议声明与定义分开，分离会导致链接错误，因为inline被展开
> 就没有函数地址了，链接1就会出现错位找不到

###### 4.auto自动变量注意事项



> 1.必须进行初始化
> 2.一行可以定义多个变量，但是一行定义的多个变量类型要一样
> 3.auto在声明指针时与auto*没有区别
> 4.auto在使用引用类型时必须加&
> 5.auto不可以用来定义数组
> 6.auto不可以当作函数形参来使用
>
> 7.auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等
> 进行配合使用



```c++
//判断类型值
#include<iostream>
using namespace std;
int main()
{
	int a = 10;
	auto b = a;//根据10的值自动推导出b的值为int类型
	int* p = &a;
	auto ptr = p;
	auto* ptr1 = p;
	cout <<"a的类型是" <<typeid(a).name() << endl;
	cout << "b的类型是" << typeid(b).name() << endl;
	cout << "p的类型是" << typeid(p).name() << endl;
	cout << "ptr的类型是" << typeid(ptr).name() << endl;
	cout << "ptr1的类型是" << typeid(ptr1).name() << endl;

}
```



```c++
//基于范围的for循环
#include<iostream>
using namespace std;
int main()
{
	int arr[] = { 1,2,3,4,5 };
	for (auto e : arr)
	{
		cout << e << " " << endl;
	}
}
```

###### 5.C++11中的空指针

> 在C98中空指针为NULL，它底层是
> #define NULL   0
> 这出现了很多问题
> 例；

```c++
#include<iostream>
using namespace std;
void Print(int a)

{
	cout << "int"<<endl;
}
void Print(int* p)
{
	cout << "int*" << endl;
}
int main()

{
	Print(0);
	Print(nullptr);
	return 0;
}
```

> 我们想让Print(0)打印int，而Print(NULL)打印int*,然而都打印了int,而在C11中为了解决这个问题，空指针被重新定义为nullptr
> 底层为：（void*）0;

### 类和对象（上）

######  1.面向对象的初步引入

> C语言注重过程
> C++注重面向对象
> 例如：点外卖
> C语言：注重下单--》接单--》送单这个过程，通过一个个函数来实现这三个过程
> C++：客户--》商家--》骑手
> C++更注重对象之间的交互，利用对象之间的交互来完成任务，每个对象都有不同的行为，例如客户下单，商家接单制作，骑手送单
> C++通过这三者之间行为得交互来实现整个送外卖的过程

###### 2.类的引入

> 在C++中，结构体内不仅可以定义数据，还可以定义函数
> 例如

```c++
#include<iostream>
#include<string>
using namespace std;
class Person //定义一个人得结构体
{
public:
	string name;
	string sex;
	int age;
	void Print_PersonInfo()
	{
		cout << "姓名:" << name << endl;
		cout << "性别:" << sex << endl;
		cout << "年龄:" << age << endl;
	}
};
int main()
{
	struct Person person;
	Person person1;
	person1.name = "张三";
	person1.age = 16;
	person1.sex = "男";
	person1.Print_PersonInfo();
	return 0;
}
```

> 如上所示，我们定义一个Person 类型的结构体，在里面创建3个变量，姓名，年龄，性别，这我们应该非常清楚，后面我们还定义了一个函数用来打印
> 这三个信息，我们发现这并不会报错，之后我们通过创建person1这个变量(在C++中定义结构体变量时struct 可以省略)，为其赋值，之后调用打印函数
> 在C++中结构体容许定义函数，我们把这个结构体内数据与函数同时存在的结构体成为一个类，我们更喜欢把前面这个struct 变为calss(类)
> 我们把里面的变量称为成员变量，函数称为成员函数，
> 这个在主函数中通过类创建的对象我们称之为对象
>
> 当我们将struct 改为class之后，我们发现会报很多错误，这是因为C++中有访问权限的说法
> 我们是访问权限：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。
> 我们想让用户访问到的我们就将该属性设这为共有，不想让用户访问到的就设置为私有或者保护
> public:
> 1. public修饰的成员在类外可以直接被访问
> 2. protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)
> 3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止
> 4. class的默认访问权限为private，struct为public(因为struct要兼容C)
> 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别
>
> 而在C++中struct为了兼容C语言中结构体的用法，默认访问权限为public,而在C++class默认访问权限是是private，因此我们上面的代码会报错
> 当我们加上访问权限public:之后，之前的代码就不会报错了

###### 3.类的定义

```c++
class className
{
	// 类体：由成员函数和成员变量组成

}; // 一定要注意后面的分号
```

> class 为定义类的关键字，className为自定义类的名字，注意括号结尾处的分号
> 类中的元素称为类的成员：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。
> 类的两种定义方式：
>
> 1. 声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处
>   理。
>
>   ```c++
>   1. class Person //定义一个人得结构体
>      {
>      public:
>      string name;
>      string sex;
>      int age;
>      void Print_PersonInfo()
>      {
>      	cout << "姓名:" << name << endl;
>      	cout << "性别:" << sex << endl;
>      	cout << "年龄:" << age << endl;
>      }
>      };
>   2. 声明放在.h文件中，类的定义放在.cpp文件中（更推荐这一种）
>      test.h文件中声明变量和函数
>      class Person //定义一个人得结构体
>      {
>      public:
>      string name;
>      string sex;
>      int age;
>      void Print_PersonInfo();
>   
>   };
>   //test.cpp中定义函数
>   void  Person:: Print_PersonInfo()//注意在类外实现函数的时候一定要加作用域限定符指定在哪个作用域下面的函数
>   {
>   	cout << "姓名:" << name << endl;
>   	cout << "性别:" << sex << endl;
>   	cout << "年龄:" << age << endl;
>   }
>   ```
>
>   



###### 4.类的封装

>  【访问限定符说明】
>
>  1. public修饰的成员在类外可以直接被访问
>  2. protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)
>  3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止
>  4. class的默认访问权限为private，struct为public(因为struct要兼容C)
>  注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区
>  4.2 封装【面试题】 面向对象的三大特性：封装、继承、多态。在类和对象阶段，我们只研究类的封装特性，
>  那什么是封装呢？
>  封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互
>

###### 5.类的大小的计算

> 类的大小计算符合内存对齐规则，与C语言计算结构体的大小基本一致
> 结构体内存对齐规则
>
> 1. 第一个成员在与结构体偏移量为0的地址处。
> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
> 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
> VS中默认的对齐数为8
> 3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是
> 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
>
> 注意：类的大小不包括成员函数与静态成员变量，即类的大小为所有非静态成员变量大小之和

```c++
例如
 类中既有成员变量，又有成员函数
class A1 {
public:
	void f1() {}
private:
	int _a;
};
// 类中仅有成员函数
class A2 {
public:
	void f2() {}
};
// 类中什么都没有---空类
class A3
{};
```

> sizeof(A1)=4,该类里面只有一个int类型的非静态成员变量，根据结构体内存对齐规则便宜到3处，最大对齐数为4，最终大小为最大对齐数的整数倍
> 故大小为4
> sizeof(A2)=1，该类没有非静态成员变量，相当于一个空类，而在c++中空类的大小为1，故sizeof(A2)=1
> sizefo(A3)=1,该类直接是一个空类，故大小为1



###### 6.this指针

```c++
#include<iostream>
using namespace std;
class Person
{
public:
	void getdata(string name, int age)
	{
		name = name;
		age = age;
	}
	string name;
	int age;
};
int main()
{
	Person son;
	son.getdata("小王", 10);
	return 0;
}
```

> 如上所示，我们定义一个类，在类里面定义成员变量，name,age;
> 我们为其赋值，让name=name,age=age,这时候就会阐述歧义
> 而C++的this指针解决了这个问题
> 即：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，
> 在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完

>  this指针的特性
> 1.this指针的类型：类类型 * const
> 2.只能在“成员函数”的内部使用
> 3.this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。
> 所以对象中不存储this指针。
> 4.this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户