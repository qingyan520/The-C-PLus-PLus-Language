线程池项目

线程创建很多可以吗，线程越多越好？

> 线程的创建和销毁都是非常重的操作
>
> 线程栈本身占用大量内存
>
> 线程的上下文切换要占用大量时间
>
> 大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机

线程池的优势

> 在服务进程启动之前，实现创建好线程池里面的线程，当业务流量到来之后，直接从线程池重获取一个空闲线程执行task任务即可，task执行完成后，也不用释放线程，而是把线程归还到线程池中给后续的task提供服务

fixed模式的线程池

线程池里面的线程数量是固定不变的，一般是Thread Pool创建时根据当前机器的CPU核心数量进行指定

cached模式线程池

线程池里面的线程数量是可以动态增长的，根据任务数量动态增长，但是会设置一个线程数量的阈值，任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初的线程数量即可



线程同步

线程同步分为线程互斥和线程通信，线程互斥

代码能不能在多线程下执行，看代码是否存在竞态条件：代码片段在多线程环境下执行，随着县的调度顺序不同，而得到不同的运行结果

线程通信：

条件变量：condition_variable

信号量：    semaphore

 

信号量

```
	看作资源技术没有限制的mutex互斥锁
	mutex互斥锁====>资源计数只能是0或者1
	mutex.lock()资源计数 1->0
	mutex.unlock()资源计数 0->1
	
	
	semaphore sem(0);
	
	
	二元信号量 semaphore sem(1);资源计数 0 1
			 可以完成和mutex互斥锁统一的线程互斥操作，区别：mutex只能是那个线程获取锁，由那个线程释放锁，但是semaphore不同，sem.wait()和sem.post()可以处在不同的线程中调用
```

线程通信PV操作



threadpool.h

```cpp
	#ifndef THREADPOOL_H
	#define THREADPOOL_H
	#include<vectror>
	#include<memory>
	#include<queue>
	#include<atomic>
	#include<mutex>
	#include<condition_variable>

	//任务抽象基类
	class Task
	{
		public:
        void exeC();
        //用户可以自定义任意任务类型，从Task继承，重写run方法,实现自定义任务处理
		virtual void run()=0;
        void setResult(Result*ret)
        {
            
        }
        ~Task()=default;
        Task():result_(nullptr)
        {
            
        }
        
        private: 
        Result*result_; //result对象的生命周期》Task的
	}
	
	//线程池支持的模式
	class enum PoolMode
	{
		MODE_FIXED, //固定数量的线程
		MODE_CACHED,//线程数量可动态增长
	}

	
	//线程类型
	class Thread
    {
        public:
        //线程函数对象类型
        using ThreadFunc=std::finction<void()>;
        
        //线程构造
        Thread(ThreadFunc func);
        //线程析构
        ~Thread();
        //启动线程
        void start();
        private:
        ThreadFunc func_;
    }


	//线程池类型
	class ThreadPool
	{
		public:
		TheradPool();
		~ThreadPool();
		
		void start();//开启线程池
        
        void setMode(PoolMode mode);//设置工作模式
        
        //设置task任务队列上限的阈值
        void setTaskQueMaxTreashHold(int threshhold);
        
        //给线程池提交任务
        void submitTask(std::shared_ptr<Task> sp);
        
        //设置初始的线程数量
        void setInitThreadSize(int size);
        
        ThreadPool(const ThreadPool&)=delete;
        ThreadPool& operatro=(const Thread&)=delete;
		
		private:
		std::vector<std::unique_ptr<Thread>> threads_; //线程列表
		size_t initThreadSize_;        //初始线程数量
		std::queue<std::shared_ptr<Task>>taskQue_;//任务队列
		std::atomic_uint taskSize_;//任务数量
        int taskQueMAxThreshhold_;   //任务队列数量上限阈值
        
        std::mutex taskQueMtx_;//保证任务队列线程安全
        std::condition_variable noFull_;//表示任务队列不满
        std::condition_variable notEmpty_;//任务队列不空
		
        PoolMode mode_;//设置工作模式
        
        
        private:
        //定义线程函数
        void threadFunc();
	}
	
```



threadpool.h

```cpp
#include"threadpool.h"
const int TASK_MAX_THRESHOLD=1024;


ThreadPool::ThreadPool():
	initThreadSize_(4),
	taskSize_(0),
	taskQueMaxThreshHold_(Task_MAX_THRESHOLD),
	poolMode_(poolMode::MODE_FIXED)
    {
        
    }
//析构函数
ThreadPool::~ThreadPool()
{
    
}

//设置线程池工作模式
ThreadPool::setMode(PoolMode mode)
{
    poolMode=mode;
}

//设置task任务队列上限阈值
void ThreadPool::setTaskQueMaxThreshHold(int threshhold)
{
    taskQueMaxThreshHold=threshhold;
}

//给线程提交任务，用户调用给接口，传入任务
void ThreadPool::submitTask(std::shared_ptr<Task>sp)
{
    
}

//开启线程
void ThreadPool::start(int initThreadSize=4)
{
    //记录初始线程个数
	 initThreadSize=initThreadSize;
    
    //创建线程对象
    for(inr i=0;i<initThreadSize_;i++)
    {
        //创建thread线程对象的时候，吧线程函数给到thread线程对象
        auto ptr=std::make_unique<Thread>(std::bind(&bind(&Thread::threadFunc,this)));
        threads_.emplase_back(std::move(ptr));
    }
    
    //启动所有线程
       for(inr i=0;i<initThreadSize_;i++)
    {
        threads[i]->start();//需要执行一个线程函数
    }
}

//定义线程函,线程
void ThreadPool::threadFunc():                             
{
    std::cout<<"begin threadFunc tid:"<<endl;
    std::cout<<std::this_thread::get_id()<<std::endl;
    std::cout<<"end threadFunc"<<endl;
}

Thread::Thread(ThreadFunc func):
                              func_(func)
                              {
                                  
                              }
Thread::~Thread()
                              {
                                  
                              }

//线程方法实现
void Thread::start()
{
    //创建一个线程来执行一个线程函数
	std::thread t(func_);  //C++11来说，线程对象t，和线程函数func
    t.detach();//设置分离线程
    
}



void Task::exec()
{
    if(result_!=nullptr)
    result_.setVal(run()); //这里调用run方法
}
void Task::setResult(Result*res)
{
    result_=res;
}
```

summitTask接口实现

```cpp
Result ThreadPool::submitTask(std::shared_ptr<Task>sp)
{
    //获取锁
    std::unique_lock<mutex>lock(taskQueMtx_);
    //线程的通信，等待任务队列又空余
    
    //如果有空余，把任务提交到任务队列
    
    //因为新放了任务，任务队列不为空了，在notEmpty上进行通知
    //用户提交任务，最长等在不超过1s,否则判断提交失败，返回
    while(taskQue_.size()==taskQueMaxThreshHold_)
    {
       if (notFull_.wait_for(lock,std::chrono::seconds(3))==false){
           std::cerr<<"task queue is full,submit task fail"<<std::endl;
           //return  task->getResult();
           return Result(sp，false);
       }
    }
    //notFUll_.wait(lock,[&]()->bool{
        return taskQue_size()<taskQueMaxThreshHold;
    })
    //如果又空余，吧任务放入任务队列中
    taskQue_.push(sp);
	taskSize_++;
    //因为新放了任务，任务队列肯定不为空，在notEmpty上进行通知，赶快分配线程执行任务
	notEmpty_.notify_all();
	//return task->getResult;
	return Result(sp);
}
```

threadfunc函数实现

```cpp
void THreadPool::threadFunc()
{
    for(;;)
    {
        std::shared_ptr<Task>task;
        {
            //先获取锁
        std::unique_lock<std::mutext>lock(taskQuemtx_);
        //等待notEmpty条件
        notEmpty_.wait(lock,[&]()->bool{
            return taskQue_.size()>0;
        });
        //从任务队列中去一个任务出来
        auto task=taskQue_.front();
        taskQue_.pop();
        taskSize--;
        
        //把锁释放掉
            //如果依然又剩余生物，继续通知其它的线程执行任务
            if(taskQue_size()>0)
            {
                notEmpty._notify_all();
            }
            //取出一个任务，通知生产者可以进行生产任务了
            notFull_.notify_all();
        }
        
        //从当前线程负载执行这个任务
        if(task!=nullptr)
        {
              // task->run(); //执行任务，把任务的返回值通过setVal返回给
            task->exex();
        }
    }
}
```

知识点补充：C++四种类型强转

> const_cast：去掉常量属性的类型转换
>
> static_cast：提供编译器认为安全的类型转换(没有任何联系之间的转换就被否定了)
>
> reinterpret_cast：类似于C风格的强制类型转换
>
> dynamic_cast：主要用在机场结构中，可以支持RTTI的类型转换

```cpp
const int a=10;
int*p1=(int*)&a;

//const_cast<这里面必须是指针或者引用>
int *p2=const_cast<int*>(&a); //去掉const常量属性


//static_cast  基类类型《=》派生类类型 能不能用static_cast转换？ 可以的，两者属于继承结构
int a=10;
char b=static_cast<int>(a);

//static_cast：没有任何联系之间的转换就被否定了，以下转换会报错
int*p=nullptr;
short*b=static_cast<short*>(p);


//reinterpret_cast:C++风格的C语言强制类型转换
int*p=nullptr;
short*p=interpret_cast<short*>(p);

//dynamic_cast
class Base{
  public:
    virtual void func()=0;
};
class Derivel:public Base{
    public:
    void func()
    {
        cout<<"call Derivel::func"<<endl;
    }
}
class Derivel2:public Base{
    public:
    void func()
    {
        cout<<"calls Derivel2::func"<<endl;
    }
    void derive02func()
    {
        cout<<"call Derive2::derive2func"<<endl;
    }
}
void showFunc(Base*p){
    //dynamic_cast会检查p指针是否指向的是一个Derive2类型的对象
    //p->vfptr->vftable RTTI信息   如果是，dynamic——cast转换类型成功，返回Derive2对象地址
    //否则返回nullptr;
    
    Derive2*pd2=dynamic_cast<Derive2>(p);
    if(pd2!=nullptr)
    {
        pd2->derive02func();
    }
    //动态绑定
    else
    {
           p->func();   //*p的类型
    }
 
}
int main()
{
    Derivel d1;
    Derive2 d2;
    showFunc(&d1);
    showFunc(&d2);
}
```

C++前面的基础知识，构建Any类型

能让一个类型指向其它任意类型：基类类型可以指向派生类类型

```cpp
Any类型：可以接受任意类型数据的类型 
class Any
{
  	public:
    Any()=default;
    ~Any()=default;
    Any(const ANy&)=delete;
    Any&operator=(const Any&)=delete;
    Any(Any&&)=default;
    Any&(operator)=(Any&&)=default;
    
    //这个构造函数可以让any类型接受任意类型其它数据
    	template<class T>
        Any(T data):base_(new Derive<T>(data))
        {
            
        }
    //提取Any中的数据
    template<class T>
    T cast_()
    {
        //从base_找到他所指向的derive对象，从它里面取出data成员变量
        //基类指针=》派生类指针     RTTI
        Derive<T>*pd=dynamic_cast<Derive<T>*>(base_.get());
        if(pd==nullptr)
        {
            throw "type is incompatiable!";
        }
        return pd->data_;
        
    }
    private:
    //基类类型
    class Base{
      public:
        virtual ~Base()=default;
    };
    
    //派生类类型
    template<class T>
    class Drive:public Base
    {
        public:
        Drive(T data):data_(data)
        {
            
        }
        private:
        T data_
    }
    private:
    //定义一个基类的指针
    std::unique_ptr<Base>base_;
};
```

C++20semaphore模拟实现：mutex+条件变量

```cpp
class Sempahore
{
    public:
    Sempahore(int limit=0):resLimit_(0){
        
    }
    ~Semaphore(){
        
    }
    //获取一个信号量操作
    void wait(){
        std::unique_lock<std::mutex>lock(mtx_);
        //等待信号量有资源，没有资源的话，阻塞当前线程
        cond_.wait(lock,[&]()->bool
                   {
                       return resLimit_>0;
                   });
        resLimit_--;
        
        
    }
    //增加一个信号量资源
    void post(){
        std::unique_lock<std::mutex>lock(mtx_);
        resLimit_++;
        cond_.notify_all;
    }
    private:
    std::mutex mtx_;
    std::condition_variable cond;
   	int resLimit_;
}
```

实现接受提交到线程池的task任务执行完成后的返回值类型Result

```cpp
class Result{
    public:
    Result(std::shared_ptr<Task> task,bool isValid=true);
    ~Result=default;
    
    //setVal方法：获取任务执行完成的返回值
    void setVal(Any any);
    
    //get方法：用户获取这个方法获取task返回值
    Any get();
    
    private:
    Any any_;//存储任务的返回值
    Semaphore sem_;//线程通信信号量
    std::shared_ptr<Task>task_;//指向对应获取返回值的任务对象·
    atomic_bool isVail_;//返回值是否有效
};


Reuslt::Reuslt(std::shread_ptr<Task>task,bool isVaild=true):
task_(task),
isVaild_(isvaild_)
{
    task->setRe
}

Any Result::get()  //用户调用
{
    if(!isVaild_)
    {
        return "";
    }
    sem_.wait();  //task任务如果没有执行完，这里会阻塞用户的线程
    return std::move(any_);
}

void Result::setVal(Any any)   //线程执行
{
    //存储task的返回值
    this->any_=std::move(any);
    sem_.post();    //已经获取了人物的返回值，增加信号量资源
    
}
```



时间函数

```
auto last=stdLLchronoLLhigh_resolution_lock(),now()

//每一秒钟返回一次，判断是否空闲时间超过60s
if(poolMpde==CACHED)
{
	if(cv_status::timeout==cond_.wait_for(lock,chrini::second(1)))
	{
		//如果超时时间超过60s,杀死该线程
		auto now=....
		auot dur=std::chrono::duration_cast<std::chorno::seconds>(now-LastTime);
		if(dur.cout()>60&&线程数量>initSize)
		{
			//回收当前线程
			//记录线程相关变量值得修改
			//把线程对象从容器列表中删除
		}
	}
}
```

![image-20220916200857740](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220916200857740.png)

threadpool析构函数

```cpp
//析构之后对象的回收
~ThreadPool()
{
    isRunning=false;
    notEmpty_.notify_all()
    //等待线程池里面所有的线程返回
    //有两种状态：阻塞&正在执行任务中
    unique_lock(mutex)lock(_mtx);
    exitCond_.wait([&]()->bool{
        return threads_.size()==0;
    });
}
```

死锁问题的解决

1.pool线程先获取锁，

2.线程池里面的线程先获取锁

3.



线程池改进

线程池提交任务改进

```
pool.submitTask(sum1,10,20);
pool.submitTask(sum2,1,2,3);
submitTask:可变参模板编程


```

 	2.我们自己造了一个Result以及相关类型，代码多

> packaged_task(funciton函数对象)  async
>
> 使用future代替Result节省线程池代码
>
> ```cpp
> #include<future>
> int sum1(int a,int b)
> {
>     return a+b;
> }
> itn sum2(int a,int,b,int c)
> {
>     return a+b+c;
> }
> int main()
> {
> 	packaged_task<<int>(int,int)>task(sum1);
>     //future<=>Result
>     future<int>res=task.get_future();
>     thread(std::move(task),10,20);
>     t.detach();
>     cout<<res.get()<<endl;
>     
>     //返回值类型
>     template<typename Func,typename...Args>
>     auto sunmitTask(Func&&func,Args&&....args)->(std::future<(decltype(func(args...))>)
>     {
>         decltype(10+20);
>     }
> }
> 
> ```

线程池代码优

```cpp
//使用可变参模板编程，使得submitTask可以接受任意函数和任意数量的参数
 template<typename Func,typename...Args>
    auto sunmitTask(Func&&func,Args&&....args)->(std::future<(decltype(func(args...))>)
    {
        //打包任务，放入任务队列中，
        auto RType=decltype(func(args...));
        auot task=std::make_shared<packaged_task<Rtype>>{
            std::bind(std::forward<func>(func),std::forward<Args>(args));
            
        };
        future<Rtype>result=task->get_future();
        
    }
                                                 
  using Task=std::function<void()>;
 queue<Task>taskQue_;
```

基于c++11/c++17实现的线程池

![image-20220927094509348](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220927094509348.png)

Linux下编译动态库

![image-20220927095505850](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220927095505850.png)



3.Result,Any信号量



线程池项目



并发和并行



多线程的优势

多线程程序一定好吗

1.线程的频繁上下文切换会产生额外的开销

2.线程创建过多会导致系统卡顿

3.产生过多内存碎片



不一定，分请看

需要根据当前程序类型判断，

看程序是IO密集型还是CPU密集型

cpu是单核还是多核

CPU密集型：程序里面的指令都是计算用的

IO密集型：程序里面的指令执行，设计一些IO操作，比如设备，文件，网络操作，(等待客户端连接,IO操作会阻塞CPU)

在多核CPU下，无论IO密集型还是CPU密集型多线程都是具有优势的

但是在单核CPU下，如果任务是IO密集型任务，多线程也是具有优势的，在单线程中同时只能由一个线程运行，在进行IO操作时，CPU通知DMA，DMA通知硬盘讲文件加载得到内存，而在这个过程中，CPU处于空闲状态，这是就可以发挥多线程的优势，让CPU执行其它线上的任务，等数据加载到内存上时，DMA通知CPU，CPU发生中断，然后cpu从内存加载数据，这样可以更好的发挥单线程优势，但是在CPU密集型任务中，比如进行大量数据运算，这个过程始终时需要CPU进行参与的，在单核CPU上利用多线程处理CPU密集型任务，每个任务都需要CPU进行参与，同时还会涉及线程上下文切换，可能有时候还不如单线程执行的快



为了完成任务，创建很多线程可以吗，线程真的越多越好吗

线程的创建和销毁都是非常重的操作

线程本身需要占大量内存

线程的上下文切换要占大量的时间

大量线程同时还行会使系统经常出现锯齿状负载或者瞬间负载量很大而导致宕机



线程同步分为线程互斥和线程通信

线程互斥：mutex和atomic原子类型

线程通信：condition_variable,信号量



死锁问题点：

线程池的线程在notEmpty上等待，没有线程唤醒

