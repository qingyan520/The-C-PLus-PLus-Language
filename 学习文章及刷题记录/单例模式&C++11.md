### 单例模式&C++11

超过100G的log file,log中存IP地址，找出现次数最多的IP地址，topk的ip，如何直接用Linux命令进行实现

假设生成A0~A99一共100个文件，一次读取大文件中的ip，计算每个ip映射的文件号，i=HashBKDR()(ip)%100，这个ip就进入Ai号小文件

再依次读取A0~A99，一个个处理，读取Ai文件，如果Ai大于2G，可以再次进行切分，类似于上面，如果小于2G，那就使用一个map<string,ip>统计次数，这样相同的ip一定进入了一个文件，所以直接统计小文件中的次数即可

出现次数最多的k个IP，建一个k个数的小队，

1.创建一个类，这个对象只能创建在堆上

```cpp
#include<iostream>
using namespace std;
class HeapOnly{
    private:
    HeapOnly(){
        
    }
    
    //拷贝构造私有，并且只声明不实现
    //实现也是可以的，但是没人用 
    HeapOnly(const HeapOnly&)；
    public:
    static HeapOnly*CreateObj(){
        return new HeapOnly;
    }
};
int main(){
    HeapOnly*=HeapOnly::CreateObj();
    
    return 0;
}
```

2.设计一个类，只能在栈上创建对象

```cpp
//禁止operator new和operator delete
```

3.设计一个类，不能进行拷贝

```cpp
//拷贝构造声明成私有，只声明不是先
//拷贝构造后加=delete
```

4.设计一个类，不能被继承

```cpp
//父类构造函数私有化，但是这种方式不够彻底，实际可以被继承，但是限制的是子类继承后不能实例化对象

//C++11final关键字，代表该类不能被继承
```

5.设计一个类，只能创建一个对象(单例模式)

单例模式：一个类只能创建一个对象，即单例模式，该模式可以保证系统中只有一个该类的实力，并提供一个它的全局访问点，该实例所有程序模块共享

```cpp
//1.如何保证全局中只有一个唯一的实例对象
//构造函数私有定义，拷贝构造和复制防拷贝禁掉
//2.提供一个GetInstance获取单例对象
//饿汉模式：程序开始之前就创建对象
//提供一个静态的指向单例对象的成员指针，初始化时new一个对象给他

class Singleton{
    public:
    static Singleton*GetInstance(){
        return _inst;
    }
    
    void Print(){
        cout<<_a<<endl;
    }
    
	private:
    Singleton(){
        
    }
    
    Singleton(const Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Singleton*_inst;
    int _a=0;
};
Singleton::inst=new Singleton;
int main(){
    cout<<Singleton::GetInstance()<<endl;
    Singleton::GetInstance->Print();
}
```



```cpp
//懒汉模式
//假设单例类的构造函数中，要做许多的配置工作，那么饿汉模式就不适合了
class Singleton{
    public:
    //保护第一次需要加锁，后面不需要加锁的场景，可以使用双检查加锁
    //第一次加锁，后面不加锁，保护线程安全，同时提高了效率
    static Singleton*GetInstance(){
		if(_inst==nullptr)
        {
             _mtx.lock();
        	if(_lisy==nullptr)
        	{
            	_inst=new Singleton;
        	}
        	-mtx.unlock();
        }
        return _inst;
    }
    
    void Print(){
        cout<<_a<<endl;
    }
    
	private:
    Singleton(){
        
    }
    
    Singleton(const Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Singleton*_inst;
    int _a=0;
    std::muxtx _mtx;
};
Singleton::inst=new Singleton;
std::mutex
int main(){
    cout<<Singleton::GetInstance()<<endl;
    Singleton::GetInstance->Print();
}
//懒汉模式和饿汉模式的对比：
//懒汉模式优点：简单
//缺点:1.如果单例对象构造函数工作多，初始化比较慢，迟迟进不了入口main函数
//2.如果有多个单例对象，他们之间有初始化的依赖关系，饿汉模式也会有问题，比如有A和B两个单例类，要求A单例先初始阿虎，B必须在A之后进行初始化，

```

