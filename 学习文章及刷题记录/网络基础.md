# 网络基础

TCP/IP

网络四层协议(网络协议栈:负责数据通信工作)：应用层(用户空间)——》传输层——》网络层—–》数据链路层

应用层：我们能传输数据，我们的目的是什么？：根据特定的通信目的，进行数据分析又出力达到某种业务性的目的

传输层：处理传输遇到的问题，保证数据可靠性

网络层：数据转发，数据去哪里的问题

数据链路层：负责数据真正的发送过程

层状结构本质：只有接口的调动关系，增加代码的可维护性和扩展性

交换机：完成局域网内的数据交换



认识协议：

关于通信，同层协议，可以认为自己在和对方层

OSI七层网络模型



网络通信的基本流程

不同层的报头，可能是下层协议的有效载荷

协议共性：

1.报头的大小

2.自定义描述字段

几乎所有的协议，报头中都有一个字段，表明，我们要将有效载荷交往那个字段





TCP/IP五层(四层)模型

以太网通信：本质所有主机都收到了任何数据，只不过经过筛选提交上来了，发给自身的数据

1.局域网中，网络本身的特性要求只能有一个机器进行发送

2.如果网络中的数据发生了碰撞，当前主机是可以检测到的

3.所有的主机都要进行碰撞避免算法



数据链路层通信原理：

1.mac地址1：网卡内置了48为的序号，MAC地址，全球唯一

2.MAC数据帧：
srcMAC dstMAC   有效载荷

```
Linux中查看MAC地址：
ifconfig
```



对于每个网络，都认为路由器是它的局域网上的一台主机

IP：用来标识全网内唯一的一台主机

ipv4:32比特位标识IP地址

ipv6:128位

无论上层协议有多少层，最终们都必须在硬件上进行数据传输





网络编程套接字

端口号(port):

端口号是一个2字节16位的整数

端口号用来表示一个进程，高数操作系统，当前这个数据要交给那个进程进行处理

IP地址+端口号能够标识网络上的某一个主机的某一个进程

一个端口号只能被一个进程占用

TCP协议：

网络字节序：

网络上的数据必须是大端

常见socket接口

```c++
//创建socket文件描述符(TCP/UDP,客户端+服务器)
int socket(int domain,int type,int protocol);

//绑定端口号(TCP/UDP,服务器)
int bind(int socket,const struct sockaddr*address,socklen_t address_len);

//开始监听(TCP,服务器)
int listen(int socket,int backlog);

//接收请求(TCP,服务器)
int accept(int socket,struct sockaddr*address,socklen_t*address_len);

//建立连接(TCP/客户端)
int connect(int sockfd,const struct sockaddr*addr,socklen_t addrlen);
```



sockaddr结构



```cpp
touch udp_client.hpp
```

```cpp
touch udp_server.hpp
```

```
touch udpclient.cc
```

```
touch udpclient.hpp
```

```makefile
cc=g++
.PHONY:all
all:udp_client udp_server
udp_client:udp_client.cc
	$(CC) -o $@ $^ -std=c++11
udp_server:udp_sever.cc
	$(CC) -o $@ $^b-std=c++11
.PHONY:clean
clean:
	rm -f udp_client udp_sever
```

udp_client.hpp

```cpp
#pramgma once
#include<iostream>
#include<sys/socket.h>
#include<sys/type.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<unistd.h>
class UdpClient
{
 	private:
    int sockfd;
    int server_ip;
    int server_port;
    public:
    UdpClient(int _ip,int _port):
    server_ip(_ip),
    server_port(_port){
       
        
    }
    
 
    //客户端不需要进行绑定
    //服务器为何要bind一个接口：
    //服务器是为了给别人提供服务的，别人一定要知道你个ip和端口，端口一定要是众所周知的端口，而且bind之后，不能轻易改变
    //客户端访问server，端口只要是唯一的即可，不需要和特定client进程强相关
    //client端口可以动态进行设置
    //sendto类似接口，client直接在OS层面会自动给client获取一个唯一的端口
    bool InitUdpClient(){
        sockfd=socket(AF_INET,SOCK_DGRAM,0);
        if(coketfd<0)
        {
            cout<<"socket error!"<<endl;
            return;
        }
        return true;
    }
    
    void Start()
    {
        struct sockaddr_in peer;
                    meset(&peer,'\0',sizeof(peer));
        peer.sin_family=AF_INET;
        peer.sin_port=htons(server_port);
        peer.sin_addr.s_addr=inet_addr(server_ip.c_str);
        string msg;
        for(;;){

            cout<<"Please Enter# "<<endl;
            cin>>msg;
            sendto(sockfd,msg.c_str(),msg,size(),0,(struct sockaddr*)&peer,sizeof(peer))
             char buf[128];
            struct buffer_in temp;
            socklen_t len=sizeof(temp);
             ssize_t size=revcfrom(sockfd,buffer,sizeof(buffer)-1,0,(struct socket*)&temp,&len);
            if(size>0)
            {
                cout<<buffer<<endl;
            }
        }
    }
    
    ~UdpClient(){
        if(sockfd>=0)
        {
            close(sockfd);
        }
    }
    
    
};
```

udp_client.cc

```cpp
#include "udp_client.hpp"
int main(int argc,char*argv)
{
    if(argc!=3)
    {
        cout<<"Usage:"<<endl;
    }
    string ip=argv[1];
    int port=atoi(argv[2]);
    
    Udpclient*ucli= new UdpClient(ip,port);
    ucli-<InitUdpClient();
    ucli->Start();
    
}
```

udp_server.hpp

```cpp
#pragma once
#include<iostream>
#include<string>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/in.h>
#include<unistd.h>
#define DEFAULT 8081
using namespace std;
class UdpServer
{
    private:
    int port;
    //IP地址
    string ip;
    int socketfd;
    public:
	UdpServer(int _Port=DEFAULTstirng  _ip):port(_port),socketfd(-1),ip(_ip){
        
    }
    
    bool InitUdpServer(){
        socketfd=socket(AF_INET,SOCK_DGRAM,0);
        if(socketfd<0)
        {
            cerr<<"socket error"<<endl;
            return false;
        }
        cout<<"socket create success ,socketfd:"<<socketfd<<end;
        struct sockadde_in local;
        meset(&loacl,'\0',sizeof(local));
        local.sin_family=AFINET;
        local.sin_port=htons(port);
        //local.sin_addr.s_addr=inet_addr(ip.c_str());
      local.sin_addr.s_addr=INADDR_ANY;  
        if(bind(socketfd,(struct addr*)&local,sizeof(local))<0)
        {
            cerr<<"error"<<endl;
        }
        cout<<"bind success"<<endl;
        return true;
    }
    #define SIZE 128;
    
    void Start(){
        char buffer[SIZE]=0;
        for(;;){
            struct sockaddr_in peer;
            socket_t len=sizeof(socketaddr_in);
            ssize_t size=recvfrom(socketfd,buffer,sizeof(buffer)-1,0,(sturct socketaddr*)&peer,&len);
            if(size>0)
            {
                buffer[size]=0;
                int _port=ntohs(peer.sin_port);
                string _ip=inet_ntoa(peer.sin_addr);
                cout<<_ip<<" "<<_port<<"#"<<buffer<<endl;
                string msg="server get!";
                msh+=buffer;
                sendto(sockfd,msg.c_str(),msg.size(),0,(struct socket*)&peer,len)
            }
            else
            {
                cerr<<"recvfrom error"<<endl;
            }
        }
    }
       
    ~UdpServer(){
        if(sockfd>=0)
        {
            colse(sockfd);
        }
    }
};
```

![image-20220305160027842](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220305160027842.png)

udp_server.cc

```cpp
#include "udp_server.hpp"
int main(int argc ,char* argv[])
{
    if(argc!=2)
    {
        cout<<argv[0]<<"port"<<endl;
    }
   // string ip="127.0.0.1";
    int port=ator(argv[0]);
    UdpServer*srv=new UdpServer(ip,port);
    s->InitUdpServer();
    srv->start();
} 
```

netstat -nlup

sz 文件名：从服务器下载软件

rz 文件：从本地上传文件到服务器









TCP服务器

```shell
touch tcp_server.hpp
touch tcp_server.cc
touch tcp_client.hpp
touch tcp_client.cc
```

```makefile
CC=g++
.PHONY:all
all:tcp_server tcp_client
tcp_server:tcp_server.cc
	$(CC) -o $@ $^ -std=c++11
tcp_client:tcp_client.cc
	$(CC) -o $@ $^ -std=c++11
.PHONY:clean
clean:
	rm -f tcp_server tcp_client
```

tcp_server.hpp

```cpp
#pragam once
#include<iostream>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/iney/h>
#include<cstring>
#include<unistd.h>
#include<sys/wait.h>
#include<signal.h>

class TcpServer
{
    private:
    int port;//监听套接字
   	int listen_sock;
    
    public:
	TcpServeeer(int _port=8081):listen_port(_port){
        
    }
    
    bool InitTcpServer(){
        listen_sock=socket(AF_INET,SOCK_STREAM,0);
        if(listen_sock<0)
        {
            cerr<<"socket error"<<endl;
            exit(2);
            return false;
        }
        struct sockaddr_in loacl;
        memset(&local,'\0',sizeof(loacl));
        loacl.sin_family=AF_INET;
        local.sin_port=honts(port);
        local.sin_addr.s_addr=INADDR_ANY;
        if(bind(listen_sock,(struct sockaddr*)&local,sizeof(local))<0)
        {
            cout<<"bind error"<<endl;
            exit(3);
            return false;
        }
        
        if(listen(listen_sock,5)<0)
        {
            cout<<"listen error"<<endl;
            return false;     
        }
        
        return true;
    }
    
    vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
            cout<<"get a new link:"<<"["<<inet_ntoa(peer.sin_addr)<<"]:"<<ntohs(peer.sin_port)<<endl;
       string ip=inet)ntoa(peer.sin_addr);
       int port=ntohs(per.sin_port);
       pid_t id=fork();
       if(id==0){
           close(listen_sock);
           if(fork()>0){
               exit(0);
           }
           Service(sock,ip,port);
           exit(0);
       }
       //waitpid();//阻塞的
	   close(sock);
        waitpid(id,nullptr,0);
        }
    }
    
    void Service(int sock,string ip,int port){
        char buf[1024]=0;
        while(true){
            ssize_t size=read(sock,buf,sizeof(buf)-1);
            if(size>0)
            {
                buf[size]=0;
                cout<<"["<<ip<<']:'<<port<<"#"<<buf<<endl;
                write(sock,buf,size);
            }
            else if(size==0)
            {
                cout<<ip<<":"<<port<<"close!"<<endl;
                break;
            }
            else
            {
                cerr<<sock<<"read error!"<<endl;
                break;
            } 
        }
        close(sock);
        cout<<"service done"<<endl;
    }
    
    ~TcpServer(){
        if(listen_sock>=0)
        {
            close(listen_lock);
        }
    }
}
```

tcp_server.cc

```cpp
#include"tcpserver.hpp"
int main(int argc,char argv[])
{
	if(argc!=2){
        cout<<"Usage"<<endl;
        exit(0);
    }
    
    TecpServer tsvr(atoi(argv[1]));
    tsvr.InitServer();
    tsvr.Loop();
    return 0;
    
        
}
```

tcp_client.hpp

```cpp
#include<iostream>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<string>
#include<n

class TcpClient{
  private:
    string svr_ip;
    int svr_ip;
    int sock;
   public:
    TcpClient(string _ip,int _port):svr_ip(_ip),svr_port(_port){
        
    }
    ~TcpClient(){
        if(sock>=0)
        {
            close(sock);
        }
    }
    
    void InitTcpClient(){
        sock=socket(AF_INET,SOCK_STREAM,0);
        if(sock<0)
        {
            cout<<"socket error"<<endl;
            exit(1);
        }
    }
	void Start(){
        struct sockaddr_in peer;
        meset(&peer,0,sizeof(peer));
        peer.sin_family=AF_INET;
        peer.sin_port=htons(svr_port);
        peer.sin_addr.s_addr=inet_addr(svr_ip.c_str());
        if(connect(sock,(struct sockaddr*)&peer,sizeof(peer))==0){
            //success
            cout<<"connect success!"<<endl;
            Request(sock);
        }
        else{
            cout<<"connect error!"<<endl;
        }
        
    }   
    
    
    Request(int sock){
        string msg;
        char buffer[1024];
        while(true){
            cout<<"Please Enter#";
            cin>>msg;
            write(sock,msg.c_str(),msg.size());
            
           ssize_t s= read(sock,buffer,sizeof(buffer)-1);
            
            if(size>0)
            {
                buffer[size]=0;
                
            }
            cout<<"server echo#"<<endl;
            
        }
    }
};
```

tcp_client.cc

```
#include"tcp_client.hpp"
int main(int argc,char*argv[])
{
	if(argc!=3){
	cout<<"Usage!"<<endl;
	exit(0);
	}
	TecpClient tcli(argv[1],atoi(argv[2]));
	tcli.Start();
	
}
```

TCP是面向连接的，所以在发送数据之前需要建立连接

服务器端，必须不断的花时间，进行检查是否有新的连接

```
ssize_t read(int fd,void*buf,size_t count);
1.>0:实际读取到了多少字节
2.==0:说明对端关闭了连接
3.<0:说明读取时遇到了错误
```

tcp socket中，读写都是一个sock(fd),全双工通信体系 

升级版本:多线程版本Tcp服务器

```cpp
#include<pthread.h>
class Prama{
    public:
    int sock;
    string ip;
    int port;
    public:
    Prame(int _sock,stirng _ip,int _port):sock(_sock),ip(_ip,),port(_port){
        
    }
    ~Preame(){
        
    }
};
static void* HanderRequst(void*arg){
    Prama*p=(Prama*)arg;
    
	pthread_detach(pthread_self());
    
    Service(p->sock,p->ip.p->port);
    delete p;
    close(p->sock);
    return nullptr;
}

 vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
            pthread_t tid;
            
          // int*p=new int(sock); 
            Prame*p=new Prame(sock,ip,port);
                pthread_create(&tid,nullptr,HanderRequest,p);
           
        }
    }
```

线程版本升级:基于线程池

```cpp
#include<pthread.h>
#include"ThreadPool.hpp"

class Prama{
    public:
    int sock;
    string ip;
    int port;
    
    public:
    Prame(int _sock,stirng _ip,int _port):sock(_sock),ip(_ip,),port(_port){
        
    }
    ~Preame(){
        
    }
};
static void* HanderRequst(void*arg){
    Prama*p=(Prama*)arg;
    
	pthread_detach(pthread_self());
    
    Service(p->sock,p->ip.p->port);
    delete p;
    close(p->sock);
    return nullptr;
}

 vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
           	
        }
    }
```

```
Task.hpp

```









```cpp
//server.cpp
```

<hr>

```cpp
//server.cc
#include<iostream>
#include<string>
#include<arpa/in.h>
#include"protocol.hpp"
void*Routine(void*arg){
    int sock=(int*)arg;
    delete arg;
    //定制协议
    
    while(1){
        request_t rq;
        response_t rsp;
        sszie_t size=recv(sock,&rq,sizeof(rq),0);
        if(s>0){
            switch(rq.op){
                case '+':
                    rsp.result=rq.x+rq.y;
                    break;
                case '-':
                    rsp.result=rq.x-rq.y;
                    break;
                case '*':
                    rsp.restult.rq.x*rq.y;
                    break;
                case '/':
                    if(rq.y==0){
                        rsp.code=1;
                    }
                    else{
                        rsp.result=rq.x/rq.y;
                    }
                    break;
                case '%':
                     if(rq.y==0){
                        rsp.code=2;
                    }
                    else{
                        rsp.result=rq.x%rq.y;
                    }
                    break;
                delault:
                    rsp.code=3;
                    break;
            }
        }
        send(sock,&rsp,sizeof(rsq),)
    }
    
}
int main(int argc,char*argv[]){
    if(arrgc!=2){
        cout<<"Usage!"<<endl;
    }
    int listten_sock=socket(AF_INET,SOCK_STREAM,0);
    if(listen_sock<0){
        exit(0);
    }
    struct sockaddr_in local;
    local.sin_family=AF_INET;
    local.sin_port=honts(atoi(a));
    loacl.sin_addr.s_addr=hontl(INADDR_ANY);
    if(bind(listen_sock,(struct sockaddr)&local,sizeof(local)<0)){
        exit(2);
    }
    if(listen(listen_sock,5)<0){
        exit(4);
    }
    struct sockaddr_in peer;
    socklen_t len=sizeof(peer);
    for(;;){
        int sock=accept(listen_sock,&peer,&len);
        if(sock<0){
            continue;
        }
        pthread_t tid;
        int*p=new int(sock);
        pthread_create(&tid,nullptr,Routine,p);
    }
    
    
}
```

<hr>

```cpp
//Client.hhp
```

<hr>

```cpp
//Client.cc
//server.cc
#include<iostream>
#include<string>
#include<arpa/in.h>
#include"protocl.hpp"
int main(int argc,char*argv[]){
    if(arrgc!=3){
        cout<<"Usage!"<<endl;
    }
    int listten_sock=socket(AF_INET,SOCK_STREAM,0);
    if(listen_sock<0){
        exit(0);
    }
    struct sockaddr_in peer;
    peer.sin_family=AF_INET;
    peer.sin_port=honts(argv[2]);
    peer.sin_addr.s_addr=inet_addr(argv[1]);
    if(connect(sock,(struct sockarr*)&peer,sizeof(peer))<0){
        cout<<"conncect error!"<<endl;
        exit(3);
    }
    while(1){
        request_t rq;
        cout<<"输入数据:"<<endl;
        cin>>rq.x;
        cin>>rq.y;
        cin>>rq.op;
        send(sock,&rq,sizeof(rq),0);//结构化的数据为什么没有序列化，
        response_t rsp;
        recv(sock,&rsp,sizeof(rsp),0);
        cout<<rsp.code<<endl;
        cout<<rq.x<<rq.op<<rq.y<<"="<<rsq.result<<endl;
        
    }
}
```

```cpp
typedef struct request{
    int x;
    int y;
    int op; //+ - * / %
}request_t;

typedef struct response{
    int code;//>success,1,2,3,4代表错误信息
    
}response_t;
```

http协议

URL：同意资源定位符

协议名称+登录信息+服务器地址+服务器地址+带层次的文件路径+查询关键字+片段标识

http协议本质是要获得某种资源

资源路径：在对应的服务器上，所要的资源位于什么位置

大部分上网都是在进行进程间通信

1.把服务器上的资源那道本地

2.把本地的数据推送到服务器

http是基于请求与响应的应用层服务

常规情况下，http底层使用的传输层协议是tcp

```cpp
//http_server.cc
#include<iostream>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<sys/types.h>
#include<sys/types.h>


int main(){
    int listen_sock=socket(AF_INET,SOCK_STREAM<0);
    if(listen_sock<0){
        cout<<"socket error!"<<endl;
        exit(1);
    }
    
    struct sockaddr_in local;
    local.sin_family=AF_INET;
    local.sin_poar=htons(atoi(argv[1]));
    local.sin_addr.s_addr=INADDR_ANY;
    if(bind(listen_sock,(struct sockaddr*)&local,sizeof(loacl))<0)
    {
        cout<<"bind error!"<<endl;
        exit(2);
    }
    if(listen(listen_sock，5)<0){
        exit(3);
    }
    struct sockaddr_in peer;
    socklen_t len=sizeof(peer);
    for(;;){
        int sock=accept(listen_sock,&peer,&len);
        if(sock<0){
            cout<<"accept error!"<<endl;
            continue;
        }
        if(fork()==0){
            if(fork()>0){
                exit(0);
            }
            close(listen_sock);
            //read http request;
            char buffer[1024];
            recv(sock,buffer,sizeof(buffer),0);
            cout<<"########http request begin########"<<endl;
            cout<<buffer<<endl;
            cout<<"########http request end########"<<endl;
            exit(0);
        }
        close(sock);
        waitpid(-1,nullptr,0);
    }
}
```

http请求有=由如下几个部分构成：

请求方法   请求资源路径  http版本协议

key: value

亲求行：请求方法 url http版本

请求报头：key value（存在多行内容）

空行

请求正文(非必须):(一般都是用户的信息或者数据)

所谓的http协议在服务器和客户端中，一般涉及非常多的文本分析

客户端如何判断已经将response报头读取完毕呢？

循环按行读取，知道读取到空行







respnse:
状态行   http版本   状态码         状态码描述

响应报头

空行

响应正文

```
ifstream in(".html");
if(in.is_open()){
	in.seekg(0,std::ios::end);
	size_t len=in.tellg();
	in.seekg(0,std::ios::beg);
	char*file=new char[len];
	in.read(file,len);
	in.close();
	string status_line="http/1.0 status Ok";
	send(sock,stratus_line.c_str(),status_line.size(),0);
	send(sock,response_header.c_str);
	send(sock,file,len,0);
	
} 
```



http协议本质是基于tcp协议，进行文本设置完成协议表达

请求方法     url        http版本

属性：值

空行

请求正文



HTTP请求方法

GET：获取资源，获得一个简单文本，也可以传递参数

POST：推送资源数据，通过正文传递参数

GET和POST如果传参，GET通过url，POST通过正文，POST会比GET传递更多的数据，更加私密

HEAD：

```
int flag=1;
setockopt(listen_sock,SOL_SOCKET,SO_REUSEADDR,&flag,sizeof(flag));
```

DELETE:删除

OPTIONS：询问支持方法

HTTP状态码：

```
1XX        信息性状态码        接受的请求正在处理
2XX        成功状态码          请求正常处理完毕
3XX        重定向状态码        需要进行附加操作完成请求
4XX        客户端错误状态码    服务器无法处理请求
5XX        服务端错误状态码    服务器请求出错
```

例如200(OK),404(NOT FOUND),403(Forbidden),302(Redirect,重定向)，504(Bad Gateway)

重定向分为临时重定向和永久重定向：本质区别是影响客户端标签，决定客户端是否需要更新目标地址

301：永久移动/永久重定向

302：临时重定向

307：http1.0临时重定向

```cpp
string status_line="http/1.1 307 Temporary Redirect\n";
string response_header="Content_Length:"+to_string(len);
response_header+="\n";
response_header+="location:www.baidu.com\n";
blank=" \n";


```

Http常见Header:

Content_Type:数据类型(text/html)

Content_Length:Body的长度

Host:客户端告知服务器，所请求的资源是在那个主机的那个端口上

User_Agent:声明用户的操作系统和浏览器版本信息

referer:当前页面是从哪个页面跳转过来的

location:搭配3xx状态码进行使用，告诉客户端接下来要去哪里访问

Cookie:用于在客户端存储少量信息，通常用于实现会话(sesson)的功能



http等上层协议，本质其实根本不是把请求与响应发送给网络，而是将自己的数据给了下层协议(TCP)



传输层：将数据从

 

端口号范围画法：0~1023知名端口，都是固定的

netstat:查看网络状态(netstat -nltp)

n:拒绝显示别名，能显示



pidof

<hr>

UDP协议

1.UDP如何保证报头和有效载荷分离

UDP前8个字节为报头信息，定长报头

2.如何将有效载荷交给上层：通过目的端口号

3.什么是报头：

udp协议属于内核协议栈(C语言)，用C语言如何表示报头？

```cpp
struct udp_header{
​		unsigned int srcc_port:16;
​		unisgned int  dst_port:16;
​		unsigned int udp_len:16;
		unsigned int udp_chk:16;
}
```

4.传输层是如何通过端口找到对应进程的





<hr>

TCP传输控制协议

保证可靠性的协议

1.报头和有效载荷如何分离



2.tcp如何决定将有效载荷交付给上层那个协议





tcp是有接受和发送缓冲区的

重传机制

发送缓冲区

一般而言，ACK字段是被经常设置的

链接建立阶段，SYN被设置

三次握手属于通信细节，上层应用不需要关心

三次握手由OS(TCP)自动完成

connect发起三次握手，accept获取已经建立好的链接，已经完成三次握手的链接

SYN

SYN+ACK

ACK



FIN

ACK





为什么要有三次握手和四次挥手

链接建立异常的情况下，大概率已经建立的连接是在client端的

谁最后发送ACK，谁就先维护连接

如果是偶数次连接，最后的异常连接一定是挂在server



TCP三次握手

SYN：请求建立连接

ACK：应答

FIN：断开连接

三次握手：

 第一次握手

客户端

携带标志位：SYN

可以随机产生32位序号：1000(可携带数据)

服务器：

检测SYN的值是否为1



第二次握手

服务器：
ACK标志位+确认序号

​	客户端随即序号+1

发起一个连接请求

​	SYN+32随即请求

​	

客户端：

检测标志位：1

确认需要释放正确



第三次握手

客户端：发送确认数据包

​	ACK+确认需要

​	服务器的随即序号+1

服务器：

​	检测ACK是否为1

​	确认序号是否正确



![image-20220318212337727](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220318212337727.png)





四次挥手断开连接

那一端主动断开连接都可以，需要FIN标志位

编号：对方最后发送ACK的时候携带的确认序号

第一次挥手

客户端：发送断开链接的请求(FIN+序号；ACK+序号)

server:检测FIN的值是否为1；ACK的作用：告诉对方之前发的数据收到了多少

第二次

server:给client发一个确认数据包(ACK+确认编号(FIN对应的序号+1+携带数据大小))

客户端：检测ACK值

​				检测确认序号

第三次

 服务器端：

发送断开连接的请求

FIN+序号

ACK+序号

第四次

ACK



TCP状态转换

1.2MSL

a.等待时长

b.主动关闭连接的一方，处于TIME_WAIT状态

c.一般是30s



查看网络相关状态

netstat -nltp:

netstat -nlup:

端口复用

```cpp
//绑定之前设置的端口
int flag=1;
setsockopt(sodkfd,SOL_SOCKET,SO_RESUADDR,&flag,sizeof(flag));
```



I/O多路转接

先构建一张与文件描述符有关的表，将要监听的文件描述符添加到该表中

然后调用一个函数，监听该表中的文件描述符，知道这些描述符表中的一个进行I/O操作时，该函数才返回(该函数是阻塞函数；函数对文件描述符的检测操作是由内核完成的)

在返回时，他告诉进程有多少(那些文件描述符)要进行I/O操作

 

select函数

```
int select(int nfds,
fd_set*readfds,//传入传出参数
fd_set*writefds,
fd_set*exceptfds,
struct timeval*timeout
参数:
nfds:要检测的文件描述符中的最大fd+1/1024
readfds:读集合
writefds:写集合
exceptfds:异常集合
timeout：
	NULL:永久阻塞
		当检测到fd变化时返回
    timeval a;
    	a.tv_sec=0;
    	a.tv_usec=0;
    	
```

select函数示例：

客户端A~F连接到服务器。分别对应问价描述符3，4，100，101，102，103

fd_set reads;

FD_SET(3,&reads);

select(103+1,&reads,NULL,NULL,NULL);

```cpp
//伪代码
#include<iostream>
using namespace std;
int main()
{
    int lfd=socket();
    bind();
    listen();
    
    //创建文件描述符表
    fd_st reads temp;
    //初始化
    FD_ZERO(&reads);
    //监听的lfd加入到读集合
    FD_SET(lfd,&reads);
    int maxfd=lfd+1;
    while(1)
    {
        //委托检测
        temp=reads;
        int ret=select(maxfd,&temp,NULL,NULL,NULL);
        
        //是不是监听的
        if(FD_ISET(lfd,&temp))
        {
            //接受新连接
            int cfd=accept();
            //cfd加入到读集合
            fd_set(cfd,&reads);
            //更新maxfd;
            if(cfd>maxfd) 
            {
                maxfd=cfd+1;
            }
            
        }
        d
        //客户端发送数据
        for(int i=lfd+1,i<maxfd;i++)
        {
            if(fd_isset(i,&temp))
            {
			int len=	read();
                if（len==0)
                {
                    fd_clr(i,&reads);
                    
                }
                write();
            }
        }
    }
}
```

代码实现

```cpp
int main()
{
     int listen_sock=socket(AF_INET,SOCK_STREAM<0);
    if(listen_sock<0){
        cout<<"socket error!"<<endl;
        exit(1);
    }
    
    struct sockaddr_in local;
    local.sin_family=AF_INET;
    local.sin_poar=htons(atoi(argv[1]));
    local.sin_addr.s_addr=INADDR_ANY;
    if(bind(listen_sock,(struct sockaddr*)&local,sizeof(loacl))<0)
    {
        cout<<"bind error!"<<endl;
        exit(2);
    }
    if(listen(listen_sock，5)<0){
        exit(3);
    }
    struct sockaddr_in peer;
    socklen_t len=sizeof(peer);
    
    
    fd_set reads,temp;//文件描述符集合
    int maxfd=listen_sock;//最大文件描述符·
    FD_ZERO(&reads);
    FD_SET(listen_sock,&reads);
    while(1)
    {
        
        
        temp=reads;
        //委托内核做I/O检测
        int ret=select(maxfd+1,&temp,NULL,NULL,NULL);
        if(ret==-1)
        {
            cerr("select error!");
            exit(0);
        }
        
        //有客户端发起了新连接
        if(FD_ISSET(lfd,&temp))
        {
            //接受连接
            int cfd=accept(lfd,(struct sockaddr*)&peer,&len);
            if(cfd=-1)
            {
                exit(0);
            }
            
            //将cfd加入到待检测的读集合，下一次就可以检测到了
            FD_SET(cfd,&reads);
            //更新最大文件描述符
            maxfd=maxfd<cfd? cfd:maxfd;
        }
        
        //已经连接的客户端发数据
        for(int i=listen_sock+1，i<=maxfd;i++)
        {
            if(FD_ISSET(i,&temp))
            {
                char buffer[1024]={0};
                int len=recv(i,buf,sizeof(buf),0);
                if(len==-1)
                {
                    exit(0);
                }
                else if(len==0)
                {
                    close(i);
                    //从读集合种删掉
                    FD_CLR(i,&reads);
                }
                else
                {
                    printf("recv buf:%s\n",buf);
                    send(i,buf,strlen(buf),0);
                }
            }
        }
    }
}
```

poll可以突破1024的限制：

![image-20220319170022752](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220319170022752.png)



epoll函数

```
该函数生成一个epoll专用的文件描述符
int epoll_create(int size)//生成一个树节点
size:epoll上能关注的最大文件描述符
```

```
用于控制某个epoll文件的文件描述符实践，可以注册，修改，删除
int epoll_ctl(int epfd,int op,int fd,struct epoll_event*event);
参数：
epfd:epoll_create生成的epoll专用的文件描述符
op:
EPOLL_CTL_ADD ---注册
EPOLL_CTL_MOD ---修改
EPOLL_CTL_DEL ---删除
fd:关联的文件描述符
event:高数内核要监听什么事件，等待IO事件的发生，可以设置阻塞的函数

```

```
int epoll_wait(int epfd,
struct epoll_event*events,//数组
int maxevents,//数组容量
int timeout);
```

epoll伪代码 

```cpp
int main()
{
	//创建监听套接字
    int lfd=socket();
    //绑定
    bind();
    //监听
    listen();
    int epfd=epoll_create(3000);
    
    //存储发送变化的fd对应的信息
    struct epoll_event all[3000];
    //初始化epoll
    struct epoll_event ev;
    //在ev种初始化lfd的信息
   	ev.enents=EPOLLIN;
    ev.data.fd=lfd;
    epoll_CTL(epfd,EPOLL_CTL_ADD,lfd,&ev);
    while(1)
    {
        //委托内核检测事件
       int ret=epoll_wait(epfd,all,3000,-1);
       //根据ret遍历all数组
        for(int i=0;i<ret;++i)
        {
            int fd=all[i].data.fd;
            //有新的连接
			if(fd==lfd)
            {
                //接受连接请求-accept不阻塞
                int cfd=accept();
                //cfd上述
               ev.events.=EPOLLIN;
 			  ev.data.fd=cfd;               EPOLL_CTL(epfd,EPOLL_CTL_ADD,cfd,&ev);
                
            }
            //已经连接的客户端有数据发送过来
            else
            {
                //只处理客户端发来的数据
                if(!all[i].events&EPOLLIN)
                {
                    continue;
                }
                //读数据
               int len=recv();
                if(len==0)
                {
                    close(fd);
                    //检测的fd从树上删除
                    EPOLL_CTL(epfd,EPOLL_CTL_DEL,fd,NULL);
                }
                //写数据
                send();
            }
        }
    }
}
```



epoll三种工作模式

1.水平触发模式 —根据读来解释

只要fd对应的fd缓冲区有数据

epoll_wait返回

返回的次数与发送数据的次数没有关系

```cpp
 
```

2.边沿触发模式-ET

客户端给Server发数据：发一次数据Server的epoll_wait被触发一次，返回一次；不在乎数据是否读完

如果读不完，1如何全部读出

while(recv());

3.边沿非阻塞触发：效率最高

如何设置非阻塞？

```
1.open()
通过设置flags
必须O_WDRW|O_NONBLOCK
终端文件:/dev/tty
2.fcntl
int flag=fcntl(fd,F_GETFL);
flag|=O_NONBLOCK;
fcntl(fd,F_SETFL,flag);
```

将缓冲区数据全部读完

```cpp
while(recv()>0)
{
	printf();
}
//当缓冲区数据读完之后，返回值是否为0？

```



文件描述符突破1024限制

select突破不了，需要重新编译内核

poll和epoll可以突破1024限制

poll内部链表

epoll红黑树

1.查看文件描述符上限:cat /proc/sys/fs/file-max

2.通过配置文件修改上限值：sudo vim /etc/security/limits.conf

```
✳	soft	nofile		8000
✳	hard	nofile		8000
```

重启/注销虚拟机





UDP广播和组播

广播

Server端只发送数据，需要一个广播地址，发送到=固定端口

客户端需要绑定特定端口

广播地址：

```
服务器
创建套接字-socket
fd绑定服务器Ip和端口
初始化客户端IP和端口信息

发送数据
	sendto(fd,buf,len,0,(struct sockaddr*)&peer);
设置广播权限
setsockopt();

```

```
客户端
创建套接字
显示绑定IP和端口
接受数据-server数据
recvfrom();

```

```
适用范围：只适用于局域网
```

代码实现

```cpp
//server.cc
int main()
{
    int fd=socket(AF_INET,SOCK_DGRAM,0);
    if(fd==-1)
    {
        return;
    }
    struct sockaddr_in peer;
    peer.sin_famliy=AF_INET;
    peer.sin_port=htons(8087);
    peer.sin_addr.s_addr=htonl(INADDR_ANY);
    int ret=bind(fd,&peer,sizeof(peer));
    struct sockaddr_in peer;
    meset(&peer,0,sizeof(peer));
    peer.sin_famliy=AF_INET;
    peer.sin_port=honts(6767);
    //所有客户端都使用广播数据
    peer.sin_addr.s_addr=inet_addr("192.168.123.255");
    //服务器开放广播权限
   int flag=1; setsockopt(fd,SOL_SOCKET,SO_BROADCAST,&flag,sizeof(flag));
    while(1)
    {
        int num=0;
        char buf[1024]={0};
        int ret=sendto(fd,buf,strlen(buf)+1,0,&peer,&peer,sizeof(peer));
    if(ret==-1)
    {
        break;
    }
    }
    close(fd);
}
```

```cpp
//CLient.cc
int main()
{
    int fd=socket(AF_INET,SOCK_DRGAM,0);
    
    //显示绑定IP和端口
    struct sockaddr_in client;
    meset(&client,0,sizeof(client));
    client.sin_famliy=AF_INET;
    client.sin_port=htons(7676);
    client.sin_addr.s_addr=inet_addr("0.0.0.0");
    if(bind(fd,&client,szieof(client)));
    
    //接受数据
    while(1)
    {
       	char buf[1024]={0};
        int len=recvfrom(fd,buf,sizeof(buf),NULL,NULL);
        if(len==-1)
        {
            
        }
        printf("client recv buf:%s\n",buf);
        
    }
    close(fd);
}
```

组播

```

```



本地套接字编程

利用本地套接字进行进程间通信

```
1.文件格式
管道：P
套接字：s
两者都是伪文件

2.服务器端
	创建套接字
	int lfd=socket(AF_LOCAL,SOCK_STREAM,0);
	绑定
	struct sockaddr_un serv;
	serv.sun_famliy=af_loacl;
	strcpy((ser.sun_path,"server.socket"));
	//现在还没有该文件，bind成功之后会被创建
	bind(lfd,(struct sockaddr*)&serv，sizeof(serv));
	
	设置监听
	listen();
	等待接受请求
	struct sockaddr_un client;
	int len=sizeof(client);
	int cfd=accept(lfd,&client,&len);
	
	通信
	send
	recv
	
	断开连接
	close(fd);
	close(lfd);
2.客户端
	创建套接字
	int fd=socket(AF_LOCAL,SOCK_STREAM,0);
	绑定套接字文件
	struct sockaddr_un client;
	client.sun_family=af_local;
	strcpy(client.sun_path,"client.socket");
	bind(fd,(struct sockaddr*)&client,len);
	
	连接服务器
	connect(fd,&serv,sizeof(serv));
```



心跳包

```
1.判断客户端和服务器是否处于连接状态

```



Libevent

```
1.创建一个事件处理框架
2.创建一个事件
3.事件添加到事件处理框架上
4.开始事件循环
5.释放资源
envent_base_free(struct envent_base*base);
```

```
1.创建一个事件处理框架
 struct envent_base* envent_base_new(void)
其中有消息循环，需要自己启动
```

```
2.创建一个事件
#define EV_READ 0x02
#define EV_WRITE 0x04
#define EV_PERSIST 0x10 //持续触发
#define EV_ET 0x20 //边沿模式
struct envent*envent_new(
	struct envent_base*base,
	evutil_socket_fd,//文件描述符
	short what,
	envent_callback_fn cb,//事件处理动作
	void*arg//上一个函数的参数
)
```

```
开始事件循环
int envent_dispatch(struct even_)
```





















































![image-20220321184321818](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220321184321818.png)

只有client close(fd)会导致server端存在处于closer_wait状态的连接

如果后期我们发现server存在大量的close_wait状态的连接，需要排查以一下是否是自己的代码有bug,没有及时关闭close(fd),造成fd泄漏，同时也可能造成连接资源没有释放完全

为什么要进行TIME_WAIT:

 

滑动窗口？

既然tcp可以一次发送多个tcp segment，可不可以一次就把数据发完？不可以，还要考虑对方的接受能力

滑动窗口:发送发不用等待ACK一次所能发送的数据最大量，滑动窗口的大小==TCP窗口大小(对方的接受能力)

窗口哦偶大小表示的是对放的接受能力，衡量的是接受缓冲区剩余空间的大小

滑动窗口在自己的发送缓冲区种，限定一块区域可以直接发送

滑动窗口的数据会被删除吗？不会

容许丢失的ACK响应而不用重传

给响应提一个要求

当网络拥塞的时候，正确的做法是：尽量不发或者少发数据，等网络恢复之后再次发送

滑动窗口的大小=min(自己的接受能力，拥塞窗口的大小)

延迟应答

面向字节流



tcp底层为什么要维护连接队列，不能没有，也不能太长：可以当内部有人离开的时候，立马从连接队列选取一个链接进行处理(保证服务器几乎100%工作)，与其维护长连接，造成client等待太久，并且占有大量暂时占用不到的资源，不然吧这些资源部分节省处理给server用



所谓的非阻塞轮询本质是在做时间就绪的检测工作



将文件描述符设置为非阻塞状态

```cpp
#include<unistd.h>
#include<fcntl.h>

int fl=int fcntl(int fd,F_GETFL);
if(fl<0)
{
	cerr<<"error!"<<endl;
}
fcntl(fd,F_SETFL,fl|O_NONBLOCK);
```

如果非阻塞读取数据的时候，如果没有就绪，read是以出错的形式返回









I/O多路转接之select:本质是通知上层，就绪事件的通知机制等

只要底层有数据，只要底层有空间，都叫做select的读时间和写事件就绪

```c++
int select(int nfds,
fd_set*readfds,//传入传出参数
fd_set*writefds,
fd_set*exceptfds,
struct timeval*timeout
参数:
nfds:要检测的文件描述符中的最大fd+1/1024
readfds:读集合
writefds:写集合
exceptfds:异常集合
timeout：
	NULL:永久阻塞
		当检测到fd变化时返回
    timeval a;
    	a.tv_sec=0;
    	a.tv_usec=0;
```

工作代码

```cpp
//接受数据的server
#include<iostream>
#include<sys/select.h>
int main()
{
    int listen_sock=socket();
    bind();
    listen();
    
    fd_set read,temp;
    FD_ZERO(&read);
    FD_ZERO(&temp);
   int maxfd=listen_sock; FD_SET(listen_sock,&read);
    while(1)
    {
        
    }
}
```

select能够同时等待的文件描述符是有上限的

select需要和os交互数据，涉及到较多的数据来会拷贝，当select面临的链接很多，会因为拷贝而降低效率

select每次调用，都必须重新添加fd,一定会影响程序运行的效率，容易出错

select(nfds,),maxfd+1,操作系统在检测fd就绪的时候，需要遍历内核同步select底层遍历，成本会变得很高

优点：

select可以同时等待多个fd,而且只负责等待，有具体的accept，recv,send完成实际的IO操作，是不会被阻塞的

适用场景：适合有大量的链接，但是只有少量是活跃的



poll:

解决了select能检测的文件描述符是有上限的问题

将用户告诉内核让OS帮我关心那些文件描述符上的那些事件，将内核告诉用户那些文件描述符的那些是已经分离的，分离不用每次都调用poll,重新添加fd以及fd关心的事件

epoll_ctl对底层的红黑树节点进行相关此操作

底层在数据就绪的时候放节点，并不断通过epoll_wait从队列中取节点，

