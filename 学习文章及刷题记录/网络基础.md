# 网络基础

TCP/IP

网络四层协议(网络协议栈:负责数据通信工作)：应用层(用户空间)——》传输层——》网络层—–》数据链路层

应用层：我们能传输数据，我们的目的是什么？：根据特定的通信目的，进行数据分析又出力达到某种业务性的目的

传输层：处理传输遇到的问题，保证数据可靠性

网络层：数据转发，数据去哪里的问题

数据链路层：负责数据真正的发送过程

层状结构本质：只有接口的调动关系，增加代码的可维护性和扩展性

交换机：完成局域网内的数据交换



认识协议：

关于通信，同层协议，可以认为自己在和对方层

OSI七层网络模型



网络通信的基本流程

不同层的报头，可能是下层协议的有效载荷

协议共性：

1.报头的大小

2.自定义描述字段

几乎所有的协议，报头中都有一个字段，表明，我们要将有效载荷交往那个字段





TCP/IP五层(四层)模型

以太网通信：本质所有主机都收到了任何数据，只不过经过筛选提交上来了，发给自身的数据

1.局域网中，网络本身的特性要求只能有一个机器进行发送

2.如果网络中的数据发生了碰撞，当前主机是可以检测到的

3.所有的主机都要进行碰撞避免算法



数据链路层通信原理：

1.mac地址1：网卡内置了48为的序号，MAC地址，全球唯一

2.MAC数据帧：
srcMAC dstMAC   有效载荷

```
Linux中查看MAC地址：
ifconfig
```



对于每个网络，都认为路由器是它的局域网上的一台主机

IP：用来标识全网内唯一的一台主机

ipv4:32比特位标识IP地址

ipv6:128位

无论上层协议有多少层，最终们都必须在硬件上进行数据传输





网络编程套接字

端口号(port):

端口号是一个2字节16位的整数

端口号用来表示一个进程，高数操作系统，当前这个数据要交给那个进程进行处理

IP地址+端口号能够标识网络上的某一个主机的某一个进程

一个端口号只能被一个进程占用

TCP协议：

网络字节序：

网络上的数据必须是大端

常见socket接口

```c++
//创建socket文件描述符(TCP/UDP,客户端+服务器)
int socket(int domain,int type,int protocol);

//绑定端口号(TCP/UDP,服务器)
int bind(int socket,const struct sockaddr*address,socklen_t address_len);

//开始监听(TCP,服务器)
int listen(int socket,int backlog);

//接收请求(TCP,服务器)
int accept(int socket,struct sockaddr*address,socklen_t*address_len);

//建立连接(TCP/客户端)
int connect(int sockfd,const struct sockaddr*addr,socklen_t addrlen);
```



sockaddr结构



```cpp
touch udp_client.hpp
```

```cpp
touch udp_server.hpp
```

```
touch udpclient.cc
```

```
touch udpclient.hpp
```

```makefile
cc=g++
.PHONY:all
all:udp_client udp_server
udp_client:udp_client.cc
	$(CC) -o $@ $^ -std=c++11
udp_server:udp_sever.cc
	$(CC) -o $@ $^b-std=c++11
.PHONY:clean
clean:
	rm -f udp_client udp_sever
```

udp_client.hpp

```cpp
#pramgma once
#include<iostream>
#include<sys/socket.h>
#include<sys/type.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<unistd.h>
class UdpClient
{
 	private:
    int sockfd;
    int server_ip;
    int server_port;
    public:
    UdpClient(int _ip,int _port):
    server_ip(_ip),
    server_port(_port){
       
        
    }
    
 
    //客户端不需要进行绑定
    //服务器为何要bind一个接口：
    //服务器是为了给别人提供服务的，别人一定要知道你个ip和端口，端口一定要是众所周知的端口，而且bind之后，不能轻易改变
    //客户端访问server，端口只要是唯一的即可，不需要和特定client进程强相关
    //client端口可以动态进行设置
    //sendto类似接口，client直接在OS层面会自动给client获取一个唯一的端口
    bool InitUdpClient(){
        sockfd=socket(AF_INET,SOCK_DGRAM,0);
        if(coketfd<0)
        {
            cout<<"socket error!"<<endl;
            return;
        }
        return true;
    }
    
    void Start()
    {
        struct sockaddr_in peer;
                    meset(&peer,'\0',sizeof(peer));
        peer.sin_family=AF_INET;
        peer.sin_port=htons(server_port);
        peer.sin_addr.s_addr=inet_addr(server_ip.c_str);
        string msg;
        for(;;){

            cout<<"Please Enter# "<<endl;
            cin>>msg;
            sendto(sockfd,msg.c_str(),msg,size(),0,(struct sockaddr*)&peer,sizeof(peer))
             char buf[128];
            struct buffer_in temp;
            socklen_t len=sizeof(temp);
             ssize_t size=revcfrom(sockfd,buffer,sizeof(buffer)-1,0,(struct socket*)&temp,&len);
            if(size>0)
            {
                cout<<buffer<<endl;
            }
        }
    }
    
    ~UdpClient(){
        if(sockfd>=0)
        {
            close(sockfd);
        }
    }
    
    
};
```

udp_client.cc

```cpp
#include "udp_client.hpp"
int main(int argc,char*argv)
{
    if(argc!=3)
    {
        cout<<"Usage:"<<endl;
    }
    string ip=argv[1];
    int port=atoi(argv[2]);
    
    Udpclient*ucli= new UdpClient(ip,port);
    ucli-<InitUdpClient();
    ucli->Start();
    
}
```

udp_server.hpp

```cpp
#pragma once
#include<iostream>
#include<string>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/in.h>
#include<unistd.h>
#define DEFAULT 8081
using namespace std;
class UdpServer
{
    private:
    int port;
    //IP地址
    string ip;
    int socketfd;
    public:
	UdpServer(int _Port=DEFAULTstirng  _ip):port(_port),socketfd(-1),ip(_ip){
        
    }
    
    bool InitUdpServer(){
        socketfd=socket(AF_INET,SOCK_DGRAM,0);
        if(socketfd<0)
        {
            cerr<<"socket error"<<endl;
            return false;
        }
        cout<<"socket create success ,socketfd:"<<socketfd<<end;
        struct sockadde_in local;
        meset(&loacl,'\0',sizeof(local));
        local.sin_family=AFINET;
        local.sin_port=htons(port);
        //local.sin_addr.s_addr=inet_addr(ip.c_str());
      local.sin_addr.s_addr=INADDR_ANY;  
        if(bind(socketfd,(struct addr*)&local,sizeof(local))<0)
        {
            cerr<<"error"<<endl;
        }
        cout<<"bind success"<<endl;
        return true;
    }
    #define SIZE 128;
    
    void Start(){
        char buffer[SIZE]=0;
        for(;;){
            struct sockaddr_in peer;
            socket_t len=sizeof(socketaddr_in);
            ssize_t size=recvfrom(socketfd,buffer,sizeof(buffer)-1,0,(sturct socketaddr*)&peer,&len);
            if(size>0)
            {
                buffer[size]=0;
                int _port=ntohs(peer.sin_port);
                string _ip=inet_ntoa(peer.sin_addr);
                cout<<_ip<<" "<<_port<<"#"<<buffer<<endl;
                string msg="server get!";
                msh+=buffer;
                sendto(sockfd,msg.c_str(),msg.size(),0,(struct socket*)&peer,len)
            }
            else
            {
                cerr<<"recvfrom error"<<endl;
            }
        }
    }
       
    ~UdpServer(){
        if(sockfd>=0)
        {
            colse(sockfd);
        }
    }
};
```

![image-20220305160027842](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220305160027842.png)

udp_server.cc

```cpp
#include "udp_server.hpp"
int main(int argc ,char* argv[])
{
    if(argc!=2)
    {
        cout<<argv[0]<<"port"<<endl;
    }
   // string ip="127.0.0.1";
    int port=ator(argv[0]);
    UdpServer*srv=new UdpServer(ip,port);
    s->InitUdpServer();
    srv->start();
} 
```

netstat -nlup

sz 文件名：从服务器下载软件

rz 文件：从本地上传文件到服务器









TCP服务器

```shell
touch tcp_server.hpp
touch tcp_server.cc
touch tcp_client.hpp
touch tcp_client.cc
```

```makefile
CC=g++
.PHONY:all
all:tcp_server tcp_client
tcp_server:tcp_server.cc
	$(CC) -o $@ $^ -std=c++11
tcp_client:tcp_client.cc
	$(CC) -o $@ $^ -std=c++11
.PHONY:clean
clean:
	rm -f tcp_server tcp_client
```

tcp_server.hpp

```cpp
#pragam once
#include<iostream>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/iney/h>
#include<cstring>
#include<unistd.h>
#include<sys/wait.h>
#include<signal.h>

class TcpServer
{
    private:
    int port;//监听套接字
   	int listen_sock;
    
    public:
	TcpServeeer(int _port=8081):listen_port(_port){
        
    }
    
    bool InitTcpServer(){
        listen_sock=socket(AF_INET,SOCK_STREAM,0);
        if(listen_sock<0)
        {
            cerr<<"socket error"<<endl;
            exit(2);
            return false;
        }
        struct sockaddr_in loacl;
        memset(&local,'\0',sizeof(loacl));
        loacl.sin_family=AF_INET;
        local.sin_port=honts(port);
        local.sin_addr.s_addr=INADDR_ANY;
        if(bind(listen_sock,(struct sockaddr*)&local,sizeof(local))<0)
        {
            cout<<"bind error"<<endl;
            exit(3);
            return false;
        }
        
        if(listen(listen_sock,5)<0)
        {
            cout<<"listen error"<<endl;
            return false;     
        }
        
        return true;
    }
    
    vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
            cout<<"get a new link:"<<"["<<inet_ntoa(peer.sin_addr)<<"]:"<<ntohs(peer.sin_port)<<endl;
       string ip=inet)ntoa(peer.sin_addr);
       int port=ntohs(per.sin_port);
       pid_t id=fork();
       if(id==0){
           close(listen_sock);
           if(fork()>0){
               exit(0);
           }
           Service(sock,ip,port);
           exit(0);
       }
       //waitpid();//阻塞的
	   close(sock);
        waitpid(id,nullptr,0);
        }
    }
    
    void Service(int sock,string ip,int port){
        char buf[1024]=0;
        while(true){
            ssize_t size=read(sock,buf,sizeof(buf)-1);
            if(size>0)
            {
                buf[size]=0;
                cout<<"["<<ip<<']:'<<port<<"#"<<buf<<endl;
                write(sock,buf,size);
            }
            else if(size==0)
            {
                cout<<ip<<":"<<port<<"close!"<<endl;
                break;
            }
            else
            {
                cerr<<sock<<"read error!"<<endl;
                break;
            } 
        }
        close(sock);
        cout<<"service done"<<endl;
    }
    
    ~TcpServer(){
        if(listen_sock>=0)
        {
            close(listen_lock);
        }
    }
}
```

tcp_server.cc

```cpp
#include"tcpserver.hpp"
int main(int argc,char argv[])
{
	if(argc!=2){
        cout<<"Usage"<<endl;
        exit(0);
    }
    
    TecpServer tsvr(atoi(argv[1]));
    tsvr.InitServer();
    tsvr.Loop();
    return 0;
    
        
}
```

tcp_client.hpp

```cpp
#include<iostream>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<string>
#include<n

class TcpClient{
  private:
    string svr_ip;
    int svr_ip;
    int sock;
   public:
    TcpClient(string _ip,int _port):svr_ip(_ip),svr_port(_port){
        
    }
    ~TcpClient(){
        if(sock>=0)
        {
            close(sock);
        }
    }
    
    void InitTcpClient(){
        sock=socket(AF_INET,SOCK_STREAM,0);
        if(sock<0)
        {
            cout<<"socket error"<<endl;
            exit(1);
        }
    }
	void Start(){
        struct sockaddr_in peer;
        meset(&peer,0,sizeof(peer));
        peer.sin_family=AF_INET;
        peer.sin_port=htons(svr_port);
        peer.sin_addr.s_addr=inet_addr(svr_ip.c_str());
        if(connect(sock,(struct sockaddr*)&peer,sizeof(peer))==0){
            //success
            cout<<"connect success!"<<endl;
            Request(sock);
        }
        else{
            cout<<"connect error!"<<endl;
        }
        
    }   
    
    
    Request(int sock){
        string msg;
        char buffer[1024];
        while(true){
            cout<<"Please Enter#";
            cin>>msg;
            write(sock,msg.c_str(),msg.size());
            
           ssize_t s= read(sock,buffer,sizeof(buffer)-1);
            
            if(size>0)
            {
                buffer[size]=0;
                
            }
            cout<<"server echo#"<<endl;
            
        }
    }
};
```

tcp_client.cc

```
#include"tcp_client.hpp"
int main(int argc,char*argv[])
{
	if(argc!=3){
	cout<<"Usage!"<<endl;
	exit(0);
	}
	TecpClient tcli(argv[1],atoi(argv[2]));
	tcli.Start();
	
}
```

TCP是面向连接的，所以在发送数据之前需要建立连接

服务器端，必须不断的花时间，进行检查是否有新的连接

```
ssize_t read(int fd,void*buf,size_t count);
1.>0:实际读取到了多少字节
2.==0:说明对端关闭了连接
3.<0:说明读取时遇到了错误
```

tcp socket中，读写都是一个sock(fd),全双工通信体系 

升级版本:多线程版本Tcp服务器

```cpp
#include<pthread.h>
class Prama{
    public:
    int sock;
    string ip;
    int port;
    public:
    Prame(int _sock,stirng _ip,int _port):sock(_sock),ip(_ip,),port(_port){
        
    }
    ~Preame(){
        
    }
};
static void* HanderRequst(void*arg){
    Prama*p=(Prama*)arg;
    
	pthread_detach(pthread_self());
    
    Service(p->sock,p->ip.p->port);
    delete p;
    close(p->sock);
    return nullptr;
}

 vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
            pthread_t tid;
            
          // int*p=new int(sock); 
            Prame*p=new Prame(sock,ip,port);
                pthread_create(&tid,nullptr,HanderRequest,p);
           
        }
    }
```

线程版本升级:基于线程池

```cpp
#include<pthread.h>
#include"ThreadPool.hpp"

class Prama{
    public:
    int sock;
    string ip;
    int port;
    
    public:
    Prame(int _sock,stirng _ip,int _port):sock(_sock),ip(_ip,),port(_port){
        
    }
    ~Preame(){
        
    }
};
static void* HanderRequst(void*arg){
    Prama*p=(Prama*)arg;
    
	pthread_detach(pthread_self());
    
    Service(p->sock,p->ip.p->port);
    delete p;
    close(p->sock);
    return nullptr;
}

 vpod Loop(){
       // signal(SIGCHLE,SIG_IGN);
        for(;;){
            struct sockassr_in peer;
            socklen_t len=sizeof(peer);
            int sock=accept(sock,(struct sockaddr*)&peer,&len);
            if(sock<0){
                cout<<"accept error"<<endl;
                continue;
            }
           	
        }
    }
```

```
Task.hpp

```









```cpp
//server.cpp
```

<hr>

```cpp
//server.cc
#include<iostream>
#include<string>
#include<arpa/in.h>
#include"protocol.hpp"
void*Routine(void*arg){
    int sock=(int*)arg;
    delete arg;
    //定制协议
    
    while(1){
        request_t rq;
        response_t rsp;
        sszie_t size=recv(sock,&rq,sizeof(rq),0);
        if(s>0){
            switch(rq.op){
                case '+':
                    rsp.result=rq.x+rq.y;
                    break;
                case '-':
                    rsp.result=rq.x-rq.y;
                    break;
                case '*':
                    rsp.restult.rq.x*rq.y;
                    break;
                case '/':
                    if(rq.y==0){
                        rsp.code=1;
                    }
                    else{
                        rsp.result=rq.x/rq.y;
                    }
                    break;
                case '%':
                     if(rq.y==0){
                        rsp.code=2;
                    }
                    else{
                        rsp.result=rq.x%rq.y;
                    }
                    break;
                delault:
                    rsp.code=3;
                    break;
            }
        }
        send(sock,&rsp,sizeof(rsq),)
    }
    
}
int main(int argc,char*argv[]){
    if(arrgc!=2){
        cout<<"Usage!"<<endl;
    }
    int listten_sock=socket(AF_INET,SOCK_STREAM,0);
    if(listen_sock<0){
        exit(0);
    }
    struct sockaddr_in local;
    local.sin_family=AF_INET;
    local.sin_port=honts(atoi(a));
    loacl.sin_addr.s_addr=hontl(INADDR_ANY);
    if(bind(listen_sock,(struct sockaddr)&local,sizeof(local)<0)){
        exit(2);
    }
    if(listen(listen_sock,5)<0){
        exit(4);
    }
    struct sockaddr_in peer;
    socklen_t len=sizeof(peer);
    for(;;){
        int sock=accept(listen_sock,&peer,&len);
        if(sock<0){
            continue;
        }
        pthread_t tid;
        int*p=new int(sock);
        pthread_create(&tid,nullptr,Routine,p);
    }
    
    
}
```

<hr>

```cpp
//Client.hhp
```

<hr>

```cpp
//Client.cc
//server.cc
#include<iostream>
#include<string>
#include<arpa/in.h>
#include"protocl.hpp"
int main(int argc,char*argv[]){
    if(arrgc!=3){
        cout<<"Usage!"<<endl;
    }
    int listten_sock=socket(AF_INET,SOCK_STREAM,0);
    if(listen_sock<0){
        exit(0);
    }
    struct sockaddr_in peer;
    peer.sin_family=AF_INET;
    peer.sin_port=honts(argv[2]);
    peer.sin_addr.s_addr=inet_addr(argv[1]);
    if(connect(sock,(struct sockarr*)&peer,sizeof(peer))<0){
        cout<<"conncect error!"<<endl;
        exit(3);
    }
    while(1){
        request_t rq;
        cout<<"输入数据:"<<endl;
        cin>>rq.x;
        cin>>rq.y;
        cin>>rq.op;
        send(sock,&rq,sizeof(rq),0);//结构化的数据为什么没有序列化，
        response_t rsp;
        recv(sock,&rsp,sizeof(rsp),0);
        cout<<rsp.code<<endl;
        cout<<rq.x<<rq.op<<rq.y<<"="<<rsq.result<<endl;
        
    }
}
```

```cpp
typedef struct request{
    int x;
    int y;
    int op; //+ - * / %
}request_t;

typedef struct response{
    int code;//>success,1,2,3,4代表错误信息
    
}response_t;
```

http协议

URL：同意资源定位符

协议名称+登录信息+服务器地址+服务器地址+带层次的文件路径+查询关键字+片段标识

http协议本质是要获得某种资源

资源路径：在对应的服务器上，所要的资源位于什么位置

大部分上网都是在进行进程间通信

1.把服务器上的资源那道本地

2.把本地的数据推送到服务器

http是基于请求与响应的应用层服务

常规情况下，http底层使用的传输层协议是tcp

```cpp
//http_server.cc
#include<iostream>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<sys/types.h>
#include<sys/types.h>


int main(){
    int listen_sock=socket(AF_INET,SOCK_STREAM<0);
    if(listen_sock<0){
        cout<<"socket error!"<<endl;
        exit(1);
    }
    
    struct sockaddr_in local;
    local.sin_family=AF_INET;
    local.sin_poar=htons(atoi(argv[1]));
    local.sin_addr.s_addr=INADDR_ANY;
    if(bind(listen_sock,(struct sockaddr*)&local,sizeof(loacl))<0)
    {
        cout<<"bind error!"<<endl;
        exit(2);
    }
    if(listen(listen_sock，5)<0){
        exit(3);
    }
    struct sockaddr_in peer;
    socklen_t len=sizeof(peer);
    for(;;){
        int sock=accept(listen_sock,&peer,&len);
        if(sock<0){
            cout<<"accept error!"<<endl;
            continue;
        }
        if(fork()==0){
            if(fork()>0){
                exit(0);
            }
            close(listen_sock);
            //read http request;
            char buffer[1024];
            recv(sock,buffer,sizeof(buffer),0);
            cout<<"########http request begin########"<<endl;
            cout<<buffer<<endl;
            cout<<"########http request end########"<<endl;
            exit(0);
        }
        close(sock);
        waitpid(-1,nullptr,0);
    }
}
```

http请求有=由如下几个部分构成：

请求方法   请求资源路径  http版本协议

key: value

亲求行：请求方法 url http版本

请求报头：key value（存在多行内容）

空行

请求正文(非必须):(一般都是用户的信息或者数据)

所谓的http协议在服务器和客户端中，一般涉及非常多的文本分析

客户端如何判断已经将response报头读取完毕呢？

循环按行读取，知道读取到空行







respnse:
状态行   http版本   状态码         状态码描述

响应报头

空行

响应正文

```
ifstream in(".html");
if(in.is_open()){
	in.seekg(0,std::ios::end);
	size_t len=in.tellg();
	in.seekg(0,std::ios::beg);
	char*file=new char[len];
	in.read(file,len);
	in.close();
	string status_line="http/1.0 status Ok";
	send(sock,stratus_line.c_str(),status_line.size(),0);
	send(sock,response_header.c_str);
	send(sock,file,len,0);
	
} 
```

