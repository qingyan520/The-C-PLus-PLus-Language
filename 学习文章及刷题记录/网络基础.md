# 网络基础

TCP/IP

网络四层协议(网络协议栈:负责数据通信工作)：应用层(用户空间)——》传输层——》网络层—–》数据链路层

应用层：我们能传输数据，我们的目的是什么？：根据特定的通信目的，进行数据分析又出力达到某种业务性的目的

传输层：处理传输遇到的问题，保证数据可靠性

网络层：数据转发，数据去哪里的问题

数据链路层：负责数据真正的发送过程

层状结构本质：只有接口的调动关系，增加代码的可维护性和扩展性

交换机：完成局域网内的数据交换



认识协议：

关于通信，同层协议，可以认为自己在和对方层

OSI七层网络模型



网络通信的基本流程

不同层的报头，可能是下层协议的有效载荷

协议共性：

1.报头的大小

2.自定义描述字段

几乎所有的协议，报头中都有一个字段，表明，我们要将有效载荷交往那个字段





TCP/IP五层(四层)模型

以太网通信：本质所有主机都收到了任何数据，只不过经过筛选提交上来了，发给自身的数据

1.局域网中，网络本身的特性要求只能有一个机器进行发送

2.如果网络中的数据发生了碰撞，当前主机是可以检测到的

3.所有的主机都要进行碰撞避免算法



数据链路层通信原理：

1.mac地址1：网卡内置了48为的序号，MAC地址，全球唯一

2.MAC数据帧：
srcMAC dstMAC   有效载荷

```
Linux中查看MAC地址：
ifconfig
```



对于每个网络，都认为路由器是它的局域网上的一台主机

IP：用来标识全网内唯一的一台主机

ipv4:32比特位标识IP地址

ipv6:128位

无论上层协议有多少层，最终们都必须在硬件上进行数据传输





网络编程套接字

端口号(port):

端口号是一个2字节16位的整数

端口号用来表示一个进程，高数操作系统，当前这个数据要交给那个进程进行处理

IP地址+端口号能够标识网络上的某一个主机的某一个进程

一个端口号只能被一个进程占用

TCP协议：

网络字节序：

网络上的数据必须是大端

常见socket接口

```c++
//创建socket文件描述符(TCP/UDP,客户端+服务器)
int socket(int domain,int type,int protocol);

//绑定端口号(TCP/UDP,服务器)
int bind(int socket,const struct sockaddr*address,socklen_t address_len);

//开始监听(TCP,服务器)
int listen(int socket,int backlog);

//接收请求(TCP,服务器)
int accept(int socket,struct sockaddr*address,socklen_t*address_len);

//建立连接(TCP/客户端)
int connect(int sockfd,const struct sockaddr*addr,socklen_t addrlen);
```



sockaddr结构



```cpp
touch udp_client.hpp
```

```cpp
touch udp_server.hpp
```

```
touch udpclient.cc
```

```
touch udpclient.hpp
```

```makefile
cc=g++
.PHONY:all
all:udp_client udp_server
udp_client:udp_client.cc
	$(CC) -o $@ $^ -std=c++11
udp_server:udp_sever.cc
	$(CC) -o $@ $^b-std=c++11
.PHONY:clean
clean:
	rm -f udp_client udp_sever
```

udp_client.hpp

```cpp
#pramgma once
#include<iostream>
#include<sys/socket.h>
#include<sys/type.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<unistd.h>
class UdpClient
{
 	private:
    int sockfd;
    int server_ip;
    int server_port;
    public:
    UdpClient(int _ip,int _port):
    server_ip(_ip),
    server_port(_port){
       
        
    }
    
 
    //客户端不需要进行绑定
    //服务器为何要bind一个接口：
    //服务器是为了给别人提供服务的，别人一定要知道你个ip和端口，端口一定要是众所周知的端口，而且bind之后，不能轻易改变
    //客户端访问server，端口只要是唯一的即可，不需要和特定client进程强相关
    //client端口可以动态进行设置
    //sendto类似接口，client直接在OS层面会自动给client获取一个唯一的端口
    bool InitUdpClient(){
        sockfd=socket(AF_INET,SOCK_DGRAM,0);
        if(coketfd<0)
        {
            cout<<"socket error!"<<endl;
            return;
        }
        return true;
    }
    
    void Start()
    {
        struct sockaddr_in peer;
                    meset(&peer,'\0',sizeof(peer));
        peer.sin_family=AF_INET;
        peer.sin_port=htons(server_port);
        peer.sin_addr.s_addr=inet_addr(server_ip.c_str);
        string msg;
        for(;;){

            cout<<"Please Enter# "<<endl;
            cin>>msg;
            sendto(sockfd,msg.c_str(),msg,size(),0,(struct sockaddr*)&peer,sizeof(peer))
             char buf[128];
            struct buffer_in temp;
            socklen_t len=sizeof(temp);
             ssize_t size=revcfrom(sockfd,buffer,sizeof(buffer)-1,0,(struct socket*)&temp,&len);
            if(size>0)
            {
                cout<<buffer<<endl;
            }
        }
    }
    
    ~UdpClient(){
        if(sockfd>=0)
        {
            close(sockfd);
        }
    }
    
    
};
```

udp_client.cc

```cpp
#include "udp_client.hpp"
int main(int argc,char*argv)
{
    if(argc!=3)
    {
        cout<<"Usage:"<<endl;
    }
    string ip=argv[1];
    int port=atoi(argv[2]);
    
    Udpclient*ucli= new UdpClient(ip,port);
    ucli-<InitUdpClient();
    ucli->Start();
    
}
```

udp_server.hpp

```cpp
#pragma once
#include<iostream>
#include<string>
#include<sys/tyeps.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/in.h>
#include<unistd.h>
#define DEFAULT 8081
using namespace std;
class UdpServer
{
    private:
    int port;
    //IP地址
    string ip;
    int socketfd;
    public:
	UdpServer(int _Port=DEFAULTstirng  _ip):port(_port),socketfd(-1),ip(_ip){
        
    }
    
    bool InitUdpServer(){
        socketfd=socket(AF_INET,SOCK_DGRAM,0);
        if(socketfd<0)
        {
            cerr<<"socket error"<<endl;
            return false;
        }
        cout<<"socket create success ,socketfd:"<<socketfd<<end;
        struct sockadde_in local;
        meset(&loacl,'\0',sizeof(local));
        local.sin_family=AFINET;
        local.sin_port=htons(port);
        //local.sin_addr.s_addr=inet_addr(ip.c_str());
      local.sin_addr.s_addr=INADDR_ANY;  
        if(bind(socketfd,(struct addr*)&local,sizeof(local))<0)
        {
            cerr<<"error"<<endl;
        }
        cout<<"bind success"<<endl;
        return true;
    }
    #define SIZE 128;
    
    void Start(){
        char buffer[SIZE]=0;
        for(;;){
            struct sockaddr_in peer;
            socket_t len=sizeof(socketaddr_in);
            ssize_t size=recvfrom(socketfd,buffer,sizeof(buffer)-1,0,(sturct socketaddr*)&peer,&len);
            if(size>0)
            {
                buffer[size]=0;
                int _port=ntohs(peer.sin_port);
                string _ip=inet_ntoa(peer.sin_addr);
                cout<<_ip<<" "<<_port<<"#"<<buffer<<endl;
                string msg="server get!";
                msh+=buffer;
                sendto(sockfd,msg.c_str(),msg.size(),0,(struct socket*)&peer,len)
            }
            else
            {
                cerr<<"recvfrom error"<<endl;
            }
        }
    }
       
    ~UdpServer(){
        if(sockfd>=0)
        {
            colse(sockfd);
        }
    }
};
```

![image-20220305160027842](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220305160027842.png)

udp_server.cc

```cpp
#include "udp_server.hpp"
int main(int argc ,char* argv[])
{
    if(argc!=2)
    {
        cout<<argv[0]<<"port"<<endl;
    }
   // string ip="127.0.0.1";
    int port=ator(argv[0]);
    UdpServer*srv=new UdpServer(ip,port);
    s->InitUdpServer();
    srv->start();
}
```

netstat -nlup

sz 文件名：从服务器下载软件

rz 文件：从本地上传文件到服务器









TCP服务器

```cpp
touch tcp_server.hpp
touch tcp_server.cc
touch tcp_client.hpp
touch tcp_client.cc
```

```
CC=g++
.PHONY:all
all:tcp_server tcp_client
tcp_server:tcp_server.cc
	$(CC) -o $@ $^ -std=c++11
tcp_client:tcp_client.cc
	$(CC) -o $@ $^ -std=c++11
.PHONY:clean
clean:
	rm -f tcp_server tcp_client
```

tcp_server.hpp

```cpp
#include<iostream>
class TcpServer
{
    private:
    int port;
    string ip;
    
    public:
	TcpServeeer(int _port):port(_port){
        
    }
    
    bool InitTcpServer(){
        
    }
    
    vpod Loop(){
        for(;;){
            
        }
    }
    
    ~TcpServer(){
        
    }
}
```

tcp_server.cc

```

```

tcp_client.hpp

```

```

tcp_client.cc

```

```

