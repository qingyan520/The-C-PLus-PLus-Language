《高性能Linux服务器》笔记

第1章 TCP/IP协议族

1.1TCP/IP协议族体系结构以及主要协议

TCP/IP协议族是一个四层协议系统：数据链路层，网络层，传输层，应用层

数据链路层：ARP，RARP协议

网络层：ICMP，IP

传输层：TCP，UDP

应用层：http,https.dns,ftp

1.1.1数据链路层

数据链路层两个常用的协议是ARP协议（Address ResolveProtocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换。

网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。

1.2网络层

网络层最核心的协议是IP协议（Internet Protocol，因特网协议）。

IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（nexthop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃

网络层另外一个重要的协议是ICMP协议（Internet Control MessageProtocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于检测网络连接

![image-20220911111815073](C:\Users\史金伟\AppData\Roaming\Typora\typora-user-images\image-20220911111815073.png)

1.1.3传输层

传输层主要有三个协议：TCP，UDP，SCTP

TCP协议为应用提供可靠的，面向连接的和基于流的服务，TCP协议使用超时重传，数据确认等方式确保数据包被正确地发送至目的端，一次TCP服务是可靠的，使用TCP协议双方必须建立TCP连接，并在内核为该连接维持一些必要的数据结构，比如连接的状态，读写缓冲区，以及诸多定时器等，当通信结束时，双方必须关闭连接释放这些内核数据，TCP服务是基于流的，基于流的数据没有边界限制，它源源不断地从通信地一端流入另一端，发送端可以逐个字节的向数据流中写入数据，接收端也可以逐个字节的将它们读出

UDP协议与TCP协议完全相反，它为应用层提供不可靠的，无连接和基于数据包地服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端，如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败，因此，使用UDP协议地应用程序通常要自己处理数据确认，超时重传等，UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信

息）。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。

第三章 TCP协议详解

3.2.1TCP固定头部结构

![image-20220914143554933](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220914143554933.png)

16位端口号（port number）：告知主机该报文段是来自哪里（源

端口）以及传给哪个上层协议或应用程序（目的端口）的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。

32位序号（sequence number）：一次TCP通信（从TCP连接建立到

断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主

机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值

被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号

值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值

将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节

流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～

2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向

（从B到A）的TCP报文段的序号值也具有相同的含义。

32位确认号（acknowledgement number）：用作对另一方发送来的

TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机

A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序

号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的

TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。

4位头部长度（header length）：标识该TCP头部有多少个32bit字 

（4字节）。因为4位最大能表示15，所以TCP头部最长是60字节。6位标志位包含如下几项：

❑URG标志，表示紧急指针（urgent pointer）是否有效。

❑ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP

报文段为确认报文段。

❑PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读

走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据

读走，它们就会一直停留在TCP接收缓冲区中）。

❑RST标志，表示要求对方重新建立连接。我们称携带RST标志的

TCP报文段为复位报文段。

❑SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP

报文段为同步报文段。

❑FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标

志的TCP报文段为结束报文段。

16位窗口大小（window size）：是TCP流量控制的一个手段。这里

说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告

诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可

以控制发送数据的速度。16位校验和（TCP checksum）：由发送端填充，接收端对TCP报

文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这

个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一

个重要保障。

16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字

段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地

说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏

移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。我们将在

后面讨论TCP紧急数据



TCP三次握手与四次挥手

![image-20220914151951593](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220914151951593.png)





TCP状态转移图

![image-20220914151859375](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220914151859375.png)





TIME_WAIT状态存在的原因主要有两点：

1.可靠的终止TCP连接

2.保证让迟来的TCP报文段有足够的时间被识别并丢弃

第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的

TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停

留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报

文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为

这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文

段。

在Linux系统上，一个TCP端口不能被同时打开多次（两次及以

上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在

TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似

的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。这

个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。

新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文

段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状

态存在的第二个原因



Linux高级I/O函数

pipe函数
pipe函数可用于创建一个管道，以实现进程间通信

```cpp
#include＜unistd.h＞
int pipe(int fd[2]);
```

```cpp
此外，socket的基础API中有一个socketpair函数。它能够方便地创
建双向管道。其定义如下：
#include＜sys/types.h＞
#include＜sys/socket.h＞
int socketpair(int domain,int type,int protocol,int fd[2]);
socketpair前三个参数的含义与socket系统调用的三个参数完全相
同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能
在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一
样，只不过socketpair创建的这对文件描述符都是既可读又可写的。
socketpair成功时返回0，失败时返回-1并设置errno。
```

dup函数和dup2函数

> 有时我们希望把标准输入重定向到一个文件，或者把标准输出重
>
> 定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制
>
> 文件描述符的dup或dup2函数来实现：

```
#include＜unistd.h＞
int dup(int file_descriptor);
int dup2(int file_descriptor_one,int file_descriptor_two);
```



sendfile函数

> sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。sendfile函数的定义如下：
>
> ```cpp
> #include＜sys/sendfile.h＞
> ssize_t sendfile(int out_fd,int in_fd,off_t*offset,size_t count);
> ```



