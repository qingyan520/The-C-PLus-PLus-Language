图及其应用

图的基本概念

图是由顶点及格及顶点间的关系(顶点+边)组成的一种数据结构

有向图和无向图

图可以表示坐标间的地图关系

无向完全图：在有n个顶点的无向图中，有n*(n-1)/2条边，即任意两个顶点之间有且只有一条边

又向完全图：任意两个顶点都是直接相互连接的,n(n-1)

邻接顶点：

顶点的度：顶点V是指与它相关里的边的条数，有向图分为出度和入度

路径：从一个顶点到另外一个顶点的路径

连通图：图中任意两个点之间有路径





图的存储及表示

```
1.顶点的集合
2.边的集合


存储方法：
1.邻接矩阵
2.邻接表
```

邻接矩阵的优势：

1.快速找到两个点之间的边

2.适合边比较多的图

劣势：
要找一个顶点连接出去的边是O(N)

邻接表：利用链式结构讲相连的点弄到一条链式结构，类似于哈希桶

优势：

1.找一个点相连的定点便很快

2.适合边比较稀疏的图

劣势：

确认两个顶点是否相连是O(N),要把这个顶点连接的所有边遍历



```cpp
//Graph.h
#include<iostream>
using namespace std;

//邻接矩阵版本
template<class V,class W,bool Direciton=false>//模式表示无向图
class Graph
{
    private:
    map<V,i>_VIndexMap;
    vector<V>_vertexs;       //顶点集合
    vector<vector<W>>_martix;//边集合的矩阵
    
    public:
    Graph(const V*vertexs,size_t n)
    {
        _vertexs.reserve(n);
        for(int i=0;i<n;i++)
        {
            _vertexs.push_back(vertex[i]);
            _vIndexMap[vertex[i]]=i;
        }
        
        _matrix.resize(n);
        for(int i=0;i<n;i++)
        {
            _matrix[i].resize(n);
        }
        
    }
    
    
    size_t GetVertexIndex(const V&v)
    {
       auto ret=_vIndexMap.find(v);
        if(ret!=——vIndexMap)
        {
            return ret->second;
        }
        else
        {
            throw invalid_argument("不存在的顶点");
            return -1;
        }
    }
    
    //添加边
    void AddEdge(const V&src,const V&dst,const W&w)
    {
        size_t srcindex=GetVertexIndex(src);
        size_t dstindex=GetVertexIndex(dsst);
        
        _martix[srcindex][dstindex]=w;
        if(Direction==false)
        {
            _martix[dstindex][srcindex]=w;
        }
    }
    
    
    //BFS广度优先遍历
    void BFS(const V&src)
    {
        size_t srcindex=GetVertexIndex(src);
        vector<bool>visited;
        visited.resize(_vertex.size(),false);
        queue<int>q;
        q.push(srcindex);
        visted[srcindex]=true;
        int d=1;
        size_t dsize=1;
        while(!q.empty())
        {
            size_t front=q.front;
            q.pop();
            printf("%s的%d度好友："src.c_str(),d);
            while(dSize--)
            {
              	 for(size_t i=0;i<_vertexs.zie();i++)
       		  	{
            		if(visited[i_==false&&martrix[front][i]!=w())
            		{
                	printf("[%d:%s]",i,_vertex[i].c_str());
                	visited[i]=true;
                	q.push(i);
            		}
        		}
             }
             dSize=q.size();
            ++d;
        	cout<<endl;
        }
    }
                       
 	void DFS()
     
    
    
};

void TestGraph()
{
    string a[]={"张三"，"李四"，"王五","赵六"};
    Graphh<string int>a1(a,4);
    g1.AddEdge("张三","李四")
}
void test()
```

邻接表方式

```cpp
template<class W>
struct LinkEdge
{
	int _srcIndex;
    int _dstIndex;
    W _w;
    LinkEdge<W>*_next;
    
    LinkEdge(const W&w):
    _srcIndex(-1),
    _dstIndex(-1),
    _w(w),
    _next(nullptr)
    {
        
    }
};

template<class V,class W,bool Direction=false>
class Graph
{
    typedef LinkEdge Edge;
    private:
    map<V,int>_mIndexMap;
    vector<V>_vertexs;
    vector<Edge*> _link;
    
    
    public:
    Graph(const V*vertexs,size_t n);
    {
        _vertexs.reserve(n);
        for(size_t i=0;i<n;i++)
        {
            _vertexs.push_back(vertesx[i]);
            _vIndexMap[vertexs[i]]=i;
        }
        _linkTable.resize(n,nullptr);
    }
    
    
    
    size_t GetVertexIndex(const V&v)
    {
       auto ret=_vIndexMap.find(v);
        if(ret!=——vIndexMap)
        {
            return ret->second;
        }
        else
        {
            throw invalid_argument("不存在的顶点");
            return -1;
        }
    }
    
    
    
    //添加边
    void AddEdge(const V&src,const V&dst,const W&w)
    {
        size_t srcindex=GetVertexIndex(src);
        size_t dstindex=GetVertexIndex(dsst);
        
        Edge*sd_edge=new Edge(w);
        sd_edge->srcIndex=srcndex;
        sd_edge->dstIndex=dstIndex;
        sd_dege->_next=_linkTable[srcIndex];
        _linkTable[srcIndex]=sd_dege;
        if(Direction=false)
        {
         	Edge*ds_edge=new Edge(w);
            ds_edge->_srcIndex=dstIndex;
            ds_edge->_dstIndex=srcIndex;
            ds_edge->_next=_linkTable[dstIndex];
            _linkTable[dstIndex]=ds_dege;
        }
    }
    
    
    
    
};


```

图的遍历方式：

深度优先遍历



广度优先遍历

```cpp
void DFS(const V&src)
{
    size_t srcIndex=GetVertexIndex(src);
    vector<bool>visited;
    visited.resize(_vertexs.size(),false);
    
    _DFS(srcindex,visited);
}

void _DFS(size_t srcIndex,vector<bool>&visited)
{
    printf("[%d:%s]->",srcIndex,_vertexs[srcIndex].c_str());
    visited[srcIndex]=true;
 	for(size_t i=0;i<_vertexs.size();i++)
    {
        if(visited[i]==false&&_martix[srcIndex][i]!=W())
           {
            	_DFS(i,visited);   
           }
    }
}
```

最小生成树

连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不在连通了，反之，在其中引入任何一条新边，都会形成一条回路

若连通图由n个顶点组成，则其生成树必含有n个顶点和n-1条边，英雌构造最小生成树的准则由三条：

1.只能使用图中的边来构造最小生成树

2.只能使用恰好n-1条边来连接图中的n个顶点

3.选用的n-1条边不能构成回路

构造最小生成树的方法：Kruskal算法和Prim算法





最短路径问题

单源最短路径 ————Dijkstra算法(一个源点跟图中其它所有点相连的最短路径)



多源最短路径————floyed算法

思维：要让任意两点之间(假设a到b)的路程变短，只能映入第三点(假设为k),并且通过这个点k进行中转，即a->k->b,才能缩短原来从顶点a到顶点b的路程，有时候可能不止一个中转点，而是经过两个点或者跟多的点进行中专，即a->k1->k2或者a->k1->k2->……->b

![image-20220513193749659](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513193749659.png)

![image-20220513193938787](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513193938787.png)

![image-20220513194831884](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513194831884.png)

![image-20220513195224703](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513195224703.png)

floyed算法总结：

可以计算出任意两点的最短路径，可以处理带有父权边的图，但不能处理带有“负环”的图，时间复杂度O(N^3)

![image-20220513195511815](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513195511815.png)



Dijkstra算法————单源最短路径算法

![image-20220513201025274](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513201025274.png)

Dijkstra算法用来计算从一个点到其它所有点的最短路径的算法，是一种单源最短路径算法，也就是说，只能计算七点只有一个的情况，Dijkstra算法的时间复杂度为O(N^2)，它不能处理存在负边权的情况

算法描述：

设起点为s,divs[v]表示从s到v的最短路径长度

a)初始化：dis[v]=无穷；dis[s]=0;

b)

```cpp
for(int i=0;i<=n;i++)
{
    //1.在没有被访问过的殿中找一个顶点u使得dis[u]是最小的
    //2.u标记为以确定的最短路径
    //3.for与u相连的每个未确定的最短路径顶点v
    if(dis[u]+w[u][v]<dis[v])
    {
        dis[v]=dis[u]+w[u][v];
    }
}
```

c)算法结束：dis[v]为s到v的最短距离

![image-20220513204720507](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513204720507.png)

![image-20220513205047632](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513205047632.png)

![image-20220513205211228](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513205211228.png)



![image-20220513212301393](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513212301393.png)

![image-20220513211952577](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513211952577.png)

![image-20220513212016794](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513212016794.png)

![image-20220513212153764](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513212153764.png)

![image-20220513212734398](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513212734398.png)

![image-20220513213533896](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220513213533896.png)
