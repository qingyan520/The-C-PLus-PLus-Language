# 云备份项目

 服务端功能细分：

1.支持客户端文件上传功能

2.支持客户端文件备份列表查看功能

3.支持客户端文件下载功能(断点续传)

4.热点文件管理功能(对长时间无访问的文件进行压缩存储)

服务端模块划分:

1.数据管理模块(管理备份文件的文件信息，以便随时获取)

2.网络通信模块(实现客户端网络通信)

3.业务处理模块(上传，列表，下载(断点续传))

4.热点管理模块(对长时间无访问文件进行压缩存储1)



客户端功能：

1.指定目录文件检测(获取文件夹当中有什么文件)

2.判断指定文件是否需要备份(新增文件，已经备份过但是又修改)

> ​	上传后又修改过，但是已经间隔3s中都没有修改过

3.将需要备份的文件上传备份到服务器

客户端模块划分：

1.数据管理模块(备份的文件信息)

2.文件检测模块(监控指定的文件夹)

3.文件备份模块(上传需要备份的文件信息)







bundle文件压缩库

```
使用时只需要包含bundle.h和bundle.cpp即可
内置23种压缩算法和两种存档格式

23种压缩格式
libs{RAW,SHOCO,LZ4F,MINIZ,LZIP,LZMA20,}
```

示例：

```cpp
#inclide><iostream>
#include<fstream>
#include"bundle.h"
int main(int argc,char*argv[])
{
    //argv[1]是原始文件名
    //argv[2]是压缩包名称
    ifstream ifs;
    ifs.open(argv[1],ios::binary);  	 //打开原始文件
    ifs.seekg(0,std::ios::end)            //跳转读写位置到末尾
    size_t fsize=fifs.tellg();            //获取文件长度
    ifs.seekg(0.ios::begin());            //跳转到文件起始位置
    string body;
    body.resize(fsize);                   //调整body大小为文件大小
    ifs.read(&body[0],fsize());           //将文件内容写入到body中
    string packed=bundle::pack(bundle::LZIP,body);   //将body中的数据进行压缩
    std::ofstream;                       //打开要压缩的文件名称
    ofs.open(argv[2],std::ios::binary);
    ofs.write(&packed[0].packed.size());     //将文件进行写入
    ifs.close();
    ofs.close();
}
```

文件类里面文件的压缩和解压缩

```cpp
bool Compress(string &packname)
{
    //1.获取源文件数据
    string body;
    if(this->GetContect(&body)==false)
    {
        LOG();
        return false;
    }
    //2.对数据进行压缩
    std::string packed=bundle::pack(bundle::LZIP,body);
    //3.对压缩数据进行写入
    FileUtile fu(packed);
    if(fu.setcontent(packed)==false)
    {
        return false;
    }
    return true;
}

bool UnCompress(string &filename)
{
    //读取当前压缩包名称
    string body;
    this->GetConnect(body);
    //对当前压缩的数据进行解压缩
    string unpack=bundle::unpack(body);
    //将解压缩的数据写入到新文件中
    FileUtil fu(packname);
    ifI(fu.SetContent(packed)==false)
    {
        return false;
    }
}
```

![image-20220712133108148](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712133108148.png)

![image-20220712133722931](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712133722931.png)

使用工具类目录操作

```CPP
namespacr fs=
bool Exists()
{
		return fs::exists(_fliename);
}
bool CreaterDirectory()
{
    if(this->Exists)
    {
        return true;
    }
    return fs::creatte_directories(_filename);
}

bool ScanDirectory(vector<string>*arry)
{
    for(auto&p:fs::direcotry_iteraotr(_filename))
    {
        if(fs::is_direory(p)==false)
        {
            continue;
        }
        //realtive_path 带有路径的文件名
        arry->push_back(fs::path(p).relative_path().string());
    }
    return true;
}
```

![image-20220712152446601](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712152446601.png)

![image-20220712152548486](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712152548486.png)



![image-20220712201547177](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712201547177.png)

![image-20220712201820066](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220712201820066.png)

![image-20220905123919344](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220905123919344.png)

数据管理模块

```cpp
1.文件的实际存储路径：当客户端要下载文件时，则从这个文件中读取数据进行响应
2.文件的压缩包存放路径名,如果这个文件是一个非热点文件就会被压缩，则这个压缩包路径名称
	如果客户端要下载文件，则需要先解压缩，然后读取解压后的数据文件
3.问价是否压缩的标志位：判断文件是否已经被压缩了
4.文件大小
5.文件最后一次修改事件
6.文件最后一次访问时间
7.文件访问url中的资源路径path


如何管理数据：
	1.用于数据信息访问：hash表在内存中管理数据，以url的path作为key值---查询速度快
	2.持久化存储管理：使用json序列化将所有数据信息保存到文件中

数据信息结构体设计
struct BackupInfo{
	bool pack_flag;//是否被压缩
	size_t fsize;//文件大小
	time_t atime;//文件最后一次访问时间
	time_t mtime;//文件最后一次修改时间
	string real_path;//文件实际存储路径名称
	string pack_path;//压缩包存储路径名称
	string url_path; //外界需要下载的url
}

class DataManger{
    private:
    string _backup_file;//之旧话存储文件
  	unorder_map<string,BackupInfo> _table;//内存中以hash表存储
    pthread_rwlock_t _rwlock;//读写锁---读共享，写互斥
    
    public:
    
    bool Insert(const BackUpInfo&info);//新增
    bool Upfate(const BackupInfo&info);//修改
    boll GetOneByUrl(const string &rul,BackUpInfo*info);
    bool GetOneRealpath(string&path,BackupInfo*info);
    bool GetAll(std::vector<BackupInfo>*array);
}

```

![image-20220713160911450](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220713160911450.png)

  



服务端业务处理模块：将网络通信模块和业务处理进行合并(网络通信通过httplib完成)

1，搭建网络通信服务器：借助httplib完成

2，业务处理请求

​	1.文件上传请求：备份客户端上传的文件，响应上传成功

​	2.文件列表请求：客户端浏览器请求一个备份文件的展示页面，响应页面

​	3.文件下载请求：通过展示页面，点击下载，响应客户端要下载的文件数据

> 当服务器收到post方法的/upload请求，我们则认为这是一个文件上传请求
>
> 解析请求，得到文件数据，将数据写入到文件中

展示页面

>  Get  /listshow http/1.1

> Http/1.1 200 OK
>
> Content-Length:
>
> Content-Type:
>
> \r\n
>
> body

文件下载

> GET /download/text.txt Http/1.1

> http/1.1 200 OK
>
> Content-Length:
>
> Content-Type:
>
> \r\n
>
> body(正文数据)



业务处理模块设计

```cpp
服务端业务处理类设计
class Service
{
	//搭建http服务器，进行业务处理
    private:
    int port;
    string ip;
    string download_prefix;
    httplib::Server _server;
    //文件上传
    static void Upload(const httplib::Request&req,httplib::Response&rsp);
    //页面展示
     static void ListShow(const httplib::Request&req,httplib::Response&rsp);
    //文件下载
     static void Download(const httplib::Request&req,httplib::Response&rsp);
    
    public:
    Service();
    bool RunModule()
    {
        _server.Post("/upload",Upload);
        _server.Get("/listshow",ListShow);
        _server.Get("/",ListShow);
        _server.Get("/download/(.*)",Download);
        _server.listen(_server_ip.c_str(),_server_port);
        return true;
    }
}
```

文件上传请求处理

```cpp
//文件上传
static void Upload(const httplib::Request&req,httplib::Response&rsp)
{
    //post请求 /upload  文件数据在正文中(正文并不一定都是数据)
    
    //判断有没有上传文件的区域
    auto ret=req.has_file("flie");
    if(ret==false)
    {
        RSP.status=400;
        return;
    }
    const auto&file=req.get_flie_value("file");
    string back_dir=Config::GetInstance()->GetBackDir();
    string realpath=back_dir+FileUtil(file.filename).FileName();
    FileUtil fu(realpath);
    fu.SetConnect(file.content);//将文件写入到文件中
	
	//文件持久化存储
 	//将文件信息写入数据管理模块
    
}
```

文件上传

![image-20220714134135441](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220714134135441.png)

页面展示请求

![image-20220714135207028](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220714135207028.png)

```html
<html>
    <head>
        <title>Download</title>
    </head>
    <body>
        <h1>Download</h1>
        <table>
            <tr>
                <td><a href="/download/text.txt">test.txt</a></td>
                <td align="right"> 2022-07-14 10:10:10</td>
                <td align="right"> 28K </td>
            </tr>
        </table>  	
    </body>
</html>
```



```cpp
//页面展示
static void ListShow(const httplib::Request&req,httplib::Response&rsp)
{
     
}
```

文件下载请求

http的ETag头部字段：其中存储了一个资源的唯一标识

客户端第一次下载文件的时候，会受到这个响应信息

第二次下载，就会将这个信息发送给服务器，想要让服务器根据这个唯一标识判断这个资源有没有被修改过，如果没有被修改过111，直接使用原来缓存的数据，不用重新下载了

etag:文件名–文件大小—最后一次修改时间

不仅仅缓存用到，后边断点续传的实现也会用到

因为断点续传也要保证文件没有被修改过

Accept-Ranges:bytes字段：用于告诉客户端我支持断点续传，并且数据单位以字节为单位

```cpp
string GetEtag(std::string filename)
{
    FileUtil fu(filename);
    std::string etag=fu.filename();
    etag+="-";
    etag+=std::to_string(fu.FIleSize());
    etag+="-";
    etag+=std::to_string(fu,LastTIme());
    return etag;
}

//1.获取客户端请求的资源路径path

//2.根据资源路径，获取文件的备份信息
BalcUpInfo info;
_data.GetOneByURL(req.path,&info);
//3.判断文件是否被压缩，如果被压缩，要先解压缩
//  删除压缩包，修改备份信息(已经没有被压缩)
if(info.pack_flag==true)
{
    FileUtil fu(req.pack_path);
    fu.UnComparess(req.real_path);//将文件解压到备份目录中
    fu.Remove();
    info.pack_flag=false;
    _data->Update(info);
}

std::string old_etag;
if(req.has_header("If-Range"))
{
    old_etag=req.get_header_value("If-Range");
    //又If-Range字段且，这个字段的与请求文件的最新etag一致则符合断点续传
    if(old_etag==GetETag(info))
    {
        retans==true;
    }
}
//如果没有If-Range字段则是正常下载，或者如果又这个字段，但是他的值贺当前文件的etag不一致，则也必须重新返回全部数据
//4.读取文件数据，放入rsp.body中
if(retrans==flase)
{
	FileUtil fu(info.real_path);
//设置响应同步字段：ETag,Accept-Ranges:bytes
rsp.set_header("Accept-Ranges","bytes");
rsp.set_header("Etag",GetETag());
rsp.set_header("Content-Type","application/octet-stream");
rsp.status=200;    
}
else
{
    //httplib内部实现了对于区间请求也就是断点续传请求的处理
    //只需要我们用户将文件所有数据读取到rsp.body中，它内部会自动根据请求区间，从body中取出指定区间数据进行响应
    fu.GetContent(&rsp.body);
    rsp.set_header("Accept-Ranges","bytes");
    rsp.set_header("Etag",GetEtag(info));
    rsp.status=206;
}

```

客户端在下载文件的时候，要每次接收到数据吸入文件后记录当前下载的数据量

当异常下载中断时，下次断点续传的时候，将要重新下载的数据区间(下载起始位置，结束位置)发送给服务器，服务器收到后，仅仅回传客户端需要的区间数据即可

问题：上次下载文件之后，这个文件在服务器上被修改了，则这狮虎不能重新断点续传，而是应该重新进行文件下载操作

http协议断点续传的实现:关键点在于：

1.在于告诉服务器下载区间范围

2.服务器上要能够检测上一次下载之后这个文件是否被修改过

断点续传：

GET /download/text.txt HTTP/1.1

if_Range:”服务端在下载时响应的etag字段”用于服务端判断这个文件宇原先下载的文件是否一致

Range：bytes 100-10000 这个字段用于告诉服务器科幻段需要的数据区间范围

HTTP/1.1 206 Partial Content

ETag:”sdadaaad”

Content-Range:bytes 100-1000/文件大小



客户端

要实现的功能：自动对指定文件夹中的文件进行备份

进行的模块划分：

数据管理模块：管理备份的文件信息

目录遍历模块：获取指定文件夹中所有文件路径名

文件备份模块：将需要备份的文件上传备份到服务器

客户端要备份文件，说明文件需要备份，都是通过数据管理判断的



数据管理模块：要管理的数据设计

数据管理模块:其中的信息用于判断一个文件是否需要重新备份

​	1.文件是否是新增的

​	2.不是新增的，则上次备份后有没有被修改过

管理的数据：文件的路径名，文件的唯一标识

当前客户端的程序开发，是在window下的，

数据管理模块实现思想：

1.内存存储：高访问效率——使用unordered_map

2.持久化存储：文件处处

 文件存储涉及到数据序列话：因为在vs中按照jsoncpp较为 麻烦



客户端数据管理模块实现——数据管理类设计

```cpp
class DataManger{
    private:
    std::unorder_map<string,string>_table;
    std::string _back_file;
    public:
    DataManger(const std::string&back_file):_backup_file(back_file);
    bool InitLoad()//程序运行时加载以前的数据
    {
        //1.从文件中读取所有数据
        FileUtil fu(_back_file);
        std::string body;
        fu.GetContent(&body);
        //2.进行数据解析，添加到表中
        
        //3.
        return true;
    }
    bool Storage()//持久化存储
    {
        //1.获取所有的备份信息
        auto it=_table.begin();
        stringstream ss;
        for(;it!=_table.end();++it)
        {
            //2.将所有信息进行指定持久化格式的组织
            ss<<it->first<<" "<<it->second<<"\n";
        }
        //3.持久化存储
        FileUtil fu(_backup_file);
        fu.SetContent(ss.str());
        return true;
    }
    bool Insert(const std::string &key,const std::string&val)
    {
        _TABLE[KEY]=VAL;
        return true;
    }
    bool Update(const stdLLstring&key,const std::string&val)
    {
        _table[key]=val;
        return true;
    }
    bool GetOneByKey(const std::string&key,std::string*val)
    {
        auot it=_table.find(key);
        if(it==_table.end())
        {
            return false;
        }
        *val=it->second;
        return true;
    }
}
```

客户端功能实现:自动将指定文件夹中的文件备份到服务器

流程：

1.遍历指定文件夹，获取文件信息

2.注意判断文件是否需要备份

3.需要备份的文件进行上传

```cpp
#define SEVER_ADDR "39.105.98.201"
#define SERVER_PORT 8080
class Backup{
    private:
    string _back_dir; //要监控的文件夹
    DataManger*_data; //数据管理类
    public:
    Backup(const string&backdir,const string &back_file ):_back_dir(back_dir)
    {
        _data=new DataManger(back_file)
    }
    //客户端运行
    bool RunModule()
    {
     while(1)
     {
         //1，遍历获取只当文件夹中所有文件
         //2，逐个判断文件是否需要上传
         //3，如果需要上传，则上传文件
         FIleUtil fu(_back_dir);
        vector<string>array;
        fu.ScanDirectory(&array);
        for(auto &a:array)
        {
            if(IsNeedUpload(a))
            {
                if(Upload(a)==true)
                {
                    _data->Insert(a,GetFileIdentifier(a));//新增文件备份信息
                    
                }
            }
        }
         Sleep(1000);
     }
    }
    
    string GetFileldentifier(const std::string &filename)//计算文件的唯一标识
    {
        //a.txt-fsize-mtime
        FileUtil fu(filename);
        std::stringstream ss;
        ss<<fu.FileName()<<"-"<<fu.FileSize()<<"-"<<fu.LastMTime)<<endl;
        return ss.str();
    }
    bool Upload(const std::string &filename)
    {
        //1.获取文件数据
        FileUtile fu(filename);
        string body;
        fu.GetContent(&body);
        //2.搭建http服务器
        httplib::client client(ip,port);
        httplib::MultipartFormData item;
        item.content=body;
        item.filename=fu.FileName();
        item.name="file";
        item.content_type="application/octet-stream";
        httplib::MultipartFormDataItems items;
        items.push_back(item);
        auto res=client.Post("/upload",items);
        if(!res||rest->status!=200)
        {
            return false;
        }
        return true;
    }
    
    bool IsNeedUload(string filename)
    {
        //需要上传文件条件：
        //1.文件时新增的：看一下有没有历史备份信息
        string id;
        if(_data->GetOneByKey(filename,&id)!=false)
        {
            string new_id=GetFileIdentifie(filenmae);
            if(new_id==id)
            {
                return false;// 不需要被上传，上次上传后没有被修改过
                
            }
        }
        
        
        //不是新增但是被修改国，唯一标识与当前唯一标识不一致
        
        //一个文件比较大，正在徐徐拷贝到这个目录下，拷贝需要一个过程，如果每次遍历都会判断标识不一致，
        //因此应该判断一个文件一段时间都没有被修改过了，才能上传
        
        FIleUtile fu(file);
        if(time(NULL)-fu.LastMTime()<3)
        {
            //3秒之内被修改过，不上传
            return false
        }
        
        return true;
    }
    
}
```

![image-20220905200723676](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220905200723676.png)



```
#include"Util.hpp"
#include"data.hpp"
#include"cloud.hpp"

```

自我总结

客户端模块：

1.文件管理模块：实现文件的写入与解压缩

```cpp
//实现压缩与解压缩
class Compress
{
	private:
    string compress(string &body)
    {
        
    }
    
    string uncompress(string& body)
    {
        return 
    }
}
```

2.服务端业务模块：利用httplib实现文件的上传，下载，页面展示功能

客户端功能：

1.文件管理：

扫描指定目录下所有文件，上传文件

2.httplib客户端搭建：

搭建httplib客户端，实现文件的上传功能
