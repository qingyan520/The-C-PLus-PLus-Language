# 轻量级高并发服务器开发

## HTML简介

### 文字和标题标签

```
1. 标题标签:
	• <h1></h1> // 最大
		○ 只有一个
		○ 搜索引擎优化: seo
	• <h2></h2>
	• ...
	• <h6></h6> // 最小
	• 1-6依次变小, 自动换行
2. 文本标签
	• <font></font>
		○ 属性: 
			§ color: 文字颜色
				□ 表示方式:
					® 英文单词: red green blue......
					® 使用16进制的形式表示颜色: #ffffff  -- (rgb)
					® 使用rgb(255, 255, 0)
			§ size: 文字大小
				® 范围 1 -- 7
					® 7最大
					® 1最小
3. 文本格式化标签
	• 文本加粗标签 
		○ <strong></strong> 
		○ <b></b> 
		○ 工作里尽量使用strong
	• 文本倾斜标签 
		○ <em></em> 
		○ <i></i> 
		○ 工作里尽量使用em
	• 删除线标签 
		○ <del></del> 
		○ <s></s> 
		○ 工作里尽量使用del
	• 下划线标签（插入文本）
		○ <ins></ins> 
		○ <u></u> 
		○ 工作里尽量ins
4. 段落：
	• <p>xxx</p>
		○ 特点:
			§ 上下自动生成空白行
5. 块容器: 
	• <div>This is a div element.</div>
	• 用于没有语义含义的内容的块级容器(或网页的"划分")。
	• 属性: 对齐方式
		○ align
			§ left
			§ center
			§ right
6. 换行
	• <br/> 
7. 水平线
	• <hr/>
		○ 属性: 
			§ color: 3种表示方法
			§ size: 1-7
			§ <hr color="red" size="3"/>

```

例如：

```html
<html>
    <body>
        <h1>hello world</h1>
        <h2>hello world</h2>
        <h3>hello world</h3>
        <front color="red" size="7">hello world</front>
        <p>hello world</p>
        
    </body>
</html>
```



### 列表标签

```
	1. 无序列表
		○ 标签
		<ul>
			<li></li>  列表项
			<li></li>
		</ul>
		○ 属性: type
			§ 实心圆圈: disc   -- 默认
			§ 空心圆圈: circle
			§ 小方块: square
	2. 有序列表
		○ 标签
		<ol>
			<li></li>  列表项
			<li></li>
		</ol>
		○ 属性: 
			○ type -- 序号
				□ 1 -- 默认
				□ a
				□ A
				□ i   -- 罗马数字(小)
				□ I   -- 罗马数字(大)
			○ start
				□ 从序号的什么位置开始表示
	3. 自定义列表
		○ 标签
		<dl>
			<dt></dt> 小标题
				<dd></dd> 解释标题
				<dd></dd> 解释标题
		</dl>
		

```



### 图片标签

```
图片标签
	• <img src="3.gif" alt="小岳岳" title="我的天呐！" width="300" height="200" />
		○ 属性: 
			§ src: 图片的来源 必写属性
			§ alt: 替换文本 图片不显示的时候显示的文字
			§ title: 提示文本 鼠标放到图片上显示的文字
			§ width: 图片宽度
			§ height: 图片高度
		○ 注意：
			§ 图片没有定义宽高的时候，图片按照百分之百比例显示
如果只更改图片的宽度或者高度，图片等比例缩放。
```

### 超链接标签

```
	1. 超链接标签
	- <a href="http://jd.com" title="A dog" target="_blank">超链接</a>
		○ 属性:
			○ href: 去往的路径（跳转的页面）必写属性
			○ title: 提示文本, 鼠标放到链接上显示的文字
			○ target
				□ _self:   默认值 在自身页面打开（关闭自身页面，打开链接页面）
				□ _blank: 打开新页面 （自身页面不关闭，打开一个新的链接页面）
		○ 示例:
			○ <a href="http://www.baidu.com">百度一下</a>
	2. 锚链接
		○ 先定义一个锚点: <p id="sd">
		○ 超链接到锚点: <a herf="#sd">回到顶点</a>

```



### 表格标签

```
1. 表格标签
	○ <table></table>
		§ 属性:
			□ border -- 表格线, 宽度1-7
			□ bordercolor -- 表格线颜色
			□ width
			□ height 
	○ <tr> -- 行 
		§ 属性
			□ align -- 对齐方式
				® center
				® left
				® right
	○ <td> -- 单元格(列)
		§ 对其属性设置同tr
	○ 示例:
	<table border=>
		<tr>
			<td></td>  第一列
			<td></td>  第二列
		</tr>
		<tr>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</table>

```

## http协议

![image-20220322212808025](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220322212808025.png)



## epoll模型

### main.cpp

```cpp
#include<stdio.h>
#include<iostream>
#include<unistd.h>
#include<stdlib.h>
#include<dirnet.h>
int main(int argc,const char*argv[])
{
 	if(argc<3)
    {
        cout<<"eg: ./a.out port path\n";
        exit(1);
    }
    int port=atoi(argv[1]);
    //修改进程工作目录，方便后续工作
    int ret=chdir(argv[2]);
    if(ret==-1)
    {
        cerr<<"chdir error!"<<endl;
        exit(1);
    }
    //启动epoll模型
    
    
    return 0;
}
```

### epoll_server.cpp

```cpp
#include<iostream>
#include<string>
#include<cstring>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<sys/epoll.h>
#include"epoll_server.h"
#include<fcntl.h>
#include<sys/stat.h>
#define MAXSZIE 2000
void epoll_run(int port)
{
	 //创建epoll的根节点
    int epfd=epoll_create(1000);
    if(epfd==-1)
    {
        cerr<<"error!"<<endl;
        exit(1);
    }
    
    //得到监听套接字
 
    //添加监听的节点
    //先添加监听的lfd;
      int lfd=init_listen_fd(port,epfd);
    //委托内核进行检测
 	stuct epoll_event all[MAXSIZE];
   
    while(1)
    {
        int ret=epoll_wait(epfd,all,MAXSIZE,-1);
        if(ret==-1)
        {
            cerr<<"epoll_wait error!"<<endl;
            exit(0);
        }
        
        for(int i=0;i<ret;i++)
        {
            //只处理读事件，其它事件默认不处理
            struct epoll_event*pev=&all[i];
            if(!(pev->ecent&EPOLLIN))
            {
				continue;                
            }
            if(pev->data.fd==lfd)
            {
                //接受连接请求
                do_accept(lfd,epfd);
            }
            else
            {
                //读数据
                do_read(pev->data.fd,epfd);
            }
        }
    }
    
}


//读数据
void do_read(int cfd,int epfd)
{
    //将浏览器发送的数据读到buf里
    //recv
    char line[1024]={0};
    //读请求行
    int len=get_line(cfd,line,sizeof(line));
    if(len==0)
    {
        cout<<"Client Qiut!"<<endl;
        //关闭套接字，cfd从epoll树上清楚
  		disconnect(fd,epfd);    
    }
    else if(len==-1)
    {
        //关闭套接字
        cerr<<"recv error!"<<endl;
        exit(1);
    }
    else
    {
        //buf中还有数据
        //继续读
        cout<<"请求行数据:"<<line<<endl;
        while(len)
        {
            char buf[1024]={0};
            len=get_line(cfd,buf,sizeof(buf));
            printf("========请求头======\n");
            cout<<"------"<<buf<<endl;
        }
    }
    
    //请求行:get /xxx http/1.1
    //判断是否为get请求
    if(strncasecmp(line,"get",3)==0)//加case表示不区分大小写
    {
        //处理http请求
        http_request();
    }  
    
}


//断开连接的函数
void disconnect(int cfd,int epfd)
{
    int ret=epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);
    if(ret==-1)
    {
        cout<<"error!"<<endl;
    }
    close(cfd);
}


//http请求处理
void http_request(const char*request.int cfd)
{
    //拆分http请求
    char method[12],path[1024],protocol[12];
    sscanf(request,"%[^ ] %[^ ] %[^ ]",method,poth,protocol);
    cout<<"mothod="<<methd<<" "<<"path="<<path<<" "<<"protocol="<<protocol<<endl;
    //转码，将不能识别的中文乱码---》中文
    
    
    //处理path,去掉/
    
    char*flie=path+1;
    
    //如果没有指定访问指定资源路径，默认显示资源目录内的内容
    if(strcmp(path,"/")==0)
    {
        //file的值就是当前资源目录的根目录
        file="./";
    }
    
    //获取文件属性
    struct stat st;
    int ret=stat(file,&st);
    if(ret==-1)
    {
        //show 404;
        send_respond_head(cfd,404,"File Not Found",".html",-1)
        send_file(cfd,"404.html");
    }
    
    //如果是目录
    if(S_ISDIR(st.st_mode))
    {
        //发送头信息
        send_respond_head(cfd,200,"OK","text/html",-1);
        //发送目录信息
        send_dir(cfd,file);
    }
    else if(S_ISREG(st.st_mode))
    {
        //文件
        //发送消息头的函数
        send_respond_head(cdf,200,"OK","text/plain",st.st_size);
        
        //发送文件内容
        send_file(cfd,file);
        
    }
    else
    //判断是目录还是文件
    
    
}



//发送目录的函数
void send_dir(int cfd,const char*dirname)
{
    //平一个html页面</table>标签
    char buf[4096]={0};
    sprintf(buf,"<html><head><title>目录名:%s</title></head>",dirname);
    sprintf(buf+strlen(buf),"<body><h1>当前目录:%s<h1><table>",dirname);
  //  #if 1
        //打开目录
  //      DIR*dir=opendir(dirname);
    //	if(dir==nullptr)
      //  {
        //    cerr<<"error!"<<endl;
        //}
    	//读目录
   // 	struct dirnet*ptr=NULL;
    //	while((ptr==readdir(dir))!=NULL)
      //  {
        //    sprintf(buf,"<tr><td></td>")
          //  char*name=ptr->d_name;
            
        //}
    	//closedir(dir);
    //#endif
    
    //目录项指针
    struct dirent**ptr;
    int num=scandir(dirname,&ptr,NULL,alphasort);
    char path[1024]={0};
    //遍历
    for(int i=0;i<num;i++)
    {
        char*name=ptr[i]->d_name;
        //拼接文件完整路径
        sprintf(path," /%s",dirname,name);
        cout<<"path=%s"<<path<<"================"<<endl;
        struct stat st;
        stat(path,&st);
        //如果是文件
        if(S_ISREG(st.st_mode))
        {
            sprintf(buf+strlen(buf),"<tr><td><a href=\"%s\">%s</a><td>%ld</td>",
                   dirname,
                   dirname
                   (long)st.st_size
                   );
        }
        //如果是目录
        else if(S_ISDIR(st.st_mode()))
        {
            printf(buf+strlen(buf),"<tr><td><a href=\"%s/\">%s</a><td>%ld</td>",
                   dirname,
                   dirname
                   (long)st.st_size
                   );
        }
        send(cfd,buf,sizeof(buf),0);
        memset(buf,0,sizeof(buf));
        //字符串拼接
		
    }
    sprintf(buf+strlen(buf),"</table></body></html>");
    send(cfd,buf,sizeof(buf),0);
    printf("dir message send OK!!!\n");
}


//发送响应报头
void send_respond_head(int cfd,int no,const char*desp,const char*type,long len)
{
    string buf;
    //状态行
    buf+="http/1.1 ";
    buf+=std::to_string(no);
    buf+=" ";
    buf+=desp;
    buf+="\r\n";
    send(cfd,buf.c_str(),buf.size(),0);
    
    //消息报头
    buf="";
    buf="Content-Type:";
    buf+=type;
    buf+="\r\n";
    send(cfd,buf.c_str(),buf.size(),0);
    
    buf="Content-Length:";
    buf+=to_string(len);
    buf+="\r\n";
    send(cfd,buf.c_str(),buf.size(),0);
    //空行
    buf="\r\n";
    send(cfd,buf.c_str(),buf.size(),0);
    
}


void send_file(int cfd,const char*fliename)
{
    //打开文件
    int fd=open(filename.O_RDONLY);
    if(fd==-1)
    {
        //show 404
        return;
    }
    
    //循环读文件
    char buf[4096];
    int len=0;
    while(len=read(fd,buf,sizeof(buf))>0)
    {
        //读出的数据
        send(cfd,buf,len,0);
    }
    if(len==-1)
    {
        cerr<<"read file error!"<<endl;
        exit(1);
    }
    close(fd);
}

//解析http请求消息的每一行内容
int get_line(int sock,char*buf,int size)
{
    int i=0;
    char c='\0';
    int n;
    while((i<size-1)&&(c!='\n'))
    {
        n=recv(sock,&c,1,0);
        if(n>0)
        {
            if(c=='\r')
            {
                n=recv(sock,&c,1,MSG_PEEK);
                if((n>0)&&(c=='\n'))
                {
                    recv(sock,&c,1,0);
                }
                else
                {
                    c='\n';
                }
            }
            buf[i]=c;
            i++;
        }
        else
        {
            c='\n''
        }
    }
    buf[i]='\0';
    if(n==-1)
    {
        i=-1;
    }
    return i;
}

//接受连接处理
void do_accept(int lfd,int epfd)
{
    struct sockaddr_in client;
    socketlen_t len=sizeof(client);
    //accept
    int cfd=accept(lfd,(struct sockaddr*)&client,&len);
    if(cfd==-1)
    {
        cerr<<"error!"<<endl;
        exit(0);
    }
    char ip=[0];
    int port=ntohs(client.sin_port);
    string ip=inet_ntoa(client.sin_addr);
    cout<<ip<<":"<<port<<endl;
    
    //设置cfd为非阻塞
    int flag=fcntl(cfd,F_GETFL);
    flag|=O_NONBLOCK;
    fcntl(cfd,F_SETFL,flag);
    
    //加入到树上
    struct epoll_event ev;
    //设置边沿非阻塞
    ev.events=EPOLLIN|EPOLLET;
    ev.data.fd=cfd;
    int ret=epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);
    if(ret==-1)
    {
        cerr<<"";
        exit(1);
    }
}


int init_listen_fd(int port,int epfd)
{
    //创建套接字
    int lfd=socket(AF_INET,SOCK_STREAM,0);
    if(lfd==-1)
    {
        eixt(0);
    }
    
    //bind
    struct sockadd_in serv;
    serv.sin_famliy=AF_INET;
    serv.sin_port=htons(port);
    serv.sin_addr.s_addr=INADDR_ANY;
    int flag=1;
    setsockopt(lfd,SOL_SOCKET<SO_RESUEADDR,&flag,sizeof(flag));
    if(bind(lfd,(struct sockaddr*)&serv,sizeof(serv))<0)
    {
        exit(0);
    }
    //listen
    if(listen(lfd,64)<0)
    {
        exit(1);
    }
    struct epoll_event ev;
    ev.event=EPOLLIN;
    ev.data.fd=lfd;
    ret=epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
    if(ret==-1)
    {
        cerr<<"error"<<endl;
        exit(1);
    }
    
    return lfd;
}
```

### epoll_server.h

```cpp
void epoll_run(int port);
int init_listen_fd(int port,int epfd);
void do_accept(int lfd,int epfd);
int get_line(int sock,char*buf,int size);
void send_dir(int cfd,const char*dirname);
void send_file(int cfd,const char*fliename);
```





目录的读取

```
int scandir (const char*dirp,
	struct dirent***namelist,
	int(*filter)(const struct dirent*),
	int(*compar)(const struct dirent**,const struct dirent**)
);

dirp:当前要扫描的目录

namelist:
--struct dirent**ptr;
--struct dirent*ptr[];

filter:
--NULL

compar:
--文件名显示的时候，指定排序规则
--alphasort
--versionsort

```



```apl
unicode
unicode 
```

线程池介入

```
1.初始化一些线程
管理者线程：不处理任务
工作线程：只负责处理任务，去任务队列中领取任务
初始化时给定一个最小线程数

2.休要有一个管理者线程
--每隔一段事件去哦按段一次
--什么时候需要创建
	指定一个峰值
		工作的线程·超过85%
		工作/存活>0.85
	超过峰值：
		创建新的线程
		每次创建10个
--什么时候销毁
	工作的线程/存活的线程<20%
	按照一定的比例杀死不干活的线程

3.线程工作的时候
	
```

