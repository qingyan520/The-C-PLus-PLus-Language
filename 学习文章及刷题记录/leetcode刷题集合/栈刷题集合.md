# 栈刷题集合



#### [面试题 03.02. 栈的最小值](https://leetcode-cn.com/problems/min-stack-lcci/)

> 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。
>

```cpp
//示例：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

> 本题思路：首先栈的push，top,操作我们可以直接用stl库函数，最麻烦的是min函数，而且时间复杂度为O(1)，这个思想非常重要，定义一个栈s1,专门用来存放栈中的元素，完成栈的push,pop工作，然后定义一个辅助栈，来存放最小值，使得每一个s1对应的栈顶元素都有对应的最小值

![image-20210605210907382](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210605210907382.png)

![image-20210605210934439](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210605210934439.png)

![image-20210605211006440](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210605211006440.png)

```cpp
class MinStack {

public:

  /** initialize your data structure here. */

  //1.定义两个栈，第一个栈用来存储值
  //第二个栈用来寻找最小值
  stack<int>s1;

  stack<int>s2;

  MinStack() {
​    //先将s2初始化
​    s2.push(INT_MAX);
  }

  void push(int x) {

​    //为s1赋值

​    s1.push(x);

​    //每次找到栈顶元素和输入元素的较小值进行比较，使得s1的每个主站元素都有其对应的最小值

​    s2.push(min(s2.top(),x));

  }

  

  void pop() {

​    //s1执行pop操作

​    //与之对应的最小值也执行pop操作，让每个栈顶元素与最小值进行对应

​    s1.pop();

​    s2.pop();
  }


  int top() {
​    return s1.top();
  }
  
  
  int getMin() {
​    return s2.top();
  }
};

/**

 \* Your MinStack object will be instantiated and called as such:

 \* MinStack* obj = new MinStack();

 \* obj->push(x);

 \* obj->pop();

 \* int param_3 = obj->top();

 \* int param_4 = obj->getMin();

 */
```

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
>

```cpp
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1


示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

思路：首先建立一个栈，我们将pushed中的元素进行入栈，判断栈中的top()和popped中的元素是否相等，如果相等那么就st.pop(),popped中的元素向后走一位，之后再将pushed中的下一个元素继续入栈;如果不相等就将push元素后移，循环结束条件为i<push.size(),此时pushed数组已经走到了结尾，最终只需要判断popped数组是否走到了结尾，要是两者都走到了结尾，就说明两者为栈的压入与弹出，不相等说明不是栈的压入与弹出

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        int i=0;
        int j=0;
        //建立一个栈
        stack<int>st;
        //循环结束条件：pushed数组遍历完
        while(i<pushed.size())
        {
        	//每次将pushed[i]进入栈中
            st.push(pushed[i]);
            //判断刚进入栈的元素，即栈顶元素是否与popped[j]相等，相等st.pop(),j++
            while(!st.empty()&&st.top()==popped[j])
            {
                st.pop();
                j++;
            }
            //直到st,top()与popped[j]不相等
            之后++i;
            i++;
        }
        //判断是否为栈的压入与弹出只需要判断popped数组是否走完了
        return j==popped.size();
}
};
```

