# 回溯算法刷题合集

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```cpp
示例:
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```cpp
//回溯算法求组合问题：

//1.首先构建数组存放要返回的值

//2.判断递归结束的条件

//3.for循环遍历（注意看清楚从哪个位置开始遍历）

//4.递归

//5.回溯

//回溯相当于进行n层for循环





class Solution {
public:
  vector<int>path;
  vector<vector<int>>ret;
  void backtracking(int n,int k,int j)
  {
​    //1.确定终止条件
​    if(path.size()==k)
​    {
​      ret.push_back(path);
​      return ;
​    }
​    //2.for循环+递归相当于进行n层for循环
​    //每次递归完之后记着回退到上一个位置
​    for(int i=j;i<=n;i++)
​    {
​      path.push_back(i);
​      backtracking(n,k,i+1);
​      path.pop_back();
​    }
  }
  vector<vector<int>> combine(int n, int k) {
​    backtracking(n,k,1);
​    return ret;
  }
};
```

#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```cpp
示例:
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

```cpp
//回溯是一种暴力搜索算法，相当于n层for循环

//1.确定循环终止条件

//2.for循环

//3.回溯

class Solution {
public:
  vector<string>ret;
  void backtrack(string&s,string&str,vector<bool>used)
  {
​    //1.确定循环条件
​    if(str.size()==s.size())
​    {
​      ret.push_back(str);
​    }
​    //2.开始循环
​    for(int i=0;i<s.size();i++)
​    {
​      //2.1去除重复元素
​      if(i>0&&s[i]==s[i-1]&&used[i-1]==false)
​      continue;
​      //2.如果used[i]==false，说明该位置还没有字符，进入
​      if(used[i]==false)
​      {
​        used[i]=true;
​        str.push_back(s[i]);
​        //进入递归
​        backtrack(s,str,used);
​        //进入回溯过程
​        str.pop_back();
​        used[i]=false;
​      }
​    }
  }

  vector<string> permutation(string s) {
​    ret.clear();
   vector<bool>used(s.size(),false);
​    sort(s.begin(),s.end());
​    string str;
​    backtrack(s,str,used);
​    return ret;
  }
};
```

