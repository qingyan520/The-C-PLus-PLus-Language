# 回溯算法刷题合集

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```cpp
示例:
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```cpp
//回溯算法求组合问题：

//1.首先构建数组存放要返回的值

//2.判断递归结束的条件

//3.for循环遍历（注意看清楚从哪个位置开始遍历）

//4.递归

//5.回溯

//回溯相当于进行n层for循环





class Solution {
public:
  vector<int>path;
  vector<vector<int>>ret;
  void backtracking(int n,int k,int j)
  {
​    //1.确定终止条件
​    if(path.size()==k)
​    {
​      ret.push_back(path);
​      return ;
​    }
​    //2.for循环+递归相当于进行n层for循环
​    //每次递归完之后记着回退到上一个位置
​    for(int i=j;i<=n;i++)
​    {
​      path.push_back(i);
​      backtracking(n,k,i+1);
​      path.pop_back();
​    }
  }
  vector<vector<int>> combine(int n, int k) {
​    backtracking(n,k,1);
​    return ret;
  }
};
```

#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```cpp
示例:
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

```cpp
//回溯是一种暴力搜索算法，相当于n层for循环

//1.确定循环终止条件

//2.for循环

//3.回溯

class Solution {
public:
  vector<string>ret;
  void backtrack(string&s,string&str,vector<bool>used)
  {
​    //1.确定循环条件
​    if(str.size()==s.size())
​    {
​      ret.push_back(str);
​    }
​    //2.开始循环
​    for(int i=0;i<s.size();i++)
​    {
​      //2.1去除重复元素
​      if(i>0&&s[i]==s[i-1]&&used[i-1]==false)
​      continue;
​      //2.如果used[i]==false，说明该位置还没有字符，进入
​      if(used[i]==false)
​      {
​        used[i]=true;
​        str.push_back(s[i]);
​        //进入递归
​        backtrack(s,str,used);
​        //进入回溯过程
​        str.pop_back();
​        used[i]=false;
​      }
​    }
  }

  vector<string> permutation(string s) {
​    ret.clear();
   vector<bool>used(s.size(),false);
​    sort(s.begin(),s.end());
​    string str;
​    backtrack(s,str,used);
​    return ret;
  }
};
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

> 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
>
> 说明：
>
> 所有数字都是正整数。
> 解集不能包含重复的组合。

```cpp
示例 1:
输入: k = 3, n = 7
输出: [[1,2,4]]

示例 2:
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

本题与上面的77题组合问题非常相似，就是组合问题加上限制条件即可，这次不光要path.size==k,还要使path数组的和为n,因此我们只要对上面的组合的代码加一些限制即可

```cpp
class Solution {
public:
  //定义一个二维数组ret用来存放最终要返回的结果
  vector<vector<int>>ret;
   //path一位数组用来存放每次遍历的值
  vector<int>path;
    //定义回溯函数backtracking,startIndex代表每次开始时的下标，k为数字个数，m为和，sum为数组path的各个元素之和
  void backtrack(int startIndex,int k,int n,int sum)
  {
      //与基础组合不同，这里需要强化条件，数量相等时，则进一步判断path的大小与题目要求的大小是否相等
​    if(path.size()==k)
​    {
    	//如果path数组的大小与题目要求的数组大小相同，则将该数组尾插到ret中
​      if(sum==n)
​      {
​        ret.push_back(path);
​      }
    	//不相等或者尾插后return，返回到上一层
​      return;
​    }
      //回溯算法的经典环节，for循环环节，
​    for(int i=startIndex;i<=9;i++)
​    {
    //每次计算sum的值
​      sum+=i;
    //如果sum>n,直接返回，枝剪
​      if(sum>n)
​      break;
    //入值
​      path.push_back(i);
    //递归
​      backtrack(i+1,k,n,sum);
    回溯
​      sum-=i;
​      path.pop_back();
​    }
  }

  vector<vector<int>> combinationSum3(int k, int n) {
​    path.clear();
​    ret.clear();
​    backtrack(1,k,n,0);
​    return ret;
  }
};
```

