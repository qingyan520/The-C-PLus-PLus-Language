# 二叉树刷题合集

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

![image-20210930100717549](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210930100717549.png)

```cpp
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
```

> 本题目是二叉树系列的入门题目，二叉树的遍历，可以用递归和迭代两中方式实现
>
> 递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
//递归进行前序遍历
    void _preorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return ;
        ret.push_back(root->val);
        _preorderTraversal(root->left,ret);
        _preorderTraversal(root->right,ret);
    }
    vector<int> preorderTraversal(TreeNode* root) {
          vector<int>ret;
          _preorderTraversal(root,ret);
          return ret;
    }
};
```

> 非递归版本：借助栈实现二叉树的前序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>ans;
        stack<TreeNode*>s;
        if(root==nullptr)
        return ans;
        s.push(root);
        while(!s.empty())
        {
            TreeNode*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ans.push_back(front->val);
            s.push(front->right);
            s.push(front->left);
        }
        return ans;
    }
};

```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

![image-20210930101453087](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210930101453087.png)

```cpp
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```cpp
示例 2：
输入：root = []
输出：[]
```

```cpp
示例 3：
输入：root = [1]
输出：[1]
```

递归版本：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //递归实现二叉树的中序遍历
class Solution {
public:
    void _inorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return;
        _inorderTraversal(root->left,ret);
        ret.push_back(root->val);
        _inorderTraversal(root->right,ret);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>ret;
        _inorderTraversal(root,ret);
        return ret;

    }
};
```

> 非递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        //二叉树的非递归实现，借助stack
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<TreeNode*>s;
        TreeNode*cur=root;
        while(cur!=nullptr||!s.empty())
        {
            if(cur!=nullptr)
            {
                s.push(cur);
                cur=cur->left;
            }
            else
            {
                cur=s.top();
                s.pop();
                ret.push_back(cur->val);
                cur=cur->right;
            }
        }
        return ret;

    }
};
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 *后序* 遍历。

```cpp
示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
```

> 1.迭代法：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void _postorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return ;
        _postorderTraversal(root->left,ret);
        _postorderTraversal(root->right,ret);
        ret.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>ret;
        _postorderTraversal(root,ret);
        return ret;
    }
};
```

> 非递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //后序遍历与前序遍历非常相似，后序遍历的访问顺序是左右中，
 //前序遍历在代码中的实现：中右左----->而借助栈使得左右出栈顺序发生变化:----->中左右
 //后续遍历代码中的方式与前序遍历相似：
 //代码中:中左右---------->借助栈之后:------------>中右左------反转数组----->左右中

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<TreeNode*>s;
        s.push(root);
        while(!s.empty())
        {
            TreeNode*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ret.push_back(front->val);
            if(front->left)
            s.push(front->left);
            if(front->right)
            s.push(front->right);
        }

        reverse(ret.begin(),ret.end());
        return ret;

    }
};
```



#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

> 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
>
> 例如：
>

```cpp
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

该题目比较简单，为二叉树基本类型的题目，二叉树一般都要用到递归来解决

首先我们能够想到，一个数如果root==nullptr,说明该数节点为0，如果root!=nullptr并且它的左右子树都为nullptr,说明该节点即为叶子节点，那么我们就能写出以下代码：

```cpp
class Solution {
public:
  int maxDepth(TreeNode* root) {
​    if(root==nullptr)
​    {
​      return 0;
​    }
​    if(root->left==nullptr&&root->right==nullptr)
​    {
​      return 1;
​    }
​    return max(maxDepth(root->left),maxDepth(root->right))+1;
  }
};
```





```cpp
//根据前序和中序或者中序和后续就能重建二叉树

class Solution {
public:

  TreeNode*_bulidTree(vector<int>&preorder,int pre_start,int pre_end,vector<int>&inorder,int ind_start,int ind_end)
  {
      //递归终止的条件
​    if(pre_start>pre_end||ind_start>ind_end)
​    {
​      return nullptr;
​    }


	//创建根结点
​    TreeNode*root=new TreeNode(preorder[pre_start]);
      //在中序序列中找到根结点，将中序序列分成左右子树，前序序列往后数对应的左子树数量
​    for(int i=0;i<=ind_end;i++)
​    {
​      if(root->val==inorder[i])
​      {
​        root->left=_bulidTree(preorder,pre_start+1,pre_start+i-ind_start,inorder,ind_start,i-1);
​        root->right=_bulidTree(preorder,pre_start+i-ind_start+1,pre_end,inorder,i+1,ind_end);
​      }
​    }
​    return root;
  }

  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      //数据不正确，直接进行退出
​    if(preorder.empty()||inorder.empty()||preorder.size()!=inorder.size())
​    {
​      return nullptr;
​    }
​    return _bulidTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
  }
};
```

#### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```cpp
例如：
给定二叉树 [3,9,20,null,null,15,7],
​    3 
​	/ \
  9  20
​    /  \
   15   7
   
返回其自底向上的层序遍历为：
[
  [15,7],
  [9,20],
  [3]
]
```

首先完成二叉树的层序遍历，然后将数组进行逆置，就完成了自低向下的二叉树的层序遍历，故此题的难点是完成二叉树的层序遍历

这里我们借助队列来实现，利用队列先进先出的特性完成每一次的遍历

![image-20210910163828156](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210910163828156.png)

```cpp
class Solution {
public:
//利用队列进行实现
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*>q;
        vector<vector<int>>vv;
        if(root!=nullptr)
        {
            q.push(root);
        }
        int levelsize=0;
        while(!q.empty())
        {
            vector<int>v;
            levelsize=q.size();
            for(int i=0;i<levelsize;i++)
            {
                TreeNode*front=q.front();
                q.pop();
                v.push_back(front->val);
                if(front->left!=nullptr)
                {
                    q.push(front->left);
                }
                if(front->right!=nullptr)
                {
                    q.push(front->right);
                }
            }
            vv.push_back(v);
        }
        reverse(vv.begin(),vv.end());
        return vv;
    }
};
```

#### [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode-cn.com/problems/LwUNpT/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

![image-20210929085859578](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929085859578.png)

```cpp
输入: root = [2,1,3]
输出: 1
```

![image-20210929085938083](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929085938083.png)

```cpp
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

> 思路：最简单的方法：借助上面二叉树层序遍历的方法，先将二叉树层序遍历，然后返回最一层第一个元素即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //二叉树的层序遍历，然后返回最后列数组的第一个元素就可以
 //二叉树的层序遍历要借助队列先进先出的特性，将二叉树的左右子节点都入到队列种去
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root==nullptr)
        {
            return -1;
        }
        //建立队列，存储每一个元素
        queue<TreeNode*>q;
        vector<vector<int>>vv;
        int levesize=0;
        q.push(root);
        while(!q.empty())
        {
            levesize=q.size();
            vector<int>v;
            //限制每一层的个数
            for(int i=0;i<levesize;i++)
            {
                //拿到当前节点
                TreeNode*front=q.front();
                v.push_back(front->val);
                //将下一层节点入队列
                if(front->left)
                {
                    q.push(front->left);
                }
                if(front->right)
                {
                    q.push(front->right);
                }
                q.pop();
            }
            vv.push_back(v);
        }
        //返回结果
        return vv[vv.size()-1][0];
    }
};
```

#### [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode-cn.com/problems/hPov7L/)

> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

```cpp
示例1：
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 

示例2：
输入: root = [1,2,3]
输出: [1,3]
解释:
          1
         / \
        2   3

示例3：
输入: root = [1]
输出: [1]

示例4：
输入: root = [1,null,2]
输出: [1,2]
解释:      
           1 
            \
             2     

示例5：
输入: root = []
输出: []
```

> 思路：二叉树的层序遍历+求出每一层的最大值

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*>q;
        vector<int>v;
        if(root==nullptr)
        return v;
        q.push(root);
        while(!q.empty())
        {
            int lensize=q.size();
            int Max=q.front()->val;
            for(int i=0;i<lensize;i++)
            {
                TreeNode*front=q.front();
                if(front->val>Max)
                {
                    Max=front->val;
                }

                if(front->left)
                {
                    q.push(front->left);
                }
                if(front->right)
                {
                    q.push(front->right);
                }
                q.pop();

            }
            v.push_back(Max);
        }
        return v;

    }
};
```

#### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

![image-20211001212016577](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211001212016577.png)

```cpp
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

![image-20211001212057545](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211001212057545.png)

```cpp
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```

> 思路：和二叉树的层序遍历一样借助队列先进先出的特点带出下一层的元素

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>>ret;
        if(root==nullptr)
        return ret;
        queue<Node*>q;
        q.push(root);
        while(!q.empty())
        {
            vector<int>v;
            int ls=q.size();
            for(int i=0;i<ls;i++)
            {
                Node*front=q.front();
                q.pop();
                v.push_back(front->val);
                for(int i=0;i<front->children.size();i++)
                {
                    q.push(front->children[i]);
                }
            }
            ret.push_back(v);
        }
        return ret;
        
    }
};
```

#### [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

给定一个 N 叉树，返回其节点值的 **前序遍历** 。

N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

 ![image-20211002161811475](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211002161811475.png)



```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<Node*>s;
        s.push(root);
        while(!s.empty())
        {
            Node*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ret.push_back(front->val);
            for(int i=front->children.size()-1;i>=0;i--)
            {
                s.push(front->children[i]);
            }
        }
        return ret;
    }
};
```



#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

> 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
>
> 例如输入：

```cpp
		 4 
​	   /  \ 
​	  2    7
 	 / \  / \
    1  3  6  9
```

镜像输出：

```cpp
    4  
   /  \ 
   7   2 
  / \  / \
  9  6 3  1
```

**示例 1：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

> 本质就是二叉树的前序遍历

```cpp
class Solution {
public:
//二叉树的前序遍历
  TreeNode* mirrorTree(TreeNode* root) {
​    //递归遍历二叉树交换左右结点的值
​    if(root==NULL)
​    {
​      return NULL;
​    }

​    swap(root->left,root->right);
​    mirrorTree(root->left);
​    mirrorTree(root->right);
​    return root;
  }
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

![image-20210929084211258](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929084211258.png)

```cpp
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

![image-20210929084302811](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929084302811.png)

```cpp
输入：root = [1,2,3], targetSum = 5
输出：false
```

```cpp
示例 3：
输入：root = [1,2], targetSum = 0
输出：false
```

本题思路：从根结点往下进行判断，看是否有一条路径上所有节点之和等于targetSum,

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count=0;
    void trackbacking(TreeNode*root,int &sum)
    {
        if(root->left==nullptr&&root->right==nullptr&&sum==0)
        {
            count++;
        }
        if(root->left==nullptr&&root->right==nullptr)
        {
            return ;
        }
        if(root->left)
        {
            sum-=root->left->val;
            trackbacking(root->left,sum);
            sum+=root->left->val;
        }
        if(root->right)
        {
            sum-=root->right->val;
            trackbacking(root->right,sum);
            sum+=root->right->val;
        }

    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return false;
        int n=targetSum-(root->val);
        trackbacking(root,n);
        if(count==0)
        return false;
        return true;
    }
};
```



#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

![image-20210928213712979](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210928213712979.png)

```cpp
示例1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

![image-20210928213759015](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210928213759015.png)

```cpp
示例2：
输入：root = [1,2,3], targetSum = 5
输出：[]
```

```cpp
示例 3：
输入：root = [1,2], targetSum = 0
输出：[]
```

思路：本题问从根结点开始到结束的一条路径上所有节点之和等于targetSum的路径个数，那么要达到本题所要求的首先要满足两个条件：

1.从根节点到达叶子节点

2.这个路径上所有节点之和等于tatgetSum

那么我们很明显需要从根节点开始向下遍历，直到叶子节点结束，判断该路径上所有数目这个是否等于targetSum,

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>>ret;//记录最终结果
    vector<int>path;//记录当前路径
    
    void trackbacking(TreeNode*root,int &count)
    {
        //判断是否到达叶子节点和否该节点所有值之和等于targetSum
        if(root->left==nullptr&&root->right==nullptr&&count==0)
        {
            ret.push_back(path);
        }
        //如果单纯的是叶子节点而所有节点之和不等于targetSum，就返回
        if(root->left==nullptr&&root->right==nullptr)
        {
            return;
        }
        //递归进入左节点
        if(root->left)
        {
            //这里采取回溯法，不符合条件之后进行回溯
            count-=root->left->val;
            path.push_back(root->left->val);
            trackbacking(root->left,count);
            //回溯步骤
            count+=root->left->val;
            path.pop_back();
        }
        //递归进入右节点，继续采取回溯的策略
        if(root->right)
        {
            count-=root->right->val;
            path.push_back(root->right->val);
            trackbacking(root->right,count);
            //回溯
            path.pop_back();
            count+=root->right->val;
        }

    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return ret;
        path.push_back(root->val);
        int n=root->val;
        //细节：刚开始时减去root->val,传参时传入targetSum-root->val,为了不影响后面代码的可读性
        int  x=targetSum-n;
        trackbacking(root,x);
        return ret;
    }
};
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

![image-20210929090430994](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929090430994.png)

```cpp
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

```cpp
示例 2：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

> 本题思路：上面两道路径总和的题目都是从根结点开始向下遍历，而这道题目是从任意一个节点开始向下遍历，那么这道题目的思路就和上面两道题目几乎一样，唯一的不同区别就是这道题目得从每一个节点出发向下遍历，那么如何从每一个节点开始向下遍历呢，这里我们采取双重递归的思路，在主函数中再加一层递归，让其从每一个节点开始往下访问

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count=0;
   // int sum=0;
    void trackbacking(TreeNode*root,int &t)
    {
        
        if(root==nullptr)
        return ;
      
        t-=root->val;
        if(t==0)
        {
            count++;
        }
        trackbacking(root->left,t);
        trackbacking(root->right,t);
        t+=root->val;
    }


    int pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return 0;
      trackbacking(root,targetSum);
      pathSum(root->left,targetSum);
      pathSum(root->right,targetSum);
      return count;
    }
};
```

#### [剑指 Offer 07. 从前序遍历和后序遍历](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

> 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
>
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

![image-20210904214225686](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210904214225686.png)

```cpp
示例 1:

Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

示例 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

在一棵二叉树中，只要知道了前序遍历和中序遍历，或者中序遍历和后续遍历就能重建整科二叉树

<img src="https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210904213733441.png" alt="image-20210904213733441" style="zoom:100%;" />

代码：

```cpp
//根据前序和中序或者中序和后续就能重建二叉树

class Solution {
public:

  TreeNode*_bulidTree(vector<int>&preorder,int pre_start,int pre_end,vector<int>&inorder,int ind_start,int ind_end)
  {
      //递归终止的条件
​    if(pre_start>pre_end||ind_start>ind_end)
​    {
​      return nullptr;
​    }


	//创建根结点
​    TreeNode*root=new TreeNode(preorder[pre_start]);
      //在中序序列中找到根结点，将中序序列分成左右子树，前序序列往后数对应的左子树数量
​    for(int i=0;i<=ind_end;i++)
​    {
​      if(root->val==inorder[i])
​      {
​        root->left=_bulidTree(preorder,pre_start+1,pre_start+i-ind_start,inorder,ind_start,i-1);
​        root->right=_bulidTree(preorder,pre_start+i-ind_start+1,pre_end,inorder,i+1,ind_end);
​      }
​    }
​    return root;
  }

  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      //数据不正确，直接进行退出
​    if(preorder.empty()||inorder.empty()||preorder.size()!=inorder.size())
​    {
​      return nullptr;
​    }
​    return _bulidTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
  }
};
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> 根据一棵树的中序遍历与后序遍历构造二叉树。

```cpp
例如，给出:
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
    
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

> 思路：从后续遍历的最后一个节点为入手点，后续遍历的最后一个节点就是我们要构建的二叉树的根结点，然后我们在前序遍历中寻找这个根结点的值，找到后，在前序遍历中，以根结点为界限，将前序遍历分为两部分，root左边的所有数字就是左子树的节点(总数即为h)，root右边的所有节点就是右子树的所有节点(总数记为l)，然后对后续遍历这个数组进行划分，从最前边走h个就是所有左子树的内容了，然后h-1就是下一层的根结点的位置了，(h,h+l)就是右子树的所有节点，然后按照前面的步骤进行划分，直到划分成不可以进行分割的小块，最终形成一个完整的二叉树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode*_buildTree(vector<int>&inorder,vector<int>&postorder,int inor_start,int inor_end,int post_start,int post_end)
    {
        //只需要判断左边树的边界就可以了
        if(inor_start>inor_end)
        return nullptr;
        //创建根结点
        TreeNode*root=new TreeNode(postorder[post_end]);
        //在前序遍历中寻找根结点
        for(int i=inor_start;i<=inor_end;i++)
        {
            //在前序遍历中找到根结点的位置了
            if(inorder[i]==postorder[post_end])
            {
             //递归构建左子树   
                //这时候下标的范围发生变化
                root->left=_buildTree(inorder,postorder,inor_start,i-1,post_start,post_start+(i-inor_start-1));
             //递归构建右子树
                root->right=_buildTree(inorder,postorder,i+1,inor_end,post_start+(i-inor_start),post_end-1);

            }
        }
            return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //如果两个序列的长度不相等，直接返回nullptr
        if(inorder.size()!=postorder.size())
        return nullptr;
        //递归构建这棵树
        TreeNode*root=_buildTree(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
};
```

#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

> 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```cpp
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

> 思路：二叉搜索树的中序遍历可以使之变成一个有序数组，然后判断有序列表中相邻两个数的绝对值即可

```cpp
class Solution {
public:
    vector<int>ret;
    //二叉树中序遍历
    void dfs(TreeNode*root)
    {
        if(root==nullptr)
        return ;
        dfs(root->left);
        ret.push_back(root->val);
        dfs(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        //遍历数组
        if(ret.size()<2)
        return 0;
           int ans=ret[1]-ret[0];
        for(int i=0;i<ret.size()-1;i++)
        {
            int x=ret[i+1]-ret[i];
            if(x<ans)
            {
                ans=x;
            }
        }
        return ans;
    }
};
```



#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

> 计算给定二叉树的所有左叶子之和。
>

```cpp
示例：
    3

   / \
  9  20
    /  \
   15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

> 上来看到左叶子一般就想到二叉树的层序遍历，但是要看清楚是叶子节点，那么我们如何确定左叶子节点呢，方法如下：

```cpp
root->left!=nullptr&&root->left->left==nullptr&&root->left->right==nullptr
//符合上述条件说明就找到了最左边的叶子节点
```

> 那么这道题目也就变得比较简单了，直接二叉树的前序遍历即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum=0;
    void dfs(TreeNode*root)
    {
        if(root==nullptr)
        return;
        判断是否为左叶子节点
        if(root->left!=nullptr&&root->left->left==nullptr&&root->left->right==nullptr)
        {
            sum+=root->left->val;
            
        }
        if(root->left)
        dfs(root->left);
        if(root->right)
        dfs(root->right);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        dfs(root);
        return sum;
    }
};
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

![image-20211006211557647](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211006211557647.png)

```cpp
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

> 看到题目一看就是二叉树的深度优先遍历+回溯，但是这道题木比较蛋疼，要你拿字符串的形式返回，这里我们可以在形参列表中中path+"->",那么就不会该表path的值，等到放回的时候实现回溯的效果

```cpp
class Solution {
public:
//回溯法确定二叉树所有路径
    string path;
    vector<string>ret;
    void backtracking(TreeNode*root,string path)
    {
        if(root==nullptr)
        return;
        //添加节点
        path+=to_string(root->val);
        //符合条件了入数组
        if(root->left==nullptr&&root->right==nullptr)
        {
            ret.push_back(path);
            return;
        }
        //左子树不为空遍历左子树
        if(root->left)
        {
            backtracking(root->left,path+"->");
     
        }
        //右子树不为空遍历右子树
        if(root->right)
        {
            backtracking(root->right,path+"->");
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        backtracking(root,path);
        return ret;
    }
};
```



#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

![image-20211024210332054](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211024210332054.png)

```cpp
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

![image-20211024210409642](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211024210409642.png)

```cpp
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

```cpp
示例 3：
输入：root = [1,2], p = 1, q = 2
输出：1
```

> 这道题目可以分为以下3中情况进行讨论：
>

> 1.如果这个二叉树是一个带有父节点的三叉链(即每一个节点除了左右孩子之外还含有一个parent指针，指向父亲)，那么我们可以尝试倒着往回走，这时候这个问题就转化为求两个链表第一个相交节点的问题了
>
> 2.如果是一棵搜索二叉树，有两个节点，有最近公共祖先，那么这个最近公共祖先一定比其中一个节点的值大，比另外一个节点的值小
>
> 如果根节点比另外两个节点的值大，那么就前往左子树进行查找
>
> 如果根节点比另外两个节点的值小，那么就前往右子树进行查找
>
> 当根节点比其中一个值大，比另外一个值小时，停止搜索，返回根节点
>
> 3.如果是一棵普通的二叉树，那么有两个节点，它有两个子节点求最近公共祖先，它具有以下特征：
>
> 如果是最近公共祖先，那么它的一个节点就在左子树上，另外一个节点就在右子树上，那么我们只需要判断这两个节点的位置即可判断最近公共祖先，如果两个节点都是位于左子树，那么就前往左子树进行查找，如果两个节点都是位于右子树，那么就前往右子树进行查找，只有当两个节点位于左右两侧的时候返回根节点，那么就有下面这两种方法：
>

> 方法一：如果两个节点都是位于左子树，那么就前往左子树进行查找，如果两个节点都是位于右子树，那么就前往右子树进行查找，只有当两个节点位于左右两侧的时候返回根节点
>

```cpp
//这个题目有了思路之后代码还是有点难写，我们该如何判断这个节点位于左子树还是右子树呢，这里我们先默认让两个节点往左子树去找，定义pInleft,qInleft记录结果，那么如果两个节点都在左子树那么(pInleft&&qInleft)就为true,我们需要向左子树继续寻找，如果(!pInleft&&!qInleft)为true，代表两个节点都在右子树，向右子树寻找，那么剩下的情况就是两个节点在左右两个子树中，返回结果该节点
class Solution {
public:
	//搜索节点在不在这颗树里面
    bool Find(TreeNode*root,TreeNode*p)
    {
        //如果为空返回false
        if(root==nullptr)
        {
            return false;
        }
		//相等说明在这棵树里
        if(root==p)
        {
            return true;
        }
		//递归判断在不在左子树，如果在就不会去判断右子树了
        return Find(root->left,p)||Find(root->right,p);
    }
    
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //如果其中p,q中有一个和根结点一样就返回
        if(root==p||root==q)
        return root;
        //记录p,q在不在左子树
        bool pInleft,pInright;
        //记录p,q在不在右子树
        bool qInleft,qInright;
        pInleft=Find(root->left,p);
        pInright=!pInleft;
        qInleft=Find(root->left,q);
        qInright=!qInleft;
		//如果两者都在左子树就去左子树中去寻找
        if(pInleft&&qInleft)
        {
           return  lowestCommonAncestor(root->left,p,q);
        }
        
        //如果两种都在右子树，就去右子树进行查找
        else if(pInright&&qInright)
        {
            return lowestCommonAncestor(root->right,p,q);
        }
        //不是的话代表p,q一个在左，一个在右，返回节点的值
        else
        {
            return root;
        }   
    }
};

```

> 方法二：将到达p,q节点的路径记录下来，然后让长的先走差距部，然后两者一起走，直到相等，即转化为相交链表的第一个节点
>

```cpp
class Solution {
public:
    //方法二：记录到达该节点的路径，然后将问题转化为求链表相交节点的问题
    //FindPath:记录到达指定节点的路径
    bool FindPath(TreeNode*root,TreeNode*p,stack<TreeNode*>&path)
    {
        //为空返回false
        if(root==nullptr)
        {
            return false;
        }
        //入节点
        path.push(root);
        if(root==p)
        {
            return true;
        }
        //到这说明根节点不是我们要找的，我们先去左子树去找，如果没有找到就去右子树去找
        bool ret=false;
        if(root->left!=nullptr)
        {
            ret=FindPath(root->left,p,path);
        }
        if(ret==false&&root->right!=nullptr)
        {
            ret=FindPath(root->right,p,path);
        }
        if(ret==false)
        {
            path.pop();
            return false;
        }
        return true;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        stack<TreeNode*>p_path;
        stack<TreeNode*>q_path;
        FindPath(root,p,p_path);
        FindPath(root,q,q_path);
        if(p_path.size()<q_path.size())
        {
            swap(p_path,q_path);
        }
        while(p_path.size()>q_path.size())
        {
            p_path.pop();
        }

        while(p_path.top()!=q_path.top())
        {
            p_path.pop();
            q_path.pop();
        }
        return p_path.top();
        
    }
};
```

> 从上面这道题目我们可以得到从根节点到达指定节点路径的模板

> 给定一个根节点root,找到到达指定节点p的唯一路径

```cpp
//用栈或者数组收集路径都是可以的 
bool FindPath(TreeNode*root,TreeNode*p,stack<TreeNode*>&path)
    {
        //为空返回false
        if(root==nullptr)
        {
            return false;
        }
        //入节点
        path.push(root);
        if(root==p)
        {
            return true;
        }
        //到这说明根节点不是我们要找的，我们先去左子树去找，如果没有找到就去右子树去找
        bool ret=false;
        if(root->left!=nullptr)
        {
            ret=FindPath(root->left,p,path);
        }
        if(ret==false&&root->right!=nullptr)
        {
            ret=FindPath(root->right,p,path);
        }
    
    	//到这里说明左右子树都没有找到该节点返回false
        if(ret==false)
        {
            path.pop();
            return false;
        }
    	//到这说明在上面右子树找到了该节点
        return true;
    }
```

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![image-20211025110724460](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211025110724460.png)

```cpp
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

```cpp
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

> 这道题目就是前面那道题目的加强版，二叉搜索树，要牢牢把握二叉搜索树的性质，如果是最近公共祖先，那么它满足以下条件:
>
> 1.两个节点位于cur(最近公共祖先)的两侧
>
> 2.两个节点中一个比当前节点大，另外一个比当前节点小

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p||root==q)
        return root;
        TreeNode*cur=root;
        while(cur)
        {
            if(cur==p||cur==q)
            {
                break;
            }
            if(p->val<cur->val&&((p->val-cur->val)*(q->val-cur->val)>0))
            {
                cur=cur->left;
            }
            else if(p->val>cur->val&&((p->val-cur->val)*(q->val-cur->val)>0))
            {
                cur=cur->right;
            }
            else
            {
                break;
            }
        }
        return cur;
    }
};
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节

![image-20211028214234805](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211028214234805.png)

```cpp
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

思路：反向输出然后相加,就是节点之和了

```cpp
class Solution {
public:
    int pre;
    TreeNode* convertBST(TreeNode* root) {
        pre=0;
        TreeNode*cur=root;
        stack<TreeNode*>st;
        while(cur||!st.empty())
        {
            if(cur)
            {
                st.push(cur);
                cur=cur->right;
            }
            else
            {
                cur=st.top();
                st.pop();
                if(cur)
                {
                    cur->val+=pre;
                    pre=cur->val;
                    cur=cur->left;
                }
            }
        }
        return root;

    }
};
```

#### [ **二叉搜索树与双向链表**](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)

> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示
>
> ![image-20211031152843067](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211031152843067.png)

> 
> 数据范围：输入二叉树的节点数 0 \le n \le 10000≤*n*≤1000，二叉树中每个节点的值 0\le val \le 10000≤*v**a**l*≤1000
> 要求：空间复杂度O(1)*O*(1)（即在原树上操作），时间复杂度 O(n)*O*(*n*)
>
> 注意:
>
> 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
> 2.返回链表中的第一个节点的指针
> 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构
>
> 4.你不用输出双向链表，程序会根据你的返回值自动打印输出

```cpp
示例1
输入：
{10,6,14,4,8,12,16}
返回值：
From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
说明：
输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。 
    
示例2
输入：
{5,4,#,3,#,2,#,1}
返回值：
From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
说明：
                    5
                  /
                4
              /
            3
          /
        2
      /
    1
树的形状如上图   
```

思路：中序遍历＋前驱指针，我定义一个前驱指针，root->left=cur,如果cur!=nhullptr,cur->right=root,然后更新cur,cur=root,这样一趟遍历之后我们就可以得到双向链表了，然后找到最左边的节点就是头节点，

同样的道理，如果我们要反向输出这张链表，只需要向上面一样交换首尾节点的值或者按照反向遍历即可

```cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    //中序遍历
    TreeNode*cur=nullptr;
    void dfs(TreeNode*root)
    {
        if(root==nullptr)
        {
            return;
        }
        dfs(root->left);
        root->left=cur;
        if(cur)
        cur->right=root;
        cur=root;
        dfs(root->right);
    }
    TreeNode* Convert(TreeNode* pRootOfTree) {
        if(!pRootOfTree)
                return nullptr;
        dfs(pRootOfTree);
         //找到最左边的节点
        TreeNode*head=pRootOfTree;
        while(head->left)
        {
            head=head->left;
        }
        return head;
    }
};
```

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

![image-20220912214854869](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220912214854869.png)

```
示例 1：
输入: [1,6,3,2,5]
输出: false

示例 2：
输入: [1,3,2,6,5]
输出: true
```

```cpp
//根据二叉树后序遍历的性质：那么数组中最后一个元素就是二叉搜索树的跟节点，在根结点的左边的值都比根节点值小，在根节点右边的值都比根节点大，所以我们根据这个性质进行遍历
//每次取出最后一个元素作为二叉树的根root
//从左边找到第一个比root大的元素 postorder[i]，那么i前面的元素就会都比root小，而i后面的元素都比root大
//判断后半部分是否都比root大，如果为否返回false
//然后从i的位置断开，[start，i-1]位置作为新的子数组进行遍历，[i,end-1]作为另外一个子数组进行遍历
//当左半部分和右半部分都符合要求时，返回true;
class Solution {
public:
    bool _verifyPostorder(vector<int>& postorder,int start,int end) {
        if(start>=end)
        return true;
        int root=postorder[end];
        //寻找左子树节点
        int i=start;
        for(;i<end;i++)
        {
            if(postorder[i]>root)
            break;
        }
        int j=i;
        for(;j<end;j++)
        {
            if(postorder[j]<root)
            return false;
        }
        if(!_verifyPostorder(postorder,start,i-1))
        return false;
        if(!_verifyPostorder(postorder,i,end-1))
        return false;
        return true;
    }
     bool verifyPostorder(vector<int>& postorder)
     {
        if(postorder.size()<2)
        {
            return true;
        }
         return _verifyPostorder(postorder,0,postorder.size()-1);
     }
};
```

