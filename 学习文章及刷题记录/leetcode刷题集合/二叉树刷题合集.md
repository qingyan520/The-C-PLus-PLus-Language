# 二叉树刷题合集

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

![image-20210930100717549](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210930100717549.png)

```cpp
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
```

> 本题目是二叉树系列的入门题目，二叉树的遍历，可以用递归和迭代两中方式实现
>
> 递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
//递归进行前序遍历
    void _preorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return ;
        ret.push_back(root->val);
        _preorderTraversal(root->left,ret);
        _preorderTraversal(root->right,ret);
    }
    vector<int> preorderTraversal(TreeNode* root) {
          vector<int>ret;
          _preorderTraversal(root,ret);
          return ret;
    }
};
```

> 非递归版本：借助栈实现二叉树的前序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>ans;
        stack<TreeNode*>s;
        if(root==nullptr)
        return ans;
        s.push(root);
        while(!s.empty())
        {
            TreeNode*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ans.push_back(front->val);
            s.push(front->right);
            s.push(front->left);
        }
        return ans;
    }
};

```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

![image-20210930101453087](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210930101453087.png)

```cpp
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```cpp
示例 2：
输入：root = []
输出：[]
```

```cpp
示例 3：
输入：root = [1]
输出：[1]
```

递归版本：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //递归实现二叉树的中序遍历
class Solution {
public:
    void _inorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return;
        _inorderTraversal(root->left,ret);
        ret.push_back(root->val);
        _inorderTraversal(root->right,ret);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>ret;
        _inorderTraversal(root,ret);
        return ret;

    }
};
```

> 非递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        //二叉树的非递归实现，借助stack
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<TreeNode*>s;
        TreeNode*cur=root;
        while(cur!=nullptr||!s.empty())
        {
            if(cur!=nullptr)
            {
                s.push(cur);
                cur=cur->left;
            }
            else
            {
                cur=s.top();
                s.pop();
                ret.push_back(cur->val);
                cur=cur->right;
            }
        }
        return ret;

    }
};
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 *后序* 遍历。

```cpp
示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
```

> 1.迭代法：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void _postorderTraversal(TreeNode*root,vector<int>&ret)
    {
        if(root==nullptr)
        return ;
        _postorderTraversal(root->left,ret);
        _postorderTraversal(root->right,ret);
        ret.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>ret;
        _postorderTraversal(root,ret);
        return ret;
    }
};
```

> 非递归版本

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //后序遍历与前序遍历非常相似，后序遍历的访问顺序是左右中，
 //前序遍历在代码中的实现：中右左----->而借助栈使得左右出栈顺序发生变化:----->中左右
 //后续遍历代码中的方式与前序遍历相似：
 //代码中:中左右---------->借助栈之后:------------>中右左------反转数组----->左右中

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<TreeNode*>s;
        s.push(root);
        while(!s.empty())
        {
            TreeNode*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ret.push_back(front->val);
            if(front->left)
            s.push(front->left);
            if(front->right)
            s.push(front->right);
        }

        reverse(ret.begin(),ret.end());
        return ret;

    }
};
```



#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

> 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
>
> 例如：
>

```cpp
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

该题目比较简单，为二叉树基本类型的题目，二叉树一般都要用到递归来解决

首先我们能够想到，一个数如果root==nullptr,说明该数节点为0，如果root!=nullptr并且它的左右子树都为nullptr,说明该节点即为叶子节点，那么我们就能写出以下代码：

```cpp
class Solution {
public:
  int maxDepth(TreeNode* root) {
​    if(root==nullptr)
​    {
​      return 0;
​    }
​    if(root->left==nullptr&&root->right==nullptr)
​    {
​      return 1;
​    }
​    return max(maxDepth(root->left),maxDepth(root->right))+1;
  }
};
```





```cpp
//根据前序和中序或者中序和后续就能重建二叉树

class Solution {
public:

  TreeNode*_bulidTree(vector<int>&preorder,int pre_start,int pre_end,vector<int>&inorder,int ind_start,int ind_end)
  {
      //递归终止的条件
​    if(pre_start>pre_end||ind_start>ind_end)
​    {
​      return nullptr;
​    }


	//创建根结点
​    TreeNode*root=new TreeNode(preorder[pre_start]);
      //在中序序列中找到根结点，将中序序列分成左右子树，前序序列往后数对应的左子树数量
​    for(int i=0;i<=ind_end;i++)
​    {
​      if(root->val==inorder[i])
​      {
​        root->left=_bulidTree(preorder,pre_start+1,pre_start+i-ind_start,inorder,ind_start,i-1);
​        root->right=_bulidTree(preorder,pre_start+i-ind_start+1,pre_end,inorder,i+1,ind_end);
​      }
​    }
​    return root;
  }

  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      //数据不正确，直接进行退出
​    if(preorder.empty()||inorder.empty()||preorder.size()!=inorder.size())
​    {
​      return nullptr;
​    }
​    return _bulidTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
  }
};
```

#### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```cpp
例如：
给定二叉树 [3,9,20,null,null,15,7],
​    3 
​	/ \
  9  20
​    /  \
   15   7
   
返回其自底向上的层序遍历为：
[
  [15,7],
  [9,20],
  [3]
]
```

首先完成二叉树的层序遍历，然后将数组进行逆置，就完成了自低向下的二叉树的层序遍历，故此题的难点是完成二叉树的层序遍历

这里我们借助队列来实现，利用队列先进先出的特性完成每一次的遍历

![image-20210910163828156](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210910163828156.png)

```cpp
class Solution {
public:
//利用队列进行实现
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*>q;
        vector<vector<int>>vv;
        if(root!=nullptr)
        {
            q.push(root);
        }
        int levelsize=0;
        while(!q.empty())
        {
            vector<int>v;
            levelsize=q.size();
            for(int i=0;i<levelsize;i++)
            {
                TreeNode*front=q.front();
                q.pop();
                v.push_back(front->val);
                if(front->left!=nullptr)
                {
                    q.push(front->left);
                }
                if(front->right!=nullptr)
                {
                    q.push(front->right);
                }
            }
            vv.push_back(v);
        }
        reverse(vv.begin(),vv.end());
        return vv;
    }
};
```

#### [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode-cn.com/problems/LwUNpT/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

![image-20210929085859578](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929085859578.png)

```cpp
输入: root = [2,1,3]
输出: 1
```

![image-20210929085938083](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929085938083.png)

```cpp
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

> 思路：最简单的方法：借助上面二叉树层序遍历的方法，先将二叉树层序遍历，然后返回最一层第一个元素即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //二叉树的层序遍历，然后返回最后列数组的第一个元素就可以
 //二叉树的层序遍历要借助队列先进先出的特性，将二叉树的左右子节点都入到队列种去
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root==nullptr)
        {
            return -1;
        }
        //建立队列，存储每一个元素
        queue<TreeNode*>q;
        vector<vector<int>>vv;
        int levesize=0;
        q.push(root);
        while(!q.empty())
        {
            levesize=q.size();
            vector<int>v;
            //限制每一层的个数
            for(int i=0;i<levesize;i++)
            {
                //拿到当前节点
                TreeNode*front=q.front();
                v.push_back(front->val);
                //将下一层节点入队列
                if(front->left)
                {
                    q.push(front->left);
                }
                if(front->right)
                {
                    q.push(front->right);
                }
                q.pop();
            }
            vv.push_back(v);
        }
        //返回结果
        return vv[vv.size()-1][0];
    }
};
```

#### [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode-cn.com/problems/hPov7L/)

> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

```cpp
示例1：
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 

示例2：
输入: root = [1,2,3]
输出: [1,3]
解释:
          1
         / \
        2   3

示例3：
输入: root = [1]
输出: [1]

示例4：
输入: root = [1,null,2]
输出: [1,2]
解释:      
           1 
            \
             2     

示例5：
输入: root = []
输出: []
```

> 思路：二叉树的层序遍历+求出每一层的最大值

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*>q;
        vector<int>v;
        if(root==nullptr)
        return v;
        q.push(root);
        while(!q.empty())
        {
            int lensize=q.size();
            int Max=q.front()->val;
            for(int i=0;i<lensize;i++)
            {
                TreeNode*front=q.front();
                if(front->val>Max)
                {
                    Max=front->val;
                }

                if(front->left)
                {
                    q.push(front->left);
                }
                if(front->right)
                {
                    q.push(front->right);
                }
                q.pop();

            }
            v.push_back(Max);
        }
        return v;

    }
};
```

#### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

![image-20211001212016577](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211001212016577.png)

```cpp
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

![image-20211001212057545](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211001212057545.png)

```cpp
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```

> 思路：和二叉树的层序遍历一样借助队列先进先出的特点带出下一层的元素

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>>ret;
        if(root==nullptr)
        return ret;
        queue<Node*>q;
        q.push(root);
        while(!q.empty())
        {
            vector<int>v;
            int ls=q.size();
            for(int i=0;i<ls;i++)
            {
                Node*front=q.front();
                q.pop();
                v.push_back(front->val);
                for(int i=0;i<front->children.size();i++)
                {
                    q.push(front->children[i]);
                }
            }
            ret.push_back(v);
        }
        return ret;
        
    }
};
```

#### [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

给定一个 N 叉树，返回其节点值的 **前序遍历** 。

N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

 ![image-20211002161811475](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211002161811475.png)



```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int>ret;
        if(root==nullptr)
        return ret;
        stack<Node*>s;
        s.push(root);
        while(!s.empty())
        {
            Node*front=s.top();
            s.pop();
            if(front==nullptr)
            continue;
            ret.push_back(front->val);
            for(int i=front->children.size()-1;i>=0;i--)
            {
                s.push(front->children[i]);
            }
        }
        return ret;
    }
};
```



#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

> 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
>
> 例如输入：

```cpp
		 4 
​	   /  \ 
​	  2    7
 	 / \  / \
    1  3  6  9
```

镜像输出：

```cpp
    4  
   /  \ 
   7   2 
  / \  / \
  9  6 3  1
```

**示例 1：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

> 本质就是二叉树的前序遍历

```cpp
class Solution {
public:
//二叉树的前序遍历
  TreeNode* mirrorTree(TreeNode* root) {
​    //递归遍历二叉树交换左右结点的值
​    if(root==NULL)
​    {
​      return NULL;
​    }

​    swap(root->left,root->right);
​    mirrorTree(root->left);
​    mirrorTree(root->right);
​    return root;
  }
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

![image-20210929084211258](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929084211258.png)

```cpp
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

![image-20210929084302811](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929084302811.png)

```cpp
输入：root = [1,2,3], targetSum = 5
输出：false
```

```cpp
示例 3：
输入：root = [1,2], targetSum = 0
输出：false
```

本题思路：从根结点往下进行判断，看是否有一条路径上所有节点之和等于targetSum,

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count=0;
    void trackbacking(TreeNode*root,int &sum)
    {
        if(root->left==nullptr&&root->right==nullptr&&sum==0)
        {
            count++;
        }
        if(root->left==nullptr&&root->right==nullptr)
        {
            return ;
        }
        if(root->left)
        {
            sum-=root->left->val;
            trackbacking(root->left,sum);
            sum+=root->left->val;
        }
        if(root->right)
        {
            sum-=root->right->val;
            trackbacking(root->right,sum);
            sum+=root->right->val;
        }

    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return false;
        int n=targetSum-(root->val);
        trackbacking(root,n);
        if(count==0)
        return false;
        return true;
    }
};
```



#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

![image-20210928213712979](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210928213712979.png)

```cpp
示例1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

![image-20210928213759015](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210928213759015.png)

```cpp
示例2：
输入：root = [1,2,3], targetSum = 5
输出：[]
```

```cpp
示例 3：
输入：root = [1,2], targetSum = 0
输出：[]
```

思路：本题问从根结点开始到结束的一条路径上所有节点之和等于targetSum的路径个数，那么要达到本题所要求的首先要满足两个条件：

1.从根节点到达叶子节点

2.这个路径上所有节点之和等于tatgetSum

那么我们很明显需要从根节点开始向下遍历，直到叶子节点结束，判断该路径上所有数目这个是否等于targetSum,

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>>ret;//记录最终结果
    vector<int>path;//记录当前路径
    
    void trackbacking(TreeNode*root,int &count)
    {
        //判断是否到达叶子节点和否该节点所有值之和等于targetSum
        if(root->left==nullptr&&root->right==nullptr&&count==0)
        {
            ret.push_back(path);
        }
        //如果单纯的是叶子节点而所有节点之和不等于targetSum，就返回
        if(root->left==nullptr&&root->right==nullptr)
        {
            return;
        }
        //递归进入左节点
        if(root->left)
        {
            //这里采取回溯法，不符合条件之后进行回溯
            count-=root->left->val;
            path.push_back(root->left->val);
            trackbacking(root->left,count);
            //回溯步骤
            count+=root->left->val;
            path.pop_back();
        }
        //递归进入右节点，继续采取回溯的策略
        if(root->right)
        {
            count-=root->right->val;
            path.push_back(root->right->val);
            trackbacking(root->right,count);
            //回溯
            path.pop_back();
            count+=root->right->val;
        }

    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return ret;
        path.push_back(root->val);
        int n=root->val;
        //细节：刚开始时减去root->val,传参时传入targetSum-root->val,为了不影响后面代码的可读性
        int  x=targetSum-n;
        trackbacking(root,x);
        return ret;
    }
};
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

![image-20210929090430994](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210929090430994.png)

```cpp
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

```cpp
示例 2：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

> 本题思路：上面两道路径总和的题目都是从根结点开始向下遍历，而这道题目是从任意一个节点开始向下遍历，那么这道题目的思路就和上面两道题目几乎一样，唯一的不同区别就是这道题目得从每一个节点出发向下遍历，那么如何从每一个节点开始向下遍历呢，这里我们采取双重递归的思路，在主函数中再加一层递归，让其从每一个节点开始往下访问

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count=0;
   // int sum=0;
    void trackbacking(TreeNode*root,int &t)
    {
        
        if(root==nullptr)
        return ;
      
        t-=root->val;
        if(t==0)
        {
            count++;
        }
        trackbacking(root->left,t);
        trackbacking(root->right,t);
        t+=root->val;
    }


    int pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)
        return 0;
      trackbacking(root,targetSum);
      pathSum(root->left,targetSum);
      pathSum(root->right,targetSum);
      return count;
    }
};
```

#### [剑指 Offer 07. 从前序遍历和后序遍历](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

> 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
>
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

![image-20210904214225686](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210904214225686.png)

```cpp
示例 1:

Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

示例 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

在一棵二叉树中，只要知道了前序遍历和中序遍历，或者中序遍历和后续遍历就能重建整科二叉树

<img src="https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20210904213733441.png" alt="image-20210904213733441" style="zoom:100%;" />

代码：

```cpp
//根据前序和中序或者中序和后续就能重建二叉树

class Solution {
public:

  TreeNode*_bulidTree(vector<int>&preorder,int pre_start,int pre_end,vector<int>&inorder,int ind_start,int ind_end)
  {
      //递归终止的条件
​    if(pre_start>pre_end||ind_start>ind_end)
​    {
​      return nullptr;
​    }


	//创建根结点
​    TreeNode*root=new TreeNode(preorder[pre_start]);
      //在中序序列中找到根结点，将中序序列分成左右子树，前序序列往后数对应的左子树数量
​    for(int i=0;i<=ind_end;i++)
​    {
​      if(root->val==inorder[i])
​      {
​        root->left=_bulidTree(preorder,pre_start+1,pre_start+i-ind_start,inorder,ind_start,i-1);
​        root->right=_bulidTree(preorder,pre_start+i-ind_start+1,pre_end,inorder,i+1,ind_end);
​      }
​    }
​    return root;
  }

  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      //数据不正确，直接进行退出
​    if(preorder.empty()||inorder.empty()||preorder.size()!=inorder.size())
​    {
​      return nullptr;
​    }
​    return _bulidTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
  }
};
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> 根据一棵树的中序遍历与后序遍历构造二叉树。

```cpp
例如，给出:
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
    
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

> 思路：从后续遍历的最后一个节点为入手点，后续遍历的最后一个节点就是我们要构建的二叉树的根结点，然后我们在前序遍历中寻找这个根结点的值，找到后，在前序遍历中，以根结点为界限，将前序遍历分为两部分，root左边的所有数字就是左子树的节点(总数即为h)，root右边的所有节点就是右子树的所有节点(总数记为l)，然后对后续遍历这个数组进行划分，从最前边走h个就是所有左子树的内容了，然后h-1就是下一层的根结点的位置了，(h,h+l)就是右子树的所有节点，然后按照前面的步骤进行划分，直到划分成不可以进行分割的小块，最终形成一个完整的二叉树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode*_buildTree(vector<int>&inorder,vector<int>&postorder,int inor_start,int inor_end,int post_start,int post_end)
    {
        //只需要判断左边树的边界就可以了
        if(inor_start>inor_end)
        return nullptr;
        //创建根结点
        TreeNode*root=new TreeNode(postorder[post_end]);
        //在前序遍历中寻找根结点
        for(int i=inor_start;i<=inor_end;i++)
        {
            //在前序遍历中找到根结点的位置了
            if(inorder[i]==postorder[post_end])
            {
             //递归构建左子树   
                //这时候下标的范围发生变化
                root->left=_buildTree(inorder,postorder,inor_start,i-1,post_start,post_start+(i-inor_start-1));
             //递归构建右子树
                root->right=_buildTree(inorder,postorder,i+1,inor_end,post_start+(i-inor_start),post_end-1);

            }
        }
            return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //如果两个序列的长度不相等，直接返回nullptr
        if(inorder.size()!=postorder.size())
        return nullptr;
        //递归构建这棵树
        TreeNode*root=_buildTree(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
};
```

#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

> 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```cpp
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

> 思路：二叉搜索树的中序遍历可以使之变成一个有序数组，然后判断有序列表中相邻两个数的绝对值即可

```cpp
class Solution {
public:
    vector<int>ret;
    //二叉树中序遍历
    void dfs(TreeNode*root)
    {
        if(root==nullptr)
        return ;
        dfs(root->left);
        ret.push_back(root->val);
        dfs(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        //遍历数组
        if(ret.size()<2)
        return 0;
           int ans=ret[1]-ret[0];
        for(int i=0;i<ret.size()-1;i++)
        {
            int x=ret[i+1]-ret[i];
            if(x<ans)
            {
                ans=x;
            }
        }
        return ans;
    }
};
```



#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

> 计算给定二叉树的所有左叶子之和。
>

```cpp
示例：
    3

   / \
  9  20
    /  \
   15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

> 上来看到左叶子一般就想到二叉树的层序遍历，但是要看清楚是叶子节点，那么我们如何确定左叶子节点呢，方法如下：

```cpp
root->left!=nullptr&&root->left->left==nullptr&&root->left->right==nullptr
//符合上述条件说明就找到了最左边的叶子节点
```

> 那么这道题目也就变得比较简单了，直接二叉树的前序遍历即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum=0;
    void dfs(TreeNode*root)
    {
        if(root==nullptr)
        return;
        判断是否为左叶子节点
        if(root->left!=nullptr&&root->left->left==nullptr&&root->left->right==nullptr)
        {
            sum+=root->left->val;
            
        }
        if(root->left)
        dfs(root->left);
        if(root->right)
        dfs(root->right);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        dfs(root);
        return sum;
    }
};
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

![image-20211006211557647](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211006211557647.png)

```cpp
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

> 看到题目一看就是二叉树的深度优先遍历+回溯，但是这道题木比较蛋疼，要你拿字符串的形式返回，这里我们可以在形参列表中中path+"->",那么就不会该表path的值，等到放回的时候实现回溯的效果

```cpp
class Solution {
public:
//回溯法确定二叉树所有路径
    string path;
    vector<string>ret;
    void backtracking(TreeNode*root,string path)
    {
        if(root==nullptr)
        return;
        //添加节点
        path+=to_string(root->val);
        //符合条件了入数组
        if(root->left==nullptr&&root->right==nullptr)
        {
            ret.push_back(path);
            return;
        }
        //左子树不为空遍历左子树
        if(root->left)
        {
            backtracking(root->left,path+"->");
     
        }
        //右子树不为空遍历右子树
        if(root->right)
        {
            backtracking(root->right,path+"->");
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        backtracking(root,path);
        return ret;
    }
};
```

