搜索算法

枚举法：暴力搜索

深度优先搜索

广度优先搜索

回溯

深度优先遍历(Depth First Search)---------一条道走到黑

  

例子：假设有编号1~3的3张扑克牌和编号为1~3的3个盒子，现在需要将三张牌放到3个盒子中去，且每个盒子只能放一张牌，一共有多少种不同的方法

每一个盒子的处理逻辑：

```cpp
void DFS(vector<int>&box,vector<int>&used,int idx,vector<int>&solution)
{
    //处理当前盒子
    for(int i=1;i<=box.size();++i)
    {
        //判断当前牌是否用过
        if(used[i]==0)
        {
            //当前没有使用的拍放入盒子
            box[idx]=i;
            solution.push_back(i);
            used[i]=1;
            DFS(box,used,idx+1,solution);
            used[i]=0;
        }
    }
}
```

1.处理边界：出口判断

2.处理当前每一步可能

3.处理下一步

690.员工的重要性：

### 迷宫问题

迷宫有n行m列的单元格组成(n,m都小于等于50)，每个单元格要么是空地，要么是障碍物，现请你找到一条从起点到终点的最短路径长度

![image-20211127210556478](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210556478.png)

![image-20211127210632571](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210632571.png)

#### DFS解决迷宫问题

```cpp
//DST解决迷宫问题
/*
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
0 0 3 2

*/
#include<iostream>
#include<vector>
using namespace std;
int startx, starty;//开始位置
int endx, endy;//结束位置
int v[100][100]{ 0 };//v[i][j]代表该位置有没有被访问，1代表已经被访问呢，0代表没有被访问方便回溯
int min_step = INT_MAX;//最终结果
vector<vector<int>>map;//地图，1代表没有障碍物，2代表右障碍物
//DFS进行深度优先遍历，按照右下左上顺时针顺序进行遍历，找到一条最符合题目要求的路径
void DFS(int x,int y,int step)
{
    //走到了终点就进行返回
	if (x == endx && y == endy)
	{
		if (step < min_step)
		{
			min_step = step;
		}
		return;
	}
    //当该位置符合要求并且没有障碍物没有被访问时我们就访问该位置
	//右
	if (y + 1 < map[0].size() && v[x][y + 1] == 0 && map[x][y + 1] == 1)
	{
		v[x][y + 1] = 1;
		DFS(x, y + 1, step + 1);
		v[x][y + 1] = 0;
	}

	//下
	if (x + 1 < map.size() && v[x + 1][y] == 0 && map[x + 1][y] == 1)
	{
		v[x + 1][y] = 1;
		DFS(x + 1, y, step + 1);
		v[x + 1][y] = 0;
	}

	//左
	if (y - 1 >= 0 && v[x][y - 1] == 0 && map[x][y - 1] == 1)
	{
		v[x][y - 1] = 1;
		DFS(x, y - 1, step + 1);
		v[x][y - 1] = 0;
	}
	//上
	if (x - 1 >= 0 && v[x - 1][y] == 0 && map[x-1][y] == 1)
	{
		v[x - 1][y] = 1;
		DFS(x - 1, y, step + 1);
		v[x - 1][y] = 0;
	}
}
int main()
{
	int m, n;
	cin >> m >> n;
	map.resize(m);
	for (int i = 0; i < m; i++)
	{
		map[i].resize(m, 0);
	}

	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			cin >> map[i][j];
		}
	}
	cin >> startx >> starty >> endx >> endy;
	DFS(startx, starty, 0);
	cout << min_step << endl;
} printf("%d",min_step);}
```

结果展示：

![image-20211128112658401](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128112658401.png)

上述代码中DFS过程存在大量的代码冗余，我们可以进行优化，提高效率:

```cpp

int dir[4][2]{ {0,1},{1,0},{0,-1},{-1,0} };
void DFS(int x,int y,int step)
{
	if (x == endx && y == endy)
	{
		if (step < min_step)
		{
			min_step = step;
		}
		return;
	}

	for (int i = 0; i < 4; i++)
	{
		int _x =x+ dir[i][0];
		int _y =y+ dir[i][1];
		if (_x >= 0 && _x < map.size() && _y >= 0 && _y <map[0].size() && map[_x][_y] == 1 && v[_x][_y] == 0)
		{
			v[_x][_y] = 1;
			DFS(x + dir[i][0], y + dir[i][1], step+1);
			v[_x][_y] = 1;
		}
	}


}
```

![image-20211128113724155](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128113724155.png)



#### BST解决迷宫问题

```cpp
/*
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
0 0 3 2

*/
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int startx,  starty;
int endx, endy;
struct pos
{
    int x;
    int y;
    int step;
};
int dir[4][2]{ {0,1},{1,0},{0,-1},{-1,0} };
int v[100][100]{ 0 };
int BST(vector<vector<int>>map)
{
    queue<pos>q;
    pos start{ startx,starty,0 };
    q.push(start);
    v[startx][starty] = 1;
    while (!q.empty())
    {
        pos front = q.front();
        q.pop();
        pos next;
        for (int i = 0; i < 4; i++)
        {
            next.x = front.x + dir[i][0];
            next.y = front.y + dir[i][1];
            next.step = front.step + 1;
            if (next.x == endx && next.y == endy)
            {
                return next.step;
            }
            if (next.x >= 0 && next.x < map.size() && next.y >= 0 && next.y < map[0].size() && map[next.x][next.y] == 1 && v[next.x][next.y] == 0)
            {
                q.push(next);
                v[next.x][next.y] = 1;
            }
        }
    }
    return 0;
}
int main()
{
    int m, n;
    cin >> m >> n;
    vector<vector<int>>map(m, vector<int>(n, 0));
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
        {
            cin >> map[i][j];
        }
    cin >> startx >> starty >> endx >> endy;
    cout << BST(map) << endl;

}
```

测试结果：

![image-20211128103836244](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128103836244.png)

#### 项目地址

[The-C-PLus-PLus-Language/2.C++初阶/test_11_28_BST和DST解决迷宫问题 at master · qingyan520/The-C-PLus-PLus-Language (github.com)](https://github.com/qingyan520/The-C-PLus-PLus-Language/tree/master/2.C%2B%2B初阶/test_11_28_BST和DST解决迷宫问题)
