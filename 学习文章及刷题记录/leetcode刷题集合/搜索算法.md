搜索算法

枚举法：暴力搜索

深度优先搜索

广度优先搜索

回溯

深度优先遍历(Depth First Search)---------一条道走到黑

  

例子：假设有编号1~3的3张扑克牌和编号为1~3的3个盒子，现在需要将三张牌放到3个盒子中去，且每个盒子只能放一张牌，一共有多少种不同的方法

每一个盒子的处理逻辑：

```cpp
void DFS(vector<int>&box,vector<int>&used,int idx,vector<int>&solution)
{
    //处理当前盒子
    for(int i=1;i<=box.size();++i)
    {
        //判断当前牌是否用过
        if(used[i]==0)
        {
            //当前没有使用的拍放入盒子
            box[idx]=i;
            solution.push_back(i);
            used[i]=1;
            DFS(box,used,idx+1,solution);
            used[i]=0;
        }
    }
}
```

1.处理边界：出口判断

2.处理当前每一步可能

3.处理下一步

690.员工的重要性：

#### 迷宫问题

迷宫有n行m列的单元格组成(n,m都小于等于50)，每个单元格要么是空地，要么是障碍物，现请你找到一条从起点到终点的最短路径长度

![image-20211127210556478](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210556478.png)

![image-20211127210632571](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210632571.png)

##### DFS解决迷宫问题

```cpp
//DST解决迷宫问题
/*
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
0 0 3 2

*/
#include<iostream>
#include<vector>
using namespace std;
int startx, starty;//开始位置
int endx, endy;//结束位置
int v[100][100]{ 0 };//v[i][j]代表该位置有没有被访问，1代表已经被访问呢，0代表没有被访问方便回溯
int min_step = INT_MAX;//最终结果
vector<vector<int>>map;//地图，1代表没有障碍物，2代表右障碍物
//DFS进行深度优先遍历，按照右下左上顺时针顺序进行遍历，找到一条最符合题目要求的路径
void DFS(int x,int y,int step)
{
    //走到了终点就进行返回
	if (x == endx && y == endy)
	{
		if (step < min_step)
		{
			min_step = step;
		}
		return;
	}
    //当该位置符合要求并且没有障碍物没有被访问时我们就访问该位置
	//右
	if (y + 1 < map[0].size() && v[x][y + 1] == 0 && map[x][y + 1] == 1)
	{
		v[x][y + 1] = 1;
		DFS(x, y + 1, step + 1);
		v[x][y + 1] = 0;
	}

	//下
	if (x + 1 < map.size() && v[x + 1][y] == 0 && map[x + 1][y] == 1)
	{
		v[x + 1][y] = 1;
		DFS(x + 1, y, step + 1);
		v[x + 1][y] = 0;
	}

	//左
	if (y - 1 >= 0 && v[x][y - 1] == 0 && map[x][y - 1] == 1)
	{
		v[x][y - 1] = 1;
		DFS(x, y - 1, step + 1);
		v[x][y - 1] = 0;
	}
	//上
	if (x - 1 >= 0 && v[x - 1][y] == 0 && map[x-1][y] == 1)
	{
		v[x - 1][y] = 1;
		DFS(x - 1, y, step + 1);
		v[x - 1][y] = 0;
	}
}
int main()
{
	int m, n;
	cin >> m >> n;
	map.resize(m);
	for (int i = 0; i < m; i++)
	{
		map[i].resize(m, 0);
	}

	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			cin >> map[i][j];
		}
	}
	cin >> startx >> starty >> endx >> endy;
	DFS(startx, starty, 0);
	cout << min_step << endl;
} printf("%d",min_step);}
```

结果展示：

![image-20211128112658401](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128112658401.png)

上述代码中DFS过程存在大量的代码冗余，我们可以进行优化，提高效率:

```cpp

int dir[4][2]{ {0,1},{1,0},{0,-1},{-1,0} };
void DFS(int x,int y,int step)
{
	if (x == endx && y == endy)
	{
		if (step < min_step)
		{
			min_step = step;
		}
		return;
	}

	for (int i = 0; i < 4; i++)
	{
		int _x =x+ dir[i][0];
		int _y =y+ dir[i][1];
		if (_x >= 0 && _x < map.size() && _y >= 0 && _y <map[0].size() && map[_x][_y] == 1 && v[_x][_y] == 0)
		{
			v[_x][_y] = 1;
			DFS(x + dir[i][0], y + dir[i][1], step+1);
			v[_x][_y] = 1;
		}
	}


}
```

![image-20211128113724155](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128113724155.png)



##### BST解决迷宫问题

```cpp
/*
5 4
1 1 2 1
1 1 1 1
1 1 2 1
1 2 1 1
1 1 1 2
0 0 3 2

*/
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int startx,  starty;
int endx, endy;
struct pos
{
    int x;
    int y;
    int step;
};
int dir[4][2]{ {0,1},{1,0},{0,-1},{-1,0} };
int v[100][100]{ 0 };
int BST(vector<vector<int>>map)
{
    queue<pos>q;
    pos start{ startx,starty,0 };
    q.push(start);
    v[startx][starty] = 1;
    while (!q.empty())
    {
        pos front = q.front();
        q.pop();
        pos next;
        for (int i = 0; i < 4; i++)
        {
            next.x = front.x + dir[i][0];
            next.y = front.y + dir[i][1];
            next.step = front.step + 1;
            if (next.x == endx && next.y == endy)
            {
                return next.step;
            }
            if (next.x >= 0 && next.x < map.size() && next.y >= 0 && next.y < map[0].size() && map[next.x][next.y] == 1 && v[next.x][next.y] == 0)
            {
                q.push(next);
                v[next.x][next.y] = 1;
            }
        }
    }
    return 0;
}
int main()
{
    int m, n;
    cin >> m >> n;
    vector<vector<int>>map(m, vector<int>(n, 0));
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
        {
            cin >> map[i][j];
        }
    cin >> startx >> starty >> endx >> endy;
    cout << BST(map) << endl;

}
```

测试结果：

![image-20211128103836244](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211128103836244.png)

##### 项目地址

[The-C-PLus-PLus-Language/2.C++初阶/test_11_28_BST和DST解决迷宫问题 at master · qingyan520/The-C-PLus-PLus-Language (github.com)](https://github.com/qingyan520/The-C-PLus-PLus-Language/tree/master/2.C%2B%2B初阶/test_11_28_BST和DST解决迷宫问题)

#### [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

> 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
>
> 两个网格块属于同一 连通分量 需满足下述全部条件：
>
> 两个网格块颜色相同
> 在上、下、左、右任意一个方向上相邻
> 连通分量的边界 是指连通分量中满足下述条件之一的所有网格块：
>
> 在上、下、左、右四个方向上与不属于同一连通分量的网格块相邻
> 在网格的边界上（第一行/列或最后一行/列）
> 请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。

```cpp
示例 1:
输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
示例 2：

输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
示例 3：

输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]
```

BFS广度优先遍历：右下左上顺时针方向进行试探，看看那个是符合要求的

```cpp
class Solution {
public:
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {  
        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
        queue<pair<int,int>>q;
        int indexColor=grid[row][col];
        vector<vector<bool>> vist(grid.size(),vector<bool>(grid[0].size(),false));
        vector<pair<int,int>>board;
        q.push(make_pair(row,col));
        vist[row][col]=true;
        while(!q.empty())
        {
            pair<int,int>front=q.front();
            q.pop();
            bool falg=false;
            for(int i=0;i<4;i++)
            {
                int nextx=front.first+dir[i][0];
                int nexty=front.second+dir[i][1];
                if(!(nextx>=0&&nextx<grid.size()&&nexty>=0&&nexty<grid[0].size()&&grid[nextx][nexty]==indexColor))
                {
                    //board.push_back(make_pair(nextx,nexty));
                   // count++;
                   falg=true;
                }
                else if(vist[nextx][nexty]==false)
                {
                   // board.push_back(make_pair(nextx,nexty));
                    vist[nextx][nexty]=true;
                    q.push(make_pair(nextx,nexty));
                }
            }
            if(falg)
            {
                board.push_back(make_pair(front.first,front.second));
                // vist[front.first][front.second]=true;
            }
        } 
        for(auto e:board)
        {
            grid[e.first][e.second]=color;
        }

        return grid;
        
    }
};
```

#### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>

```cpp
示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

代码：

```cpp
class Solution {
public:
    int dir[4][2]={{0,1},{-1,0},{0,-1},{1,0}};
    void dfs(int x,int y,vector<vector<char>>&grid)
    {
        if(x<0||x>=grid.size()||y<0||y>=grid[0].size()||grid[x][y]!='1')
        return;
        grid[x][y]='0';
        for(int i=0;i<4;i++)
        {
            int _x=x+dir[i][0];
            int _y=dir[i][1]+y;
            dfs(_x,_y,grid);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int ret=0;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]=='1')
                {
                    dfs(i,j,grid);
                    ret++;
                }
            }
        }
        return ret;
    }
};
```

#### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

> 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
>
> 返回执行此操作后，grid 中最大的岛屿面积是多少？
>
> 岛屿 由一组上、下、左、右四个方向相连的 1 形成。

```
示例 1:
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。

示例 2:
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。

示例 3:
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
```

思路：

根据题意，我们可以知道整个“矩阵地图”中，是由岛屿（格子值为：1）和海洋（格子值为：0）组成的。那么，题目要求计算“经过某些操作”之后的岛屿面积，而岛屿是不同的，所以我们可以在遍历整个矩阵的过程中，对不同的岛屿进行编号。由于0和1已经被使用了，那么岛屿的编号我们就从2开始，当遍历到新的岛屿时，岛屿编号加1。如下图所示，我们遍历出来了编号为2~8的岛屿。并且，在遍历过程中，将每个岛屿的面积也统计出来，并保存到Map中（key=岛屿编号；value=岛屿面积）。如下图所示：

![image-20220919182705040](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220919182705040.png)

那么，下一步就需要根据题意的要求——即：“最多只能将一格0变为1”。那么我们遍历矩阵中的所有格子，只有当格子是海洋（格子值为：0）时，我们来判断其上、下、左、右格子的值，再来结合Map中存储的岛屿编号与面积的对应关系，进行岛屿面积计算即可。以下图为例，在我们遍历的这个格子周围：上格子值为：2，下格子值为：6，左格子为：0，右格子为：0，所以我们可以知道这块海洋格子与岛屿2和岛屿6是相邻的，那么总的面积就是：岛屿2面积（10）+ 岛屿6面积（4）+ 海洋格子翻转面积（1）= 15。通过这种方式，将遍历所有格子后，最大的岛屿面积作为方法返回值即可。

![image-20220919182600672](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220919182600672.png)

这里再补充说一下，对于每个格子遍历的时候，我们采用深度优先遍历方式，即：先后深度的去遍历该格子的上方向、下方向、左方向和右方向。

![](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220919182600672.png)

为了防止遍历不同格子时，出现重复遍历，我们采取遍历到“岛屿”后，将格子值赋值为岛屿编号的方式。那么，终止深度遍历的条件如下所示：

条件一：遍历格子下标已经越界，即：不满足 row >=0 && row < grid.length && column >= 0 && column < grid.length
条件二：遍历的格子不为1。即：不遍历海洋格子和已遍历编号过的岛屿。

```cpp
class Solution {
public:

    int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};  //方向数组
    
    //dfs寻找每个岛屿的面积，并且为其进行编号
    int  dfs(vector<vector<int>>&grid,int x,int y,int index)
    {
        if(!(x>=0&&x<grid.size()&&y>=0&&y<grid[0].size()&&grid[x][y]==1))
        {
               return 0;
        }
         grid[x][y]=index;
        return dfs(grid,x,y+1,index)+dfs(grid,x+1,y,index)+dfs(grid,x,y-1,index)+dfs(grid,x-1,y,index)+1;

    }
    
    int largestIsland(vector<vector<int>>& grid) {
        int index=2;
        unordered_map<int,int>m;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[i].size();j++)
            {
                if(grid[i][j]==1)
                {
                    int ret=dfs(grid,i,j,index);
                    cout<<"ret="<<ret<<endl;
                    m[index++]=ret;
                }
            }
        }
		
        //寻找单个岛屿的最大面积
        int count=0;
        for(auto &e:m)
        {
            if(e.second>count)
            {
                count=e.second;
            }
        }
        
        //判断为0的海洋地区与其相连的四个方向上是否有相连的岛屿群，注意相连的岛屿是否重复出现过
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[i].size();j++)
            {
                int temp=1;
                if(grid[i][j]==0)
                {
                    set<int>s;
                    for(int k=0;k<4;k++)
                    {
                        int x=i+dir[k][0];
                        int y=j+dir[k][1];
                        if(x>=0&&x<grid.size()&&y>=0&&y<grid[0].size()&&grid[x][y]!=0&&(s.find(grid[x][y])==s.end()))
                        {
                            auto it=m.find(grid[x][y]);
                            //cout<<"gird[x][y]="<<grid[x][y]<<endl;
                            s.insert(grid[x][y]);
                            if(it!=m.end())
                            {
                                temp+=it->second;
                            }
                        }
                    }
                }
                if(temp>count)
                {
                    count=temp;
                }
            }
        }
        return count;
    

    }
};
```

#### [剑指 Offer II 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/)

> 给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。
>
> 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
>

![image-20220919183523869](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220919183523869.png)

```
输入: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出: 6
解释: 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
```

思路：

改题目与上面题目内容相似，为典型的dfs题目，从为1的元素上下左右开始遍历，将这个元素1周围的1全部变为0，记录其中1个个数，重复上述步骤，直到选出最大岛屿

```cpp
class Solution {
public:
    int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    
    //dfs记录岛屿数量
    int dfs(vector<vector<int>>&grid,int x,int y)
    {
        if(!(x>=0&&x<grid.size()&&y>=0&&y<grid[x].size()&&grid[x][y]==1))
        {
            return 0;
        }
        grid[x][y]=0;
        return dfs(grid,x,y+1)+dfs(grid,x+1,y)+dfs(grid,x,y-1)+dfs(grid,x-1,y)+1;
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ret=0;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[i].size();j++)
            {
                if(grid[i][j]==1)
                {
                    int temp=dfs(grid,i,j);
                    if(ret<temp)
                    {
                        ret=temp;
                    }
                }
            }
        }
        return ret;
    }
};
```

