搜索算法

枚举法：暴力搜索

深度优先搜索

广度优先搜索

回溯

深度优先遍历(Depth First Search)---------一条道走到黑

  

例子：假设有编号1~3的3张扑克牌和编号为1~3的3个盒子，现在需要将三张牌放到3个盒子中去，且每个盒子只能放一张牌，一共有多少种不同的方法

每一个盒子的处理逻辑：

```cpp
void DFS(vector<int>&box,vector<int>&used,int idx,vector<int>&solution)
{
    //处理当前盒子
    for(int i=1;i<=box.size();++i)
    {
        //判断当前牌是否用过
        if(used[i]==0)
        {
            //当前没有使用的拍放入盒子
            box[idx]=i;
            solution.push_back(i);
            used[i]=1;
            DFS(box,used,idx+1,solution);
            used[i]=0;
        }
    }
}
```

1.处理边界：出口判断

2.处理当前每一步可能

3.处理下一步

690.员工的重要性：

### 迷宫问题

迷宫有n行m列的单元格组成(n,m都小于等于50)，每个单元格要么是空地，要么是障碍物，现请你找到一条从起点到终点的最短路径长度

![image-20211127210556478](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210556478.png)

![image-20211127210632571](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211127210632571.png)

DFS生搜解决迷宫问题

```cpp
#include<iostream>
using namespace std;
int p,q,min_step;
int m,n;
int arr[100][100];//1标识空地，2标识障碍物
int v[100][100];//0代表为访问，1代表访问

//按照顺时针：右下左上遍历
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
void dfs(int x,int y,int step)
{
    if(x==p&&y==q)
    {
        if(step<min_step)
        {
            min_step;
        }
        return ;
    }
    //顺时针试探
    //右
    if(y+1<=n&&a[x][y+1]==1&&v[x][y+1]==0)
    {
        v[x][y+1]=1;
        dfs(x,y+1,step+1);
        v[x][y]=0;
    }
    //下
    if(x+1<=m&&a[x+1][y]==1&&v[x+1][y]==0)
    {
        v[x+1][y]=1;
        dfs(x+1,y,step+1);
        v[x+1][y]=0;
    }
    //左
    if(y-1>=1&&a[x][y-1]==1&&v[x][y-1]==0)
    {
        v[x][y-1]=1;
        dfs(x,y-1,step+1);
        v[x][y-1]=0;
    }
    //上
    if(x-1>=1&&a[x-1][y]==1&&v[x-1][y]==0)
    {
        v[x-1][y]=1;
        dfs(x-1,y,step+1);
        v[x-1][y]=0;
    }
    
    
    
    //ps:上面4段代买可以柔和在一起
    for(int i=0;i<4;i++)
    {
        x=x+dx[i];
        y=y+dy[i];
        v[x][y]=1;
        dfs(x,y,step+1);
        v[x][y]=0;
    }
}
int main()
{
    int startx,starty;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    scanf("%d%d%d%d",&startx,starty,&p,&q);
    v[startx][starty]=1;
    dfs(startx,starty,0);
    printf("%d",min_step);
}
```

