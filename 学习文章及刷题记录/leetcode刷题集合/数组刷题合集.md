# 数组刷题合集



#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

![image-20211025102406502](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211025102406502.png)

```cpp
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

![image-20211025102459983](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211025102459983.png)

```cpp
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

```

> 最暴力的方式就是直接搜索，时间复杂度O(N^2),容易超时，那么我们就需要借助题目所描述的这个二维矩阵的性质了，题目上说这个矩阵是从左到右是有序的，从上到下也是有序的，那么问题就简单多了，我们可以从右上角或者左下角开始搜索，我们下面以右上角为例进行说明，我们从右上角开始查找，如果target<matrix(i)(j),那么说明它在matrix的左边，如果target>maxtrix(i)(j),说明它在matrix的下面，如果正好相等就返回

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int i=0;
        int j=matrix[0].size()-1;
        while(i<matrix.size()&&j>=0)
        {
            if(target<matrix[i][j])
            {
                j--;
            }
            else if(target>matrix[i][j])
            {
                i++;
            }
            else
            {
                return true;
            }
        }
        return false;
        
    }
};
```

#### [869. 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2/)

> 给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。
>
> 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

```cpp
示例 1：
输入：1
输出：true

示例 2：
输入：10
输出：false

示例 3：
输入：16
输出：true

示例 4：
输入：24
输出：false

示例 5：
输入：46
输出：true
```

> 解法一：
>
> 将n转化为字符串，回溯法求它的全排列，然后与1~10^9内2^n进行对比，判断它是不是2^n次幂
>
> 解法二：
>
> 首先1~10^9内2^n只有30个数，创建一个二维数组，其中每一个一维数组代表2^n方中每个数字的位数，比如235，那么这个一维数组中a[2]=1,a[3]=1,a[5]=1,其它数字全为0，就代表该数字由1个2，1个3，1个5构成，我们将1~10^9内所有的2^n全部统计出来，然后再统计n的个数，判断n的数字位数构成在前面那个二维数组中存不存在，不存在返回false

```cpp
class Solution {
public:
    bool reorderedPowerOf2(int n) {
        vector<vector<int>>arr1;
        //找到1~10^9中2^n的数字各个位的个数
        for(long long int i=1;i<=1000000000;i*=2)
        {
            vector<int>temp(10,0);
            long long int j=i;
            while(j)
            {
                temp[j%10]++;
                j/=10;
            }
            arr1.push_back(temp);
       
        }
        //找到n的位数构成
        vector<int>arr2(10,0);
        while(n)
        {
        
            arr2[n%10]++;
            n/=10;
          
        }
		//判断是否存在
        
        for(long long int i=0;i<30;i++)
        {
            int j=0;
            for(;j<10;j++)
            {
                if(arr1[i][j]!=arr2[j])
                {
                    break;
                }
            }

            if(j==10)
            {
                return true;
            }
        }

        return false;

    }
};

//ps:此算法实际的时间复杂度位O(N)
```

