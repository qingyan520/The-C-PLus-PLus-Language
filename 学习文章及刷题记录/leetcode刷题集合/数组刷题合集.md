# 数组刷题合集



#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

![image-20211025102406502](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211025102406502.png)

```cpp
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

![image-20211025102459983](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211025102459983.png)

```cpp
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

```

> 最暴力的方式就是直接搜索，时间复杂度O(N^2),容易超时，那么我们就需要借助题目所描述的这个二维矩阵的性质了，题目上说这个矩阵是从左到右是有序的，从上到下也是有序的，那么问题就简单多了，我们可以从右上角或者左下角开始搜索，我们下面以右上角为例进行说明，我们从右上角开始查找，如果target<matrix(i)(j),那么说明它在matrix的左边，如果target>maxtrix(i)(j),说明它在matrix的下面，如果正好相等就返回

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int i=0;
        int j=matrix[0].size()-1;
        while(i<matrix.size()&&j>=0)
        {
            if(target<matrix[i][j])
            {
                j--;
            }
            else if(target>matrix[i][j])
            {
                i++;
            }
            else
            {
                return true;
            }
        }
        return false;
        
    }
};
```

#### [869. 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2/)

> 给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。
>
> 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

```cpp
示例 1：
输入：1
输出：true

示例 2：
输入：10
输出：false

示例 3：
输入：16
输出：true

示例 4：
输入：24
输出：false

示例 5：
输入：46
输出：true
```

> 解法一：
>
> 将n转化为字符串，回溯法求它的全排列，然后与1~10^9内2^n进行对比，判断它是不是2^n次幂
>
> 解法二：
>
> 首先1~10^9内2^n只有30个数，创建一个二维数组，其中每一个一维数组代表2^n方中每个数字的位数，比如235，那么这个一维数组中a[2]=1,a[3]=1,a[5]=1,其它数字全为0，就代表该数字由1个2，1个3，1个5构成，我们将1~10^9内所有的2^n全部统计出来，然后再统计n的个数，判断n的数字位数构成在前面那个二维数组中存不存在，不存在返回false

```cpp
class Solution {
public:
    bool reorderedPowerOf2(int n) {
        vector<vector<int>>arr1;
        //找到1~10^9中2^n的数字各个位的个数
        for(long long int i=1;i<=1000000000;i*=2)
        {
            vector<int>temp(10,0);
            long long int j=i;
            while(j)
            {
                temp[j%10]++;
                j/=10;
            }
            arr1.push_back(temp);
       
        }
        //找到n的位数构成
        vector<int>arr2(10,0);
        while(n)
        {
        
            arr2[n%10]++;
            n/=10;
          
        }
		//判断是否存在
        
        for(long long int i=0;i<30;i++)
        {
            int j=0;
            for(;j<10;j++)
            {
                if(arr1[i][j]!=arr2[j])
                {
                    break;
                }
            }

            if(j==10)
            {
                return true;
            }
        }

        return false;

    }
};

//ps:此算法实际的时间复杂度位O(N)
```

#### [384. 打乱数组_洗牌算法](https://leetcode-cn.com/problems/shuffle-an-array/)

> 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
>
> 实现 Solution class:
>
> Solution(int[] nums) 使用整数数组 nums 初始化对象
> int[] reset() 重设数组到它的初始状态并返回
> int[] shuffle() 返回数组随机打乱后的结果

```cpp
示例：
输入
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]

```

该题目即设计一个算法，随机打乱一个数组的顺序，这里我们就要用到洗牌算法了

```cpp
for(int i=0;i<nums.size();i++)
{
    //rand产生随机数
    int j=i+rand()%(nums.size()-i);
    swap(nums[i],nums[j]);
}
```

那么上面这道题目就变得非常简单了

```cpp
class Solution {
public:
    vector<int>ans,orign;
    Solution(vector<int>& nums)
    {
        for(auto e:nums)
        {
            ans.push_back(e);
            orign.push_back(e);
        }

    }
    
    vector<int> reset() {
        return orign;
    }
    
    vector<int> shuffle() {
        //打乱一个数组的顺序
        for(int i=0;i<ans.size();i++)
        {
            int j=i+rand()%(ans.size()-i);
            swap(ans[i],ans[j]);
        }
        return ans;

    }
};
```

