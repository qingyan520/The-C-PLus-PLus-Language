并查集是一个森林————多棵树构成森林

并查集，有多个集合构成，每个集合就可以认为是一棵树

并：合并多个集合

查：两个值是否在一个集合



树表示一个集合

并查集中有多个集合，也就是有多棵树，每棵树都存在数组中，用双清表示法

双亲表示法：每个位置都是双亲的小标，根节点存的是一个负值

![image-20220331193612532](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220331193612532.png)

并查集理解：

```

```

并查集代码

```cpp
#include<iostream>
#include<vector>
#include<assert.h>
using namespace std;
class UnionFindSet
{
    public:
    UnionFindSet(int n)
    {
    	_ufs.resize(n,-1);    
    }
    //x1和x2所在的集合合并
    void Union(int x1,int x2)
    {
        assert(x1<_ufs.size());
        assert(x2<_ufs.size());
        int root1=FindRoot(x1);
        int root2=FindRoot(x2);
        //本身在一个集合就不合并
        //不在一个集合进行合并
        if(root1!=root2)
        {
        	_ufs.[root1]+=_ufs[root2]; 
            _ufs[root2]=root1;
        }
        
        
    }
    //查找x所在集合的根
    int FindRoot(int x)
    {
        assert(x<_ufs.size());
        while(_ufs[x]>=0)
        {
            x=_ufs[x];
        }
        return x;
    }
    private:
    vector<int>_ufs;
};
```

#### [剑指 Offer II 116. 省份数量](https://leetcode-cn.com/problems/bLyHh0/)

 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

 ![image-20220331193352241](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220331193352241.png)

```cpp
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

![image-20220331193414972](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220331193414972.png)

```cpp
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```

```cpp
提示：
1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] 为 1 或 0
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]
```

本题目为并查集中的经典题目，

```cpp
//这是并查集代码
class UnionFindSet
{
    public:
    //将每个节点初始化为-1
    UnionFindSet(int n)
    {
        _parent.resize(n,-1);
    }

    //找到它的根
    int FindRoot(int x)
    {
        int x_root=x;
        while(_parent[x_root]>=0)
        {
            x_root=_parent[x_root];
        }
        return x_root;
    }

    //二者进行合并
    void Union(int x,int y)
    {
        int x_root=FindRoot(x);
        int y_root=FindRoot(y);
        if(x_root!=y_root)
        {
           _parent[x_root]+=_parent[y_root];
            _parent[y_root]=x_root;
        }
    }
	
    //p
    int Size()
    {
        int count=0;
        for(auto e:_parent)
        {
            if(e<0)
            count++;
        }
        return count;
    }

    private:
    vector<int>_parent;
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {

        UnionFindSet ufs(isConnected.size());
        for(int i=0;i<isConnected.size();i++)
        {
            for(int j=0;j<isConnected[i].size();j++)
            {
                if(isConnected[i][j]==1)
                ufs.Union(i,j);
            }
        }
        return ufs.Size();


    }
};
```

#### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

```
示例 1：

输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/satisfiability-of-equality-equations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

```
示例 2：

输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
```

```
示例 3：

输入：["a==b","b==c","a==c"]
输出：true
```

代码：

```cpp

//并查集简单实现
class UnionFindSet{
    public:
    UnionFindSet(int n)
    {
        _parent.resize(n,-1);
    }
    int FindRoot(int x)
    {
        while(_parent[x]>=0)
        {
            x=_parent[x];
        }
        return x;
    }

    void Union(int x,int y)
    {
        int x_root=FindRoot(x);
        int y_root=FindRoot(y);

        if(x_root!=y_root)
        {
            _parent[x_root]=y_root;
        }
    }
    private:
    vector<int>_parent;
};


class Solution {
public:
    bool equationsPossible(vector<string>& equations) {

        UnionFindSet _ubfs(26);
        //先把相等的进行融合，然后判断不想等的是否在该集合中
		
        //先将相等的字符串弄到一个集合中，然后再将不相等的字符串判断两者是否在同一个集合中
        for(auto e:equations)
        {
            if(e[1]=='=')
            {
                _ubfs.Union(e[0]-'a',e[3]-'a');
            }
        }

        for(auto e:equations)
        {
            if(e[1]=='!')
            {
                if(_ubfs.FindRoot(e[0]-'a')==_ubfs.FindRoot(e[3]-'a'))
                {
                    return false;
                }
            }
        }
        return true;
    }
};
```

