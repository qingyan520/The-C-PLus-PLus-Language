线段树

一个数组频繁进行修改某个下标值或者求某一段区间的和，这时时间复杂度就非常高

![image-20220404100747212](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220404100747212.png)

![image-20220404100831650](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220404100831650.png)

![image-20220404100923146](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220404100923146.png)

![image-20220404101415930](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220404101415930.png)

![image-20220404101542623](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220404101542623.png)





```cpp
#include<stdio.h>
#define MAX_LEN 1000

void build_tree(int arr[],int tree[],int node,int start,int end)
{
    
    if(start==end)
    {
        tree[node]=arr[start];
    }
	else
    {
        int mid=(start+end)/2;
    	int left_node=node*2+1;
    	int right_node=node*2+2;
    	build_tree(arr,tree,left_node,start,mid);
    	build_tree(arr,tree,right_node,mid+1,end);
    	tree[node]=tree[left_node]+tree[node_right];
    }
}


void updata(int arr[],int tree[],int ndoe,int start,int end,int index,int val)
{
    if(start==end)
    {
        arr[index]=val;
        tree[node]=val;
        return;
    }
    int mdi=(start+end)/2;
    int left_node=2*node+1;
    int right_node=2*node+2;
    if(index>=start&&index<=mid)
    {
        updata(arr,tree,left_node,start,mid,idx,val);
    }
    else
    {
		updata(arr,tree,right_node,mid+1,index,val);
    }
    tree[node]=tree[left_node]+tree[right_node];
}

int query_tree(int arr[],int tree[],int node,int start, int end,int L,int R)
{
    if(R<start||L>end)
    {
        return 0;
    }
    else if(start==end)
    {
        return tree[node];
    }
    int mid=(start+end)/2;
	int left_node=2*node+1;
    int right_node=2*node+2;
    int sum_left=query_tree(arr,tree,left_node,start,mid,L,R);
    int sum_right=query_tree(arr,tree,left_node,mid+1,end,L,R);
    return sum_left+sum_right;
}


int main()
{
    int arr[]={1,3,5,7,9,11};
    int size=6;
    int tree[MAX_LEN]={0};
    build_tree(arr,tree,0,0,size-1)
    return 0;
}
```

