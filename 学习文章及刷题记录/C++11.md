<h3>C++11</h3>

<hr>
1.统一初始化

```
初始化时直接使用{},不s
```

initilizer_list<int> il={1,2,3};

initlizer_list主要用于容器初始化



3.1 auto自动推导类型

3.2decltype 将变量类型推导出来然后定义遍历

```cpp
int i=10;
decltype(i) x=10;
cout<<x<<endl;
```

3.3nullptr:空指针

3.4范围for





7右值引用和移动语义

7.1左值引用和右值引用

无论左值引用还是右值引用，都是在给对象起别名

左值可以取地址

一般情况下可以修改(const修饰的不能修改)

右值引用也是一个数据的表达式，如字面常量，表达式返回值(这个不能是左值引用返回)等，右值可以出现在赋值符号的右边，但是不能出现在赋值符号的左边，右值不能取地址，右值引用就是对右值的引用，给右值起别名

```cpp
int main(){
    double x=1.1,y=2.2;
    10;
    x+y;
    fmin(x,y);
    
    //右值引用
    int&&rr1=10;
    double&&rr2=x+y;
    double&&rr3=fmin(x,y);
}
```

需要注意的是，右值是不能取地址的，但是给右值取别名之后，会导致右值被存储到特定位置，且可以渠道该位置的地址，，也就是说例如。不能取自变量10的地址，但是rr1引用之后，可以对rr1取地址，也可以修改rr1，如果不想rr1被修改。可以用const int&&rr1去引用



左值引用与右值引用的比较：

左值引用—-》左值

右值引用—–》右值

const的左值引用可以引用右值/左值

右值引用可以引用move之后的左值

```
int a=10;
int&&r3=std::move(a);
```

右值引用补齐了左值引用的短板

```cpp
//移动构造
string(string&&s):_str(nullptr),_size(0),_capacity(0){
    this->swap(s);
    
}
//将参数右值的资源窃取国开，占位己有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己


//移动赋值
string&operator=(string&&s){
    this->swap(s);
    return *this;
}
```

右值引用出来之后并不是直接使用右值引用去减少拷贝，提高效率，而是支持深拷贝的类，提供移动构造和移动赋值，这时这些类的的ui想进行船只返回或者是参数为右值时，则可以用移动构造和移动赋值，转移资源，避免深拷贝，提高效率



右值引用主要使用场景：主要是对深拷贝的类，如string,vector,list等等增加移动构造和移动赋值；容器插入接口函数中，如果实参是右值，则可以转移它的资源，减少拷贝



完美转发

```cpp
//模板中&&不代表右值引用，而是万能引用，既可以接受左值也可以接受右值
//模板的万能引用只提供了能够接受同时接收左值引用和右值引用的能力
//但是引用类型的唯一作用就是限制了接受的类型，后续使用中都退化成了左值

void PerfectForward(T&&t){
	Fun(std::forward<T>(t));
}
//右值引用的对象，再次作为实参进行传递时，属性会退化为左值，只能匹配左值引用，使用完美转发，可以保持它的右值属性
```





final修饰类，这个类不能被继承

final修饰虚函数，这个虚函数不能被重写

override修饰子类重写的虚函数，检测是否完成重写，如果没有就报错

一般纯虚函数，才要求子类强制重写，如果子类补充些，子类依旧是抽象类，不能实例化对象



可变参数模板

```cpp
template<class...Args>
void ShowList(Args...args){
	cout<<...(args)<<endl;
}
int main(){
    ShowList();
    ShowList(1,2,1.1);
    ShowList(2.2,1,"hehe");
    
}
```



```cpp
void ShowList(){
    
}
template<class T,class..Args>
void ShowList(T value,Args...args){
	cout<<value<<endl;
	Show(args...);
}
```



lambda表达式

格式：[捕捉列表]  (参数)   —>   返回值类型     {     函数体实现}

捕捉列表和函数体不可以省略

捕捉列表的说明

[val] :表示值传递的方式捕捉变量value

[=] :表示值传递方式捕获所有父作用域中的变量，包括this

[&val] :表示引用传递捕捉变量var

[&] :表示引用传递捕捉所有父作用域中的变量，包括this



```cpp
int main(){
	//最简单的lambda表达式，没有任何意义
    []{};
    
    int a=1;
    int b=2;
    //实现add的lambda表达式
    auto add1=[](int x,int y)->int{
        return x+y;
    }
    cout<<add1(a,b)<<endl;
    //在捕捉列表捕捉a,b,没有参数，可没有返回值，返回值可以通过推导知道
    auto add2=[a,b]()->int{return a+b+10};
    cout<<add2()<<endl;
    
}
```



```cpp
int a=0,b-0;
//捕捉列表，捕捉局部于的变量，减少传参
auto swap=[&a,&b]{
    int temp=a;
    a=b;
    b=temp;
}
//标准写法
auto swap=[](int&a,int&b)->void{
    int temp=a;
    a=b;
    b=temp;
}
```





包装器

可调用对象的类型：函数指针，反函数(函数对象)，lambda表达式





线程<thread>

```cpp
#include<thread>
int main(){
    int n=100;
    thread t1([n]{
        for(size_t i=0;i<n;i+=2){
            cout<<i<<endl;
        }
    });
    thread t2([n]{
        for(size_t i=1;i<n;i+=2){
            cout<<i<<endl;
        }
    });
    
    t1.join();
    t2.join();
    
}
```

两个线程交替打印奇数和偶数

```cpp
#include<thread>
#include<vector>
#include<mutex>


void f(int N){
    mtx.Lock();
    for(int i=0;i<n;++i){
        
        cout<<this_thread::git_id(<<i<<endl;
    }
    mtx.unLock();
                                  
}
int main(){
    int n;
    cin>>n;
    vector<thread>vthreaads;
    vthreads.resize(n);
    mutex mtx;
    int N=100;
    int x=0;
    for(auto&td:vthreads){
        td=thread([&mtx,&N,&x]{

            for(int i=0;i<N;i++){
                            mtx.lock();
                cout<<this_thread::get_id()<<":"<<x<<endl;
                ++x;
                 mtx.unlock();
            }
           
        });
        cout<<td.gett_id()<<endl;
    }
    
    for(auto&td:vthreads){
        td.join();
    }
    
    printf("%d个线程对x++了%d次\n",n,N);
    
}
```



```cpp
atomic<int>x=0;
++x;
//这样就可以使++变成原子性操作
```



```cpp
//b
void func(){
    
}
int main(){
    mutex mtx;
    mtx.lock();
    
    mtx.unlock();
    
}
```

