<h3>C++11</h3>

<hr>
1.统一初始化

```
初始化时直接使用{},不s
```

initilizer_list<int> il={1,2,3};

initlizer_list主要用于容器初始化



3.1 auto自动推导类型

3.2decltype 将变量类型推导出来然后定义遍历

```cpp
int i=10;
decltype(i) x=10;
cout<<x<<endl;
```

3.3nullptr:空指针

3.4范围for





7右值引用和移动语义

7.1左值引用和右值引用

无论左值引用还是右值引用，都是在给对象起别名

左值可以取地址

一般情况下可以修改(const修饰的不能修改)

右值引用也是一个数据的表达式，如字面常量，表达式返回值(这个不能是左值引用返回)等，右值可以出现在赋值符号的右边，但是不能出现在赋值符号的左边，右值不能取地址，右值引用就是对右值的引用，给右值起别名

```cpp
int main(){
    double x=1.1,y=2.2;
    10;
    x+y;
    fmin(x,y);
    
    //右值引用
    int&&rr1=10;
    double&&rr2=x+y;
    double&&rr3=fmin(x,y);
}
```

需要注意的是，右值是不能取地址的，但是给右值取别名之后，会导致右值被存储到特定位置，且可以渠道该位置的地址，，也就是说例如。不能取自变量10的地址，但是rr1引用之后，可以对rr1取地址，也可以修改rr1，如果不想rr1被修改。可以用const int&&rr1去引用



左值引用与右值引用的比较：

左值引用—-》左值

右值引用—–》右值

const的左值引用可以引用右值/左值

右值引用可以引用move之后的左值

```
int a=10;
int&&r3=std::move(a);
```

右值引用补齐了左值引用的短板

```cpp
//移动构造
string(string&&s):_str(nullptr),_size(0),_capacity(0){
    this->swap(s);
    
}
//将参数右值的资源窃取国开，占位己有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己


//移动赋值
string&operator=(string&&s){
    this->swap(s);
    return *this;
}
```

右值引用出来之后并不是直接使用右值引用去减少拷贝，提高效率，而是支持深拷贝的类，提供移动构造和移动赋值，这时这些类的的ui想进行船只返回或者是参数为右值时，则可以用移动构造和移动赋值，转移资源，避免深拷贝，提高效率



右值引用主要使用场景：主要是对深拷贝的类，如string,vector,list等等增加移动构造和移动赋值；容器插入接口函数中，如果实参是右值，则可以转移它的资源，减少拷贝



完美转发

```cpp
//模板中&&不代表右值引用，而是万能引用，既可以接受左值也可以接受右值
//模板的万能引用只提供了能够接受同时接收左值引用和右值引用的能力
//但是引用类型的唯一作用就是限制了接受的类型，后续使用中都退化成了左值

void PerfectForward(T&&t){
	Fun(std::forward<T>(t));
}
```

 





