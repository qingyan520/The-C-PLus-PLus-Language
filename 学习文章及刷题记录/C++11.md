<h3>C++11</h3>

<hr>
1.统一初始化

```
初始化时直接使用{},不s
```

initilizer_list<int> il={1,2,3};

initlizer_list主要用于容器初始化



## 3.1 auto自动推导类型

3.2decltype 将变量类型推导出来然后定义遍历

```cpp
int i=10;
decltype(i) x=10;
cout<<x<<endl;
```

3.3nullptr:空指针

3.4范围for





## 7右值引用和移动语义

7.1左值引用和右值引用

无论左值引用还是右值引用，都是在给对象起别名

左值可以取地址

一般情况下可以修改(const修饰的不能修改)

右值引用也是一个数据的表达式，如字面常量，表达式返回值(这个不能是左值引用返回)等，右值可以出现在赋值符号的右边，但是不能出现在赋值符号的左边，右值不能取地址，右值引用就是对右值的引用，给右值起别名

```cpp
int main(){
    double x=1.1,y=2.2;
    10;
    x+y;
    fmin(x,y);
    
    //右值引用
    int&&rr1=10;
    double&&rr2=x+y;
    double&&rr3=fmin(x,y);
}
```

需要注意的是，右值是不能取地址的，但是给右值取别名之后，会导致右值被存储到特定位置，且可以渠道该位置的地址，，也就是说例如。不能取自变量10的地址，但是rr1引用之后，可以对rr1取地址，也可以修改rr1，如果不想rr1被修改。可以用const int&&rr1去引用



左值引用与右值引用的比较：

左值引用—-》左值

右值引用—–》右值

const的左值引用可以引用右值/左值

右值引用可以引用move之后的左值

```
int a=10;
int&&r3=std::move(a);
```

右值引用补齐了左值引用的短板

```cpp
//移动构造
string(string&&s):_str(nullptr),_size(0),_capacity(0){
    this->swap(s);
    
}
//将参数右值的资源窃取国开，占位己有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己


//移动赋值
string&operator=(string&&s){
    this->swap(s);
    return *this;
}
```

右值引用出来之后并不是直接使用右值引用去减少拷贝，提高效率，而是支持深拷贝的类，提供移动构造和移动赋值，这时这些类的的ui想进行船只返回或者是参数为右值时，则可以用移动构造和移动赋值，转移资源，避免深拷贝，提高效率



右值引用主要使用场景：主要是对深拷贝的类，如string,vector,list等等增加移动构造和移动赋值；容器插入接口函数中，如果实参是右值，则可以转移它的资源，减少拷贝



### 完美转发

```cpp
//模板中&&不代表右值引用，而是万能引用，既可以接受左值也可以接受右值
//模板的万能引用只提供了能够接受同时接收左值引用和右值引用的能力
//但是引用类型的唯一作用就是限制了接受的类型，后续使用中都退化成了左值

void PerfectForward(T&&t){
	Fun(std::forward<T>(t));
}
//右值引用的对象，再次作为实参进行传递时，属性会退化为左值，只能匹配左值引用，使用完美转发，可以保持它的右值属性
```





final修饰类，这个类不能被继承

final修饰虚函数，这个虚函数不能被重写

override修饰子类重写的虚函数，检测是否完成重写，如果没有就报错

一般纯虚函数，才要求子类强制重写，如果子类补充些，子类依旧是抽象类，不能实例化对象



## 可变参数模板

```cpp
template<class...Args>
void ShowList(Args...args){
	cout<<...(args)<<endl;
}
int main(){
    ShowList();
    ShowList(1,2,1.1);
    ShowList(2.2,1,"hehe");
    
}
```



```cpp
void ShowList(){
    
}
template<class T,class..Args>
void ShowList(T value,Args...args){
	cout<<value<<endl;
	Show(args...);
}
```



## lambda表达式

格式：[捕捉列表]  (参数)   —>   返回值类型     {     函数体实现}

捕捉列表和函数体不可以省略

捕捉列表的说明

[val] :表示值传递的方式捕捉变量value

[=] :表示值传递方式捕获所有父作用域中的变量，包括this

[&val] :表示引用传递捕捉变量var

[&] :表示引用传递捕捉所有父作用域中的变量，包括this



```cpp
int main(){
	//最简单的lambda表达式，没有任何意义
    []{};
    
    int a=1;
    int b=2;
    //实现add的lambda表达式
    auto add1=[](int x,int y)->int{
        return x+y;
    }
    cout<<add1(a,b)<<endl;
    //在捕捉列表捕捉a,b,没有参数，可没有返回值，返回值可以通过推导知道
    auto add2=[a,b]()->int{return a+b+10};
    cout<<add2()<<endl;
    
}
```



```cpp
int a=0,b-0;
//捕捉列表，捕捉局部于的变量，减少传参
auto swap=[&a,&b]{
    int temp=a;
    a=b;
    b=temp;
}
//标准写法
auto swap=[](int&a,int&b)->void{
    int temp=a;
    a=b;
    b=temp;
}
```





## 包装器

可调用对象的类型：函数指针，反函数(函数对象)，lambda表达式





## 线程<thread>

```
thread t1(函数名,函数参数)
t1.join();等待线程
t1.detach();线程分离
```



```cpp
#include<thread>
int main(){
    int n=100;
    thread t1([n]{
        for(size_t i=0;i<n;i+=2){
            cout<<i<<endl;
        }
    });
    thread t2([n]{
        for(size_t i=1;i<n;i+=2){
            cout<<i<<endl;
        }
    });
    
    t1.join();
    t2.join();
    
}
```

两个线程交替打印奇数和偶数

```cpp
#include<thread>
#include<vector>
#include<mutex>


void f(int N){
    mtx.Lock();
    for(int i=0;i<n;++i){
        
        cout<<this_thread::git_id(<<i<<endl;
    }
    mtx.unLock();
                                  
}
int main(){
    int n;
    cin>>n;
    vector<thread>vthreaads;
    vthreads.resize(n);
    mutex mtx;
    int N=100;
    int x=0;
    for(auto&td:vthreads){
        td=thread([&mtx,&N,&x]{

            for(int i=0;i<N;i++){
                            mtx.lock();
                cout<<this_thread::get_id()<<":"<<x<<endl;
                ++x;
                 mtx.unlock();
            }
           
        });
        cout<<td.gett_id()<<endl;
    }
    
    for(auto&td:vthreads){
        td.join();
    }
    
    printf("%d个线程对x++了%d次\n",n,N);
    
}
```

线程的互斥<mutex>

竞态条件：多线程程序的执行结果是一致的，互惠随着CPU对线程不同的调用顺序，而产生不同的运行结果

```cpp
//模拟车站三个窗口买票
int count=100;
mutex _lock;
void buyTicket()
{
    while(count>0)
    {
     	_lock.lock();
    	if(count>0)
    	cout<<count--<<endl;
    	_lock.unlock();   
    }
}
int main()
{
    thread t1(buyTicket);
    thread t2(buyTicket);
    thread t3(buyTicket);
    t1.detach();
    t2.detach();
    t23.detach();
}
```

lock_guard和unique_lock

```cpp
lock_gurad<mutex> _lock(mtx);
//lock_guard不容许被拷贝

unique_lock//unique_ptr,
unique_lock<std::mutex> lck(mtx);//unique使用与mutex相同，但是两者都不支持拷贝构造和赋值，但是unique_lock支持右值引用的拷贝构造和赋值，一般用于线程通信


lock_guard和unique_lcok的区别
lock_guard不能用在函数参数传递或者函数参数返回过程中，只能用在简单的临界区代码段的互斥中
unique_lock不仅可以使用在简单的临界区代码互斥操作中，还能用在函数调用过程中
```

线程间的同步同步通信机制

<conditon>

condition_variable

```
cv.notify_all();//通知在cv等待的线程，条件成立了 ，起来干活了
//通知其它再cv上等待的线程，收到通知，从等待状态=>阻塞状态=>获取了互斥锁=>xian'c
```



```cpp
//生产者、消费者线程模型
    
std::mutex mtx;
std::conditon_variable cv;//定义条件变量，做线程间的同步通信操作
class Queue
{
  public:
    
    //生产物品
    void put(int val)
    {
    unique_lock<mutex>lck(mtx);
        while(!que.empty())
        {
            //que不为空和，生产者应该通知消费者去消费，消费完了，再继续生菜
            //生产者线程应该进入等待状态，并且吧mtx互斥锁释放掉
        
            cv.wait(lck);
            
            
        }
        que.push(val);
        cv.notify_all();//通知其它所有线程，我生产了一个线程，你们赶紧消费吧，其它线程得到该同志就会从等待状态变成阻塞状态，获取互斥锁之后才能继续执行
        				//notify_one:通知一个线程
      
    }
    //消费物品
    int get()
    {
     unique_lock<mutex>lck(mtx);
        while(que.empty())
        {
            //消费者线程发现que是空的，通知生产者线程生成物品
            //1.进入等待状态
		    //2.把互斥锁释放掉
             unique_lock<mutex>lck(mtx);
            cv.wait(lck);
        }
        int val=que.front();
        que.pop();
        cv.notigy_all();//通知其它线程我消费完了，赶紧生产把
        
        return val;
    }
    private:
    queue<int>que;
};

void producer(Queue*que)//生产者生产物品
{
    for(int i=0;i<10;i++)
    {
   
        que->put(i);
        
        std::this_thread::skeep_for(std::chormpo::mill(10));
    }
}

void consumer(Queue*que)//消费者线程
{
    
}
int main()
{
    Queue que;//两个线程共享对了
    std::thread t1(producer，&que);
    std::thread t2(consumer,&que);
    t1.join();
    t2.join();
    
}
```





```cpp
atomic<int>x=0;
++x;
//这样就可以使++变成原子性操作
```



```cpp
//b
void func(){
    
}
int main(){
    mutex mtx;
    mtx.lock();
    
    mtx.unlock();
    
}
```

## decltype类型推导

代码示例

```cpp
decltype(t1 + t2) 
template<typename T1, typename T2> 
void Sum(T1 & t1, T2 & t2, decltype(t1 + t2) & s) 
{
	s = t1 + t2; 
}
int main() {
	int a = 3; 
	long b = 5;
    float c = 1.0f, d = 2.3f; 
    long e; float f; 
    decltype(a) g=10; //g的类型被推到为int
    Sum(a, b, e); // s的类型被推导为 long
    Sum(c, d, f); // s的类型被推导为 float 
    }
```

如上所示：decltype可以推导类型，可以声明变量

decltype与auto关键字，使用 追踪返回类型的函数定义来使得编译器对函数返回值进行推导（事实上，decltype一个最大的用途就是用在 追踪返回类型的函数中）

### decltype推导四规则 

```cpp
int i; 
decltype(i) a; // a: int 
decltype((i)) b; // b: int &, 无法编译通过
```

> 事实上，C++11中decltype推导返回类型的规则 
>
> 比我们想象的复杂。具体地，当程序员用decltype(e)来获取类型时，编 
>
> 译器将依序判断以下四规则： 
>
> 1）如果e是一个没有带括号的标记符表达式（id-expression）或者 类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。此外， 如果e是一个被重载的函数，则会导致编译时错误。 
>
> 2）否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么 decltype(e)为T&&。 
>
> 3）否则，假设e的类型是T，如果e是一个左值，则decltype(e)为 T&。
>
> 4）否则，假设e的类型是T，则decltype(e)为T。

我们再回到代码清单4-24，并结合decltype类型推导的规则，就可 以知道，decltype(i)a;使用了推导规则1—因为i是一个标记符表达式，所 以类型被推导为int。而decltype((i))b;中，由于(i)不是一个标记符表达 式，但却是一个左值表达式（可以有具名的地址），因此，按照 decltype推导规则3，其类型应该是一个int的引用。 

### 追踪返回类型

```cpp
template<typename T1, typename T2> 
decltype(t1 + t2) Sum(T1 & t1, T2 & t2) 
{ 
    return t1 + t2;
}

```

> 这样的写法虽然看似不错，不过对编译器来说有些小问题。编译器 在推导decltype(t1+t2)时的，表达式中的t1和t2都未声明（虽然它们近在 咫尺，编译器却只会从左往右地读入符号）。按照C/C++编译器的规 则，变量使用前必须已经声明，因此，为了解决这个问题，C++11引入 新语法—追踪返回类型，来声明和定义这样的函数。 

```cpp
template<typename T1,typename T2>
auto Sum(T1 &t1,T2&t2)->decltype(t1+t2){
    return t1+t2;
}
```

我们把函数的返回值移动到参数声明之后，符合符号->decltype(t1+t2)被称为追踪返回类型，而原本函数返回值的位置由auto关键字占据，这样，我们就可以让编译器来推导Sum函数模板的返回值类型了，而auto占位符和->return_type也就是构成追踪返回类型函数的两个基本元素

返回值类型后置，使模板中的一些类型推导就成为了可能

```cpp
#include<iostream>
using namespace std;
template<class T1,class T2>
auto Sum(const T1&t1,const T2&t2)->decltype(t1+t2){
    return t1+t2;
}
auto Mul(const T1&t1,const T2&t2)->decltype(t1*t2){
    return t1*t2;
}
int main()
{
    int a=10;
    double b=1.1;
    auto c=Sum(a,b);
    cout<<c<<endl;    //11.1
    auto d=Mul(a,b);   
    cout<<d<<endl;    //10
}
```

此外，追踪返回值类型也可以被用在转发函数中

```从【【
#include<iostream>
using namespace std;
double foo(int a){
	return double(a)+0.1;
}
int foo(double a){
	return (int)b;
}
template<class T>
auto ForWard(T t)->decltype(foo(t)){
	return foo(t);
}
int main(){
	cout<<Forward(2)<<endl;
	cout<<Forward(0.5)<<endl;
}
```



future机制

> 获取线程执行的返回值：
>
> packaged_task(function函数对象) async
>
> 

```cpp
#include<iostream>
#include<thread>
#include<future>
#include<funcitonal>
using namespace std;
int sum1(int a,int b)
{
    return a+b;
}
int sum2(int a,int b,int c)
{
    return a+b+c;
}
int main()
{
  //  thread t1(sum1,1,2);
    //thread t2(sum2,1,2,3);
    //t1.join();
    //t2.join();
    packaged_task<int(int,int)> task(sum1);
    future<int>res=task.get_future();
    task(10,10);
    thread t(std::move(task),10,10);
    t.join();
    cout<<res.get()<<endl;
    
}
```

常量表达式constexpr









```cpp
//使用可变参模板编程，使submitTask可以接受生意任务函数和任意数量参数
template<class Func,typename...Args>
auto submitTask(Func&& func,Args&&...args) ->std::future<decltype(func(args...))>
{
    //打包任务，放入任务队列
    using RType=decltype(func(args...));
    auto task=std::make_shared<packaged_task<Rtype()>>(
    std::bind(std::forward<Func>(func),std::forward<Args>(args)...);
     future<Rtype>=task->get_future();
     
}

using Task=std::function<void()>;
```

![image-20220922204342045](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220922204342045.png)

![image-20220922204723024](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220922204723024.png)
