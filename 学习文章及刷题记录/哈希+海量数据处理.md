# 哈希+海量数据处理

常见哈希函数：

直接定值法

除留余数法：%len(表的长度)



哈希冲突：不同的值映射到相同的位置



闭散列的开放定址法：数组方法

开散列—拉链法—-哈希桶



负载因子：表中已有的数据个数/表的长度



位图的应用：

40亿个无符号整型，给一个无符号整型，如何判断一个数是否在这个集合中

位图只能处理整型



布隆过滤器：位图的衍生

针对字符串设计一个和位图差不多的数据结构

布隆解决方式：这个问题不可以解决，降低误判概率

每个值映射一个位置容易冲突，每个值可以映射多个位置，映射多各位，还时存在误判，但是误判的概率降低了，因为要映射多个位都被占用冲突，才会误判

布隆过滤器，出发点是节省空间，效率高，

布隆过滤器不存在删除

```cpp
BllomFilter
#include<iostream>
using namespace std;
template<class K,class Hash1,class Hash2,class Hash3,size_t N=-1>
class BoolFolter
{
    public:
    void Set(const K&key)
    {
        size_t i1=Hash1()(key)%N;
        size_t i2=Hash2()(key)%N;
       size_t i3=Hash3()(key)%N;
        _bset.Set(i1);
        _bset.Set(i2);
        _bset.Set(i3);
    }
    bool Test(const K&key)
    {
        size_t i1=Hash1()(key)%N;
        if(_bset.Test(i1)==false)
        {
            return false;
        }
        
        ize_t i2=Hash2()(key)%N;
        if(_bset.Test(i2)==false)
        {
            return false;
        }
        
        ize_t i3=Hash3()(key)%N;
        if(_bset.Test(i3)==false)
        {
            return false;
        }
        return True;//这里三个为都在有可能是其它key占的，是不准确的，存在误判
        //不在是准确的
    }
    private:
    BitSet<N>_bset;
}
void testBloom()
{
    
}
int main()
{
    
    return 0;
}
```

布隆过滤器

优点：节省空间(相对于平衡搜索树和哈希表)，效率高

缺点：存在误判，在是不准确的，不在是准确的，一般不支持删除

布隆过滤器的使用前提是容许存在误判

1.给定两个文件1，分别由100亿个query,我们只有1G内存，如何找到两个文件的交集，分别给出精确算法和近似算法

2.如何扩展BloomFilter使得他支持删除元素操作

使用多个为表示一个位置，多个值映射时，++计数,删除时，– –计数

3.假设平均每个query 20byte,那么100亿query就是100亿*20字节，1G大概就是10亿byte,可以看到一个文件大概在200G左右

哈希切分：读取文件A中的100一个query字符串，进行哈希切分,

我们有1G内存，哈希切分不一定平均，简易切成400分，读取文件中的每一个query,然后创建A0-A399的400个小文件读取文件中的每一个query.计算i=HashBKDR()(query)%400,这个query就读如Ai的小文件中

哈希切分的特点:A和B文件中相同的query,进入编号相同的小文件