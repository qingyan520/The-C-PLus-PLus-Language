设计模式



12.单例模式

Singleton

在软件系统中，只存在一个实例，才能保证它们的逻辑正确性，以及良好的效率

```cpp
class Singleton
{
	private:
    Singleton();
    Singleton(const Singleton&other);
    static Singleton* m_instance;
     mutex lock;
    public:
    static Singleton*getInstance();
    
}

//双检查锁，但由于内存读写reorder不安全
static Singleton* Singleton::getInstance()
{
    if(m_instance==nullptr)
    {
       lock.lock();
        if(m_instance==nullptr)
        {
            m_instance=new Singleton();
        }
        lock.unlock();
    }
    return m_instance;
}
```

![image-20220501095201785](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220501095201785.png)

Singleton模式中的实例构造器可以设置为protected以允许子类派生

Singleton模式一般不支持拷贝构造函数和Clone接口，因为这有可能导致多个对象示例，与Singelton模式的初衷违背

在多线程环境下安全的Singleton，注意双检查锁的正确实现