# 哈希

### unordered系列容器简单使用

> unordered_map
>
> unordered_set
>
> 前面这两个底层是哈希表，建立某种映射关系，为C++11提供,遍历时没有顺序
>
> 
>
> map/set底层是红黑树
>
> 
>
> unordered系列关联式容器
>
> unordered_map
>
> 1.unordered_map是存储<key,value>键值对的关联式容器，其容许通过keys快速的索引到与其对应的value
>
> 2.unordered_map中，键值通常唯一的标识元素，而映射值是一个对象，其内容与此键关联，键值和映射值的类型可能不同
>
> 3.unordered_map没有对<key,value>按照任何特定的顺序排序，为了在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中
>
> 4.unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面的效率比较低
>
> 5.unordered_maps实现了直接访问操作符operator[]，它容许使用key作为参数直接访问value
>
> 6.它的迭代器至少是前向迭代器

```cpp
#include<iostream>
#include<unordered_set>
#include<unordered_map>
#include<time.h>
#include<set>
using namespace std;
namespace std
{
    void test_unordered_set()
    {
        unordered_set<int>us;
        us.insert(1);
        us.insert(5);
        us.insert(0);
        us.insert(2);
        us.insert(1);
        //迭代器遍历
        //遍历结果是无序的
        unordered_set<int>::iterator it = us.begin();
        while (it != us.end())
        {
            cout << *it << " ";
            ++it;
        }
        for (auto e : us)
        {
            cout << e << " ";
        }
        cout << endl;
        auto pos = us.find(2);
        //auto pos find(us.begin(),us.end(),2)//通用算法，有点事每个容器都可以使用，泛型编程，暴力查找，时间复杂度是O(N)
        //unordered_set中的find是unordered_map专用查找算法，使用了哈希特性进行查找，效率高,查找效率是O(1)
        //类似的，如果是set，查找效率是O(logN)
        //上面两种查找方式：
        //第一种
        if (pos != us.end())
        {
            cout << "找到了" << endl;
        }
        else
        {
            cout << "未找到" << endl;
        }

    }

    void test_unordered_map()
    {
        //不会根据key进行排序
        unordered_map<int, int>m;
        int arr[]{ 5,2,3,4,1,0 };
        for (auto e : arr)
        {
            m.insert(make_pair(e, e));
        }

        auto it = m.begin();
        while (it != m.end())
        {
            cout << it->first << ":" << it->second << endl;
        }

        for (auto e : m)
        {
            cout << e.first << ":" << e.second << endl;
        }
    }

    //增删查改的效率
    void test_op()
    {
        int N = 300000000;
        srand(time(0));
        vector<int>v;
        v.reserve(N);
        for (int i = 0; i < N; i++)
        {
            v.push_back(rand());
        }

        unordered_set<int>us;
        set<int>s;
        size_t begin1 = clock();
        for (auto e : v)
        {
            us.insert(e);
        }
        size_t end1 = clock();
        size_t begin2 = clock();
        for (auto e : v)
        {
            s.insert(e);
        }
        size_t end2 = clock();
        cout << "unordered_set_insert:" << end1 - begin1 << endl;
        cout << "set_insert:" << end2 - begin2 << endl << endl;;

        size_t begin3 = clock();
        for (auto e : v)
        {
            us.find(e);
        }
        size_t end3 = clock();

        size_t begin4 = clock();
        for (auto e : v)
        {
            s.find(e);
        }
        size_t end4 = clock();

        cout << "unordered_set_find:" << end3 - begin3 << endl;
        cout << "set_find:" << end4 - begin4 << endl << endl;;

        size_t begin5 = clock();
        for(auto e:v)
        {
            us.erase(e);
        }
        size_t end5 = clock();

        size_t begin6 = clock();
        for (auto e : v)
        {
            s.erase(e);
        }
        size_t end6 = clock();

        cout << "unordered_set_erase:" << end5 - begin5 << endl;
        cout << "set_erase:" << end6 - begin6 << endl;

    }

}
int main()
{
    std::test_op();

    return 0;
}
```

> 序列是容器：vector/list/deque 纯粹的存储数据
>
> 关联式容器：map/set/unordered_map/unordered_set 存储数据+查找数据
>



### 哈希表

> 哈希/散列—–建立映射关系
>
> 常见哈希函数
>
> 1.直接定址法———–只适用于整数，且数据范围比较集中，速度快，且节省时间O(1)，每个值都对应一个唯一位置
>
> 直接定址法的缺陷：给一组数据，范围很大，直接定址法会浪费很多空间；不能处理浮点数，字符串等场景
>
> 2.除留余数法———数据范围很大，不同的值经过同一哈希函数可能映射到同一位置上(哈希冲突)

```
1    5  10    100000   100   18   15   7
```

​    把数据映射到有限的空间里面，

```
0     1    2    3    4    5    6    7   8   9   
0     1                   5         7   18
100000
100
```

> 如何解决哈希冲突：
>
> 1.闭散列—开放定址法
>
> a.线性探测法
>

```cpp
如果除留余数法映射出的当前位置已经存储元素了，往后进行线性查找到第一个空位置进行插入
Hash(key)=key%klen+i;
```

> 线性探测的缺点：某个位置出现冲突，会出现踩踏效应
>
> 
>
> b.二次探测法:减少踩踏
>

```cpp
Hash(key)=key%len+i^2(i=0,1,2,3,4);
```



> 负载因子/载荷因子：存储的有效数据个数/空间的大小
>
> 负载因子越大，冲突的概率就越高，增删查改的效率就越低
>
> 负载因子越小，冲突的概率就越低，增删查改的效率就越高，但是空间利用率越低
>
> 实际中当负载因子>0.7之后我们就要重新开辟空间了，注意这里增容之后要将原来的数据重新在插入一遍建立新的映射关系
>



### 线性闭散列模拟实现

```cpp
#include<iostream>
#include<vector>
using namespace std;

//模拟存在，删除，未使用三种状态
enum State
{

	EMPTY,
	EXITS,
	DELETE,
};

//建立数据节点，里面不仅有一个pair类型的数据，还有一个标志位代表该位置有没有使用
template<class K,class V>
struct HashData
{
	pair<K, V>_kv=make_pair(K(),V());
	State _state=EMPTY;
};

//建立专门的比较函数，使得哈希函数可以顺利进行取模运算
template<class K>
struct Hash
{
	size_t operator()(K k)
	{
		return k;
	}
};
//模板的特化
template<>
struct Hash<string>
{
    //string类型进行模板的特化
	size_t operator()(string s)
	{
		size_t value = 0;
		for (int i = 0; i < s.size(); i++)
		{
			value += s[i];
			value *= 131;
		}
		return value;
	}
};

//建立哈希表------线性开散列
template<class K, class V,class HashFun=Hash<K>>
class HashTable
{
public:
    
    
    //插入元素
	bool Insert(const pair<K, V>& kv)
	{
        //首先判断该元素是否存在
		HashData<K, V>* ret = Find(kv.first);
		if (ret != nullptr)
		{
			return false;
		}
			
        //如果size==0,则说明第一次插入需要进行增容
		if (_table.size() == 0)
		{
			_table.resize(10);
		}
        
        //如果负载因子>0.7就需要进行扩容
		else if (_table.size() != 0 && (double)n / double(_table.size()) > 0.7)
		{
            //哈希表的扩容不是简单的resize,而是开辟相同的空间，增大容量，然后重新插入元素
			HashTable<K,V> newtable;
			newtable._table.resize(_table.size() * 2);
		
			for (size_t i = 0; i < _table.size(); i++)
			{
				if(_table[i]._state==EXITS)
				newtable.Insert(_table[i]._kv);
			}
			//交换_table内容
			_table.swap(newtable._table);
		}
		HashFun value;
        
        //利用除留取余法建立哈希映射
		size_t start = value(kv.first) % _table.size();
		size_t index = start;
		int i = 1;
        
        //_state==EXITS说明该位置被占用了，找到第一个不被占有的位置进行插入
		while (_table[index]._state == EXITS)
		{
			index = start + i;
            //每次++之后进行取模防止超出范围
			index %= _table.size();
			++i;
		}
        //找到该位置进行插入
		_table[index]._kv = kv;
		_table[index]._state = EXITS;
		n++;
		return true;
	}

    
    //查找元素：返回指针便于修改
	HashData<K, V>* Find(const K & key)
	{
		if (_table.size() == 0)
		{
			return nullptr;
		}
		HashFun value;
		size_t start = value(key) % _table.size();
		int index = start;
		int i = 1;
		while (_table[index]._state != EMPTY)
		{
			if (_table[index]._state == EXITS && _table[index]._kv.first == key)
			{
				return &_table[index];
			}
			index = start + i;
			index %= _table.size();
			i++;
		}
		return nullptr;
	}

    //删除：删除只需要进行标记即可，然后下次只需要覆盖写入即可
	bool Erase(const K& key)
	{
		HashData<K, V>* ret = Find(key);
		if (ret == nullptr)
			return false;
		ret->_state = DELETE;
        //注意删除后n--
		n--;
		return true;
	}
	

	size_t size()
	{
		return n;
	}

	bool empty()
	{
		return n == 0;
	}

private:
	vector<HashData<K,V>>_table;
	size_t n=0;
};
int main()
{
    //简单测试哈希表
	HashTable<int, int>ht;
	int arr[]{ 14,15,2,3,1,8,9,10,11,12 ,11};
	for (auto e : arr)
	{
		ht.Insert(make_pair(e, e));
	}
    
    //简单利用哈希表统计字符个数
	HashTable<string, int>hs;
	string s[]{ "苹果","西瓜","苹果", "西瓜", "苹果", "苹果","苹果","玉米","小麦" };
	for (auto e : s)
	{
		HashData<string, int>* ret = hs.Find(e);
		if (ret == nullptr)
		{
			hs.Insert(make_pair(e,1));
		}
		else
		{
			ret->_kv.second++;
		}
	}
	return 0;
}
```

![image-20211121205028005](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211121205028005.png)

> 一个类型去做map/set的Key有什么要求——能支持比较大小
>
> 一个类型去做unordered_map/unordered_set的Key有什么要求——–能支持变换成整形+相等比较
>
> 1.直接定址法：每个值都有一个唯一的位置，效率很高，每次都是1次就能找到
>
> 缺点：使用场景比较局限，通常要求数据是整数，范围比较集中
>
> 2.除留余数法：根据数据个数开辟一块空间，key%空间大小，算出映射位置。
>
> 优点：适用场景一下就广了，不受限制
>
> 缺点：存在哈希冲突———需要解决哈希冲突，哈希冲突越多，效率下降越厉害
>
> 解决哈希冲突的方法：
>
> 1.闭散列——开发定址法：
>
> a、线性探测法
>
> b、二次探测法
>
> 2.开散列：哈希桶/拉链法



#### 项目地址

[The-C-PLus-PLus-Language/2.C++初阶/test_11_21_HashTable_闭散列 at master · qingyan520/The-C-PLus-PLus-Language (github.com)](https://github.com/qingyan520/The-C-PLus-PLus-Language/tree/master/2.C%2B%2B初阶/test_11_21_HashTable_闭散列)



### 开散列模拟实现

```cpp
//哈希表开散列模拟实现：
//哈希表的开散列中表中每一个位置存放节点的指针，如果发生哈希冲突，那么就把他挂载到这个节点上去


#include<iostream>
#include<vector>
using namespace std;

//创建节点类型
template<class K,class V>
struct HashTableNode
{
	HashTableNode<K, V>* _next;
	pair<K, V>_kv;

	HashTableNode(const pair<K, V>& kv = pair<K, V>()) :
		_next(nullptr),
		_kv(kv)
	{

	}
};

//哈希函数：用于拿到每一个key，将其变为整形，方便除留取余法进行映射
template<class K>
struct Hash
{
	size_t operator()(const K& key)
	{
		return key;
	}
};
//模板的特化
template<>
struct Hash<string>
{
	size_t operator()(const string& key)
	{
		size_t ret = 1;
		for (int i = 0; i < key.size(); i++)
		{
			ret = ret * 131 + key[i];
		}
		return ret;
	}
};


//哈希表主体实现
template<class K, class V,class HashFunc=Hash<K>>
class HashTable_Open
{
	typedef HashTableNode<K, V> Node;

private:

	//我们认为控制哈希表的容量，让其容量变成素数，可减少哈希冲突
	size_t Get_Next_Size(size_t n)
	{
		static const size_t primeList[29] = {
			53ul,97ul,193ul,193ul,389ul,769ul,
			1543ul,3079ul,6151ul,12289ul,2493ul,
			49157ul,98317ul,196613ul,393241ul,786433ul,
			1572869ul,3145739ul,6291469ul,12582917ul,25165843ul,
			50331653ul,10063319ul,201326611ul,402653189ul,805306457ul,
			1610612741ul,3221225473ul,4294967291ul
		};
		for (int i = 0; i < 29; i++)
		{
			if (primeList[i] > n)
			{
				return primeList[i];
			}
		}
		return -1;

	}
public:

	bool Insert(const pair<K, V>& kv)
	{

		if (Find(kv.first) != nullptr)
			return false;

		//如果负载因子==1，进行增容
		if (_table.size() == _n)
		{
			//增容时我们选择该表节点的指向
			vector<Node*>newtable;
			size_t new_size=Get_Next_Size(_table.size());
			newtable.resize(new_size);
			for (size_t i = 0; i<_table.size(); i++)
			{
				//当前头节点不为空
				if (_table[i] != nullptr)
				{
					//从当前节点开始重新建立映射关系
					Node* cur = _table[i];
					while (cur!=nullptr)
					{
						HashFunc hf;
						//重新建立映射关系
						size_t index = hf(cur->_kv.first )% new_size;
						//链接前先保存当前节点
						Node* next = cur->_next;
						//头插法进行链接
						cur->_next = newtable[index];
						newtable[index] = cur;
						cur = next;
					}
					delete cur;
					cur = nullptr;
				}
			}
			swap(_table,newtable);
		}

		//每次利用头插法进行链接
		HashFunc hf;
		int index = hf(kv.first )% _table.size();
		Node* newnode = new Node(kv);
		newnode->_next = _table[index];
		_table[index] = newnode;
		++_n;
		return true;
	}

	Node* Find(const K& key)
	{
		if (_table.size() == 0)
			return nullptr;
		HashFunc hf;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		while (cur)
		{
			if (cur->_kv.first == key)
			{
				return cur;
			}
			cur = cur->_next;
		}
		return nullptr;
	}


	bool Erase(const K& key)
	{
		if (_table.size() == 0)
			return false;
		HashFunc hf;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		Node* prev = nullptr;
		while (cur)
		{
			if (cur->_kv.first == key)
			{
				if (cur == _table[index])
				{
					_table[index] = cur->_next;
					delete cur;
					cur = nullptr;
				}
				else
				{
					prev->_next = cur->_next;
					delete cur;
					cur = nullptr;
				}
				_n--;
				return true;
			}

			prev = cur;
			cur = cur->_next;
		}
		return false;
	}
private:
	vector<Node*>_table;
	int _n;
};




int main()
{
	HashTable_Open<string, int>ht;
	string s[]{ "苹果","西瓜","苹果", "西瓜", "苹果", "苹果","苹果","玉米","小麦" };
	for (auto e : s)
	{
		HashTableNode<string, int>* ret = ht.Find(e);
		if (ret == nullptr)
		{
			ht.Insert(make_pair(e, 1));
		}
		else
		{
			ret->_kv.second++;
		}
	}
}
```

#### 插入

```cpp

//我们认为控制哈希表的容量，让其容量变成素数，可减少哈希冲突
	size_t Get_Next_Size(size_t n)
	{
		static const size_t primeList[29] = {
			53ul,97ul,193ul,193ul,389ul,769ul,
			1543ul,3079ul,6151ul,12289ul,2493ul,
			49157ul,98317ul,196613ul,393241ul,786433ul,
			1572869ul,3145739ul,6291469ul,12582917ul,25165843ul,
			50331653ul,10063319ul,201326611ul,402653189ul,805306457ul,
			1610612741ul,3221225473ul,4294967291ul
		};
		for (int i = 0; i < 29; i++)
		{
			if (primeList[i] > n)
			{
				return primeList[i];
			}
		}
		return -1;

	}
bool Insert(const pair<K, V>& kv)
	{

		if (Find(kv.first) != nullptr)
			return false;

		//如果负载因子==1，进行增容
		if (_table.size() == _n)
		{
			//增容时我们选择该表节点的指向
			vector<Node*>newtable;
			size_t new_size=Get_Next_Size(_table.size());
			newtable.resize(new_size);
			for (size_t i = 0; i<_table.size(); i++)
			{
				//当前头节点不为空
				if (_table[i] != nullptr)
				{
					//从当前节点开始重新建立映射关系
					Node* cur = _table[i];
					while (cur!=nullptr)
					{
						HashFunc hf;
						//重新建立映射关系
						size_t index = hf(cur->_kv.first )% new_size;
						//链接前先保存当前节点
						Node* next = cur->_next;
						//头插法进行链接
						cur->_next = newtable[index];
						newtable[index] = cur;
						cur = next;
					}
					delete cur;
					cur = nullptr;
				}
			}
			swap(_table,newtable);
		}

		//每次利用头插法进行链接
		HashFunc hf;
		int index = hf(kv.first )% _table.size();
		Node* newnode = new Node(kv);
		newnode->_next = _table[index];
		_table[index] = newnode;
		++_n;
		return true;
	}

```



#### 删除

```cpp
bool Erase(const K& key)
	{
		if (_table.size() == 0)
			return false;
		HashFunc hf;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		Node* prev = nullptr;
		while (cur)
		{
			if (cur->_kv.first == key)
			{
				if (cur == _table[index])
				{
					_table[index] = cur->_next;
					delete cur;
					cur = nullptr;
				}
				else
				{
					prev->_next = cur->_next;
					delete cur;
					cur = nullptr;
				}
				_n--;
				return true;
			}

			prev = cur;
			cur = cur->_next;
		}
		return false;
	}
```



#### 查找

```cpp
Node* Find(const K& key)
	{
		if (_table.size() == 0)
			return nullptr;
		HashFunc hf;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		while (cur)
		{
			if (cur->_kv.first == key)
			{
				return cur;
			}
			cur = cur->_next;
		}
		return nullptr;
	}
```



#### 哈希函数

```cpp
template<class K>
struct Hash
{
	size_t operator()(const K& key)
	{
		return key;
	}
};
//模板的特化
template<>
struct Hash<string>
{
	size_t operator()(const string& key)
	{
		size_t ret = 1;
		for (int i = 0; i < key.size(); i++)
		{
			ret = ret * 131 + key[i];
		}
		return ret;
	}
};

```

#### 项目地址

[The-C-PLus-PLus-Language/2.C++初阶/test_11_27_HashTable_开散列 at master · qingyan520/The-C-PLus-PLus-Language (github.com)](https://github.com/qingyan520/The-C-PLus-PLus-Language/tree/master/2.C%2B%2B初阶/test_11_27_HashTable_开散列)

> 
>
> 如何控制哈希冲突：
>
> 1.控制负载因子，负载因在越小，冲突的概率越小，效率越高，但是浪费的空间就越多，反之，则冲突概率越高，效率越低
>
> 负载因子=表中有效数据个数/表的大小
>
> 闭散列的开放定址法，负载因子不能超过1，一般控制在[0.0,0.7]之间
>
> 开散列的哈希桶负载因子可以超过1，一般建议控制在[0.0,1.0]之间
>
> 实际中哈希桶结构更加实用：
>
> a.空间利用率高
>
> b.极端情况下可控
>
> 极端情况：数据不多，负载因子很低，但是这些数据大部分冲突了
>
> 把冲突数据多的桶，改成红黑树结构(超过一定长度(java>8)，就换成红黑树)

### unordered_map/set模拟实现(iterator)

#### HashTable的改变

1.与红黑树一样将<K,V>结构改为<K,T>结构，其中K用来标识key的数据类型，T用来存储真正的数据

2.HashTable里面封装迭代器

```cpp
#pragma once
#include<iostream>
#include<vector>
using namespace std;

//创建节点类型
template<class T>
struct HashTableNode
{
	HashTableNode<T>* _next;
	T _data;

	HashTableNode(const T&data=T()) :
		_next(nullptr),
		_data(data)
	{

	}
};
template<class K,class T,class KeyOfT,class HashFunc>
class HashTable_Open;
template<class K,class T,class KeyOfT,class HashFunc>
struct HTIterator
{
	typedef typename HashTable_Open<K, T, KeyOfT, HashFunc> HashTable;
	typedef HashTableNode<T> Node;
	typedef HTIterator<K, T, KeyOfT, HashFunc> Self;
	HTIterator(Node* p = nullptr, HashTable* pHt = nullptr):
		_p(p),_pHt(pHt)
	{

	}
	Self& operator++()
	{
		if (_p->_next!=nullptr)
		{
			_p = _p->_next;
		}
		else
		{
			//找到下一个不为空的节点
			size_t index = _pHt->HashFunc(KeyOfT(_p->_data)) + 1;
			for (; index < _pHt->_table.size(); ++index)
			{
				if (_pHt->_table[index] != nullptr)
				{
					_p = _pHt->_table[index];
					break;
				}
			}
		}
		return *this;
	}


	Node* _p;
	HashTable* _pHt;
};



//哈希函数：用于拿到每一个key，将其变为整形，方便除留取余法进行映射
template<class K>
struct Hash
{
	size_t operator()(const K& key)
	{
		return key;
	}
};
//模板的特化
template<>
struct Hash<string>
{
	size_t operator()(const string& key)
	{
		size_t ret = 1;
		for (size_t i = 0; i < key.size(); i++)
		{
			ret = ret * 131 + key[i];
		}
		return ret;
	}
};


//哈希表主体实现
template<class K, class T, class KeyOfT, class HashFunc = Hash<K>>
class HashTable_Open
{
	typedef HashTableNode<T> Node;
	friend HTIterator<K, T, KeyOfT, HashFunc>;
private:


	//我们认为控制哈希表的容量，让其容量变成素数，可减少哈希冲突
	size_t Get_Next_Size(size_t n)
	{
		static const size_t primeList[29] = {
			53ul,97ul,193ul,193ul,389ul,769ul,
			1543ul,3079ul,6151ul,12289ul,2493ul,
			49157ul,98317ul,196613ul,393241ul,786433ul,
			1572869ul,3145739ul,6291469ul,12582917ul,25165843ul,
			50331653ul,10063319ul,201326611ul,402653189ul,805306457ul,
			1610612741ul,3221225473ul,4294967291ul
		};
		for (int i = 0; i < 29; i++)
		{
			if (primeList[i] > n)
			{
				return primeList[i];
			}
		}
		return -1;

	}
public:

	typedef HTIterator<K, T, KeyOfT,HashFunc> Iterator;

	Iterator Begin()
	{
		int i = 0;
		for (; i < _table.size(); i++)
		{
			if (_table[i] != nullptr)
				break;
		}
		if (i < _table.size())
			return Iterator(_table[i], this);
		else
			return (nullptr, this);


	}

	Iterator end()
	{
		return Iterator(nullptr, this);
	}


	bool Insert(const T& data)
	{

		KeyOfT Key;
		if (Find(Key(data)) != nullptr)
			return false;

		//如果负载因子==1，进行增容
		if (_table.size() == _n)
		{
			//增容时我们选择该表节点的指向
			vector<Node*>newtable;
			size_t new_size = Get_Next_Size(_table.size());
			newtable.resize(new_size);
			for (size_t i = 0; i < _table.size(); i++)
			{
				//当前头节点不为空
				if (_table[i] != nullptr)
				{
					//从当前节点开始重新建立映射关系
					Node* cur = _table[i];
					while (cur != nullptr)
					{
						HashFunc hf;
						KeyOfT Key;
						//重新建立映射关系
						size_t index = hf(Key(cur->_data)) % new_size;
						//链接前先保存当前节点
						Node* next = cur->_next;
						//头插法进行链接
						cur->_next = newtable[index];
						newtable[index] = cur;
						cur = next;
					}
					delete cur;
					cur = nullptr;
				}
			}
			swap(_table, newtable);
		}

		//每次利用头插法进行链接
		HashFunc hf;
		
		int index = hf(Key(data)) % _table.size();
		Node* newnode = new Node(data);
		newnode->_next = _table[index];
		_table[index] = newnode;
		++_n;
		return true;
	}

	Node* Find(const K& key)
	{
		if (_table.size() == 0)
			return nullptr;
		HashFunc hf;
		KeyOfT Key;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		while (cur)
		{
			if(Key(cur->_data) == key)
			{
				return cur;
			}
			cur = cur->_next;
		}
		return nullptr;
	}


	bool Erase(const K& key)
	{
		if (_table.size() == 0)
			return false;
		HashFunc hf;
		KeyOfT Key;
		int index = hf(key) % _table.size();
		Node* cur = _table[index];
		Node* prev = nullptr;
		while (cur)
		{
			if (Key(cur->_data) == key)
			{
				if (cur == _table[index])
				{
					_table[index] = cur->_next;
					delete cur;
					cur = nullptr;
				}
				else
				{
					prev->_next = cur->_next;
					delete cur;
					cur = nullptr;
				}
				_n--;
				return true;
			}

			prev = cur;
			cur = cur->_next;
		}
		return false;
	}
private:
	vector<Node*>_table;
	int _n;
};


```



#### unordered_map

```cpp
template<calss T>
struct HashNode
{
    HashNode<T>*_next;
    T _data;
    
    
    HashNode(const T&kv)
        :_data(kv),_next(nullptr)
        {}
}
template<class K>
struct Hash
{
    K operator()(const K&key)
    {
        return key;
    }
}

template<>
struct Hash<string>
{
    //string类型进行模板的特化
	size_t operator()(string s)
	{
		size_t value = 0;
		for (int i = 0; i < s.size(); i++)
		{
			value += s[i];
			value *= 131;
		}
		return value;
	}
};

   
//前置声明
template<class K,class T,class KeofT,class HashFunc> 
class HashTable_Open;
//迭代器
template<class K,class T,class KeofT,class HashFunc=Hash<K>> 
struct _HTITerator
{
    typedef HashNode<T>Node;
    typedef _HTITerator<K,T,KeyofT,HashFunc>Self;
    Node*_node;
    Self& operator++()
    {
        //1.当前桶中还有数据，那么就当前通往后走
        if(_node->_next)
        {
			_node=_node->_next；
        }
        //2.当钱桶走往了，就往下一个桶走
        {
            
            size_t index=KeyOfT()(_node->_data)%_pht->_table.size();
            ++index;
            while(index<_pth->_table.size())
            {
                if(_pht->_table[index])
                {
                    _node=_pht->_table[index];
                    return *this;
                }
                else
                    
                ++index;
            }
            _node=_pth->_table[index];
        }
        return *this;
    }
    
    T&operator*()
    {
        return _node->_data;
    }
    
    T*operator->()
    {
        return &_node_>_data;
    }
    
    bool operato!_(const Self&s)
    {
        return _node!=s._node;
    }
    
    bool operator==(const Self&s)
    {
        return _node==s._node;
    }
}

template<class K,class T,class KeofT,class HashFunc=Hash<K>> 
class HashTable
{
    typedef HashNode<T> Node;
    public:
    typedef HTITerator<K,T,KeyOfT,HashFunc>;
    
    
    
    HashTable=default;//显示指定生成默认构造函数
    HashTable(){}
    //拷贝构造函数
    HashTable(const HashTable&ht)
    {
        _n=ht.n;
        _table.resize(th._table.size());
        for(int i=0;i<ht_table.size();i++)
        {
            Node*cur=ht._btale[i];
            while(cur!=nullptr)
            {
                
                Node*copy=new Node(cur->_data);
                copy->_next=_table[i];
                _table[i]=copy;
                cur=cur->_next;
            }
        }
        
    }
    
    
    HashTable&operatpr=(HashTable ht)
    {
        _tabl.swap(ht._table);
        swap(_n,ht._n);
    }   
    
    ~HashTable()
    {
        for(int i=;i<_tbale.soze;i++)
        {
            Node*cur=_table[i];
            while(cur)
            {
                Node*next=cur->_next;
                delete cur;
                cur=next;
            }
            _table[i]=nullptr;
        }
    }
    bool Insert(cosnt T&kv)
    {
        if(Find(kv.first))
            return false;
        HashFunc hf;
        if(_table.zie()==_n)
        {
            //负载因子到1时，进行增容
            vector<Node*>newtable;
            size_t newsize=_table.size()==? 10:_table.size()*2;
            newtable.resize(newsize);
            //遍历旧表的位置，重新计算映射位置，挂到新表中
            for(int i=0;i<_tbale.size();i++)
            {
                if(_table[i]!=nullptr)
                {
                    Node*cur=_table[i];
                    while(cur)
                    {
                        int index=hf(cur->_kv.first)%newtable.size();
                        Node*next=cur->_next;
                        cur->_next=newtable[index];
                        newtaable[index]=cur;
                        cur=next;
                    }
                    _table[i]=nullptr;
                }
            }
            swpa(_table,newtable);
        }
        size_t index=hf(kv.first)%_table.size();
        Node*newnode=new Node(kv);
        //头插
        newnode.next=_table[index];
        _table[index]=newnode;
        ++_n;
        return true;
    }
    
    
    Node*Find(const T&key)
    {
        KeyOfT kot;
        if(!_table.size())
            return false;
        HashFunc hf;
        size_t index=hf(kot(key))%_table.size();
        Node*cur=_table[index];
        while(cur)
        {
            if(cur->_kc.first==key)
            {
                return cur;
            }
            else
            {
                cur=cur->_next;
            }
        }
        return nullptr;
    }
    
    bool Erase(const K&key)
    {
        KeyOfT kot;
  		HashFunc hf;
        size_t index=hf(kot(key))%_table.size();
		Node*prec=nullptr;
        Node*cur=_tab;e[index];
        while(cur)
        {
            if(kot(cur->_data)==key)
            {
                if(_table[iindex]==cur)
                {
                    _table[index]=cur->next;
                }
                else
                {
                    prev->_next=cur->_next;
                }
                delete cur;
                _n--;
                return cur;
            }
            prev=cur;
            cur=cur->_next;
        }
        return false;
            
     
        _n--;
        return true;
    }
    
    
    private:
    vectro<Node*>_table;
   	size_t _n=0;//有效数据的个数
}
```

Unorder_Set

```cpp
template<class K>
class unordered_set
{
    public:
    typedef typedef HashTable_Open<K,K>::iterator iterator;
    
    iterator begin()
    {
        return _th.begin();
    }
    
    iterator end()
    {
        return _ht.end();
    }
    struct MapKeyOfT
    {
        const K&operatro()(K&kv)
        {
          return kv ; 
        }
    }
    bool Insert(const K&k)
    {
        _bt.Insert(k);
        return true;
    }
    private:
    HashTable<K,const K>_ht;
    
}
```

unorder_map

```cpp
template<class K,class V>
class unordered_map
{
    public:
    struct MapKeyOfT
    {
        const K&operatro()(cosnt pair<K,V>kv)
        {
          return kv.first ; 
        }
    }
    typedef typename HashTable_Open<>::iterator iteratr;
    
    bool Insert(const pair<K,V>&kv)
    {
        _bt.Insert(kv);
        return true;
    }
    
   V& operator[](const k&key)
    {
        pair<iterator ,bppl>ret=_ht.insert(make_pair(key,V()));
        return ret.first->second;
    }
    private:
    HashTable<K,pair<const K,V>MapOfT>_ht;
    
}
```

### 位图

1.给40亿个不重复的无符号整形，没有排过序，如果快速判断一个属是否在这40亿个数中

错误方法：

(1)排序+二分查找

排序·的时间复杂度为O(N*logN)

二分查找时间复杂度为O(logN)

问题：40亿个数据，需要16G空间来存储

(2).放进set或者unordered_set,再查找

问题：空间不够

上面两种方案效率都是不错的，但是对内存的消耗时很大的

正确方法：

一个数映射一个位置，40亿个数，需要内存

2^32个位进行映射

2^32/8==512M

```cpp
//BitSet.h
template<size_t N>
class BitSet
{
 public:
    BitSet()
    {
        _bits.resize(N/32+1,0);
    }
    //把x映射的位置标记成1
    void Set(size_t x)
    {
        assert(x<N);
        //算出x映射的位在第几个整数
        //算出x映射的位在这个整数的第几个位
        size_t i=x/32;
        size_t j=x%32;
        //_bits[i]的第j位标记成1
        _bits[i] |=(1<<j);
    }
    
    void Reset(size_t x)
    {
        size_t i=x/32;
        size_t j=x%32;
        _bits[i]&=(~(1<<j));
    }
    
    bool Test(size_t x)
    {
        size_t i=x/32;
        size_t j=x%32;
        
        //如果第j位是1，结果是非0，非0就是真
        //如果第j位是0，结果是0，0就是假
       return  _bits[i]&(1<<j);
       //return (_bits[i]>>j)&1;
    }
    
 private:
    vecotr<int>_bits;
    
};
void TestBitSet()
{
    //BitSet<4294967295u>bs;
    BitSet<-1>bs;
    
    
}
```

1.给定100亿个整数，设计算法找出只出现一次的整数

标记一个整数的一下几种状态:

出现0次：             00

出现1次：              01

出现2次及以上的 10

所有的32变成16就可以搞定

方案二：
建立两个位图

```cpp
BitSet<-1>_bs1;
BitSet<-1>_bs2;
void Set(size_t x)
{
    //00->01
    if(_bs1.Test(x)&&!_bs2.Text(x))
    {
        _bs1.Set(x);
    }//01->10
    else if(!_bs1.Test(x)&&_bs2.Text(x))        
    {
        _bs1.Set(x);
        _bs2.Reset(x);
    }//10->10
    else if(!_bs1.Test(x)&&!_bs2.Text(x))
    {
        //不处理
    }
    else
    {
        assert(flase);
    }
}
//遍历两个位图，把所有的01映射的整数找出来
```

2.给两个文件，分别有100亿个整数，我们只有1G内存，如果找到两个文件的交集

方案一：

把第一个文件中的所有整数依次映射到一个位图，再读取另外一个文件中的所有整数，判断在不在位图中，在就是交集，不在就不是交集中的数

方案二：

依次读取第一个文件的所有整数标记映射到位图1，再读取第二个文件的所有整数标记映射到位图2，再对两个位图进行与等到一起(依次与位图中的整数)，与完之后，还是1的位置的映射就是交集

3.1个文件有100亿int,1G内存，设计算法找出出现不超过2次的所有整数

```cpp

```

