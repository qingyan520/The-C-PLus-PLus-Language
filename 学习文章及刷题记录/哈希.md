# 哈希

unordered系列容器简单使用

unordered_map

unordered_set

前面这两个底层是哈希表，建立某种映射关系，为C++11提供,遍历时没有顺序



map/set底层是红黑树



unordered系列关联式容器

unordered_map

1.unordered_map是存储<key,value>键值对的关联式容器，其容许通过keys快速的索引到与其对应的value

2.unordered_map中，键值通常唯一的标识元素，而映射值是一个对象，其内容与此键关联，键值和映射值的类型可能不同

3.unordered_map没有对<key,value>按照任何特定的顺序排序，为了在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中

4.unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面的效率比较低

5.unordered_maps实现了直接访问操作符operator[]，它容许使用key作为参数直接访问value

6.它的迭代器至少是前向迭代器

```cpp
#include<iostream>
#include<unordered_set>
#include<unordered_map>
#include<time.h>
#include<set>
using namespace std;
namespace std
{
    void test_unordered_set()
    {
        unordered_set<int>us;
        us.insert(1);
        us.insert(5);
        us.insert(0);
        us.insert(2);
        us.insert(1);
        //迭代器遍历
        //遍历结果是无序的
        unordered_set<int>::iterator it = us.begin();
        while (it != us.end())
        {
            cout << *it << " ";
            ++it;
        }
        for (auto e : us)
        {
            cout << e << " ";
        }
        cout << endl;
        auto pos = us.find(2);
        //auto pos find(us.begin(),us.end(),2)//通用算法，有点事每个容器都可以使用，泛型编程，暴力查找，时间复杂度是O(N)
        //unordered_set中的find是unordered_map专用查找算法，使用了哈希特性进行查找，效率高,查找效率是O(1)
        //类似的，如果是set，查找效率是O(logN)
        //上面两种查找方式：
        //第一种
        if (pos != us.end())
        {
            cout << "找到了" << endl;
        }
        else
        {
            cout << "未找到" << endl;
        }

    }

    void test_unordered_map()
    {
        //不会根据key进行排序
        unordered_map<int, int>m;
        int arr[]{ 5,2,3,4,1,0 };
        for (auto e : arr)
        {
            m.insert(make_pair(e, e));
        }

        auto it = m.begin();
        while (it != m.end())
        {
            cout << it->first << ":" << it->second << endl;
        }

        for (auto e : m)
        {
            cout << e.first << ":" << e.second << endl;
        }
    }

    //增删查改的效率
    void test_op()
    {
        int N = 300000000;
        srand(time(0));
        vector<int>v;
        v.reserve(N);
        for (int i = 0; i < N; i++)
        {
            v.push_back(rand());
        }

        unordered_set<int>us;
        set<int>s;
        size_t begin1 = clock();
        for (auto e : v)
        {
            us.insert(e);
        }
        size_t end1 = clock();
        size_t begin2 = clock();
        for (auto e : v)
        {
            s.insert(e);
        }
        size_t end2 = clock();
        cout << "unordered_set_insert:" << end1 - begin1 << endl;
        cout << "set_insert:" << end2 - begin2 << endl << endl;;

        size_t begin3 = clock();
        for (auto e : v)
        {
            us.find(e);
        }
        size_t end3 = clock();

        size_t begin4 = clock();
        for (auto e : v)
        {
            s.find(e);
        }
        size_t end4 = clock();

        cout << "unordered_set_find:" << end3 - begin3 << endl;
        cout << "set_find:" << end4 - begin4 << endl << endl;;

        size_t begin5 = clock();
        for(auto e:v)
        {
            us.erase(e);
        }
        size_t end5 = clock();

        size_t begin6 = clock();
        for (auto e : v)
        {
            s.erase(e);
        }
        size_t end6 = clock();

        cout << "unordered_set_erase:" << end5 - begin5 << endl;
        cout << "set_erase:" << end6 - begin6 << endl;

    }

}
int main()
{
    std::test_op();

    return 0;
}
```

序列是容器：vector/list/deque 纯粹的存储数据

关联式容器：map/set/unordered_map/unordered_set 存储数据+查找数据



哈希/散列—–建立映射关系

常见哈希函数

1.直接定址法———–只适用于整数，且数据范围比较集中，速度快，且节省时间O(1)，每个值都对应一个唯一位置

直接定址法的缺陷：给一组数据，范围很大，直接定址法会浪费很多空间；不能处理浮点数，字符串等场景

2.除留余数法———数据范围很大，不同的值经过同一哈希函数可能映射到同一位置上(哈希冲突)

```
1    5  10    100000   100   18   15   7
```

把数据映射到有限的空间里面，

```
0     1    2    3    4    5    6    7   8   9   
0     1                   5         7   18
100000
100
```

如何解决哈希冲突：

1.闭散列—开放定址法

a.线性探测法

```cpp
如果除留余数法映射出的当前位置已经存储元素了，往后进行线性查找到第一个空位置进行插入
Hash(key)=key%klen+i;
```

线性探测的缺点：某个位置出现冲突，会出现踩踏效应



b.二次探测法:减少踩踏

```cpp
Hash(key)=key%len+i^2(i=0,1,2,3,4);
```



负载因子/载荷因子：存储的有效数据个数/空间的大小

负载因子越大，冲突的概率就越高，增删查改的效率就越低

负载因子越小，冲突的概率就越低，增删查改的效率就越高，但是空间利用率越低

实际中当负载因子>0.7之后我们就要重新开辟空间了，注意这里增容之后要将原来的数据重新在插入一遍建立新的映射关系



线性闭散列模拟实现

```cpp
#include<iostream>
#include<vector>
using namespace std;

//模拟存在，删除，未使用三种状态
enum State
{

	EMPTY,
	EXITS,
	DELETE,
};

//建立数据节点，里面不仅有一个pair类型的数据，还有一个标志位代表该位置有没有使用
template<class K,class V>
struct HashData
{
	pair<K, V>_kv=make_pair(K(),V());
	State _state=EMPTY;
};

//建立专门的比较函数，使得哈希函数可以顺利进行取模运算
template<class K>
struct Hash
{
	size_t operator()(K k)
	{
		return k;
	}
};
//模板的特化
template<>
struct Hash<string>
{
    //string类型进行模板的特化
	size_t operator()(string s)
	{
		size_t value = 0;
		for (int i = 0; i < s.size(); i++)
		{
			value += s[i];
			value *= 131;
		}
		return value;
	}
};

//建立哈希表------线性开散列
template<class K, class V,class HashFun=Hash<K>>
class HashTable
{
public:
    
    
    //插入元素
	bool Insert(const pair<K, V>& kv)
	{
        //首先判断该元素是否存在
		HashData<K, V>* ret = Find(kv.first);
		if (ret != nullptr)
		{
			return false;
		}
			
        //如果size==0,则说明第一次插入需要进行增容
		if (_table.size() == 0)
		{
			_table.resize(10);
		}
        
        //如果负载因子>0.7就需要进行扩容
		else if (_table.size() != 0 && (double)n / double(_table.size()) > 0.7)
		{
            //哈希表的扩容不是简单的resize,而是开辟相同的空间，增大容量，然后重新插入元素
			HashTable<K,V> newtable;
			newtable._table.resize(_table.size() * 2);
		
			for (size_t i = 0; i < _table.size(); i++)
			{
				if(_table[i]._state==EXITS)
				newtable.Insert(_table[i]._kv);
			}
			//交换_table内容
			_table.swap(newtable._table);
		}
		HashFun value;
        
        //利用除留取余法建立哈希映射
		size_t start = value(kv.first) % _table.size();
		size_t index = start;
		int i = 1;
        
        //_state==EXITS说明该位置被占用了，找到第一个不被占有的位置进行插入
		while (_table[index]._state == EXITS)
		{
			index = start + i;
            //每次++之后进行取模防止超出范围
			index %= _table.size();
			++i;
		}
        //找到该位置进行插入
		_table[index]._kv = kv;
		_table[index]._state = EXITS;
		n++;
		return true;
	}

    
    //查找元素：返回指针便于修改
	HashData<K, V>* Find(const K & key)
	{
		if (_table.size() == 0)
		{
			return nullptr;
		}
		HashFun value;
		size_t start = value(key) % _table.size();
		int index = start;
		int i = 1;
		while (_table[index]._state != EMPTY)
		{
			if (_table[index]._state == EXITS && _table[index]._kv.first == key)
			{
				return &_table[index];
			}
			index = start + i;
			index %= _table.size();
			i++;
		}
		return nullptr;
	}

    //删除：删除只需要进行标记即可，然后下次只需要覆盖写入即可
	bool Erase(const K& key)
	{
		HashData<K, V>* ret = Find(key);
		if (ret == nullptr)
			return false;
		ret->_state = DELETE;
        //注意删除后n--
		n--;
		return true;
	}
	

	size_t size()
	{
		return n;
	}

	bool empty()
	{
		return n == 0;
	}

private:
	vector<HashData<K,V>>_table;
	size_t n=0;
};
int main()
{
    //简单测试哈希表
	HashTable<int, int>ht;
	int arr[]{ 14,15,2,3,1,8,9,10,11,12 ,11};
	for (auto e : arr)
	{
		ht.Insert(make_pair(e, e));
	}
    
    //简单利用哈希表统计字符个数
	HashTable<string, int>hs;
	string s[]{ "苹果","西瓜","苹果", "西瓜", "苹果", "苹果","苹果","玉米","小麦" };
	for (auto e : s)
	{
		HashData<string, int>* ret = hs.Find(e);
		if (ret == nullptr)
		{
			hs.Insert(make_pair(e,1));
		}
		else
		{
			ret->_kv.second++;
		}
	}
	return 0;
}
```

![image-20211121205028005](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20211121205028005.png)

一个类型去做map/set的Key有什么要求——能支持比较大小

一个类型去做unordered_map/unordered_set的Key有什么要求——–能支持变换成整形+相等比较

1.直接定址法：每个值都有一个唯一的位置，效率很高，每次都是1次就能找到

缺点：使用场景比较局限，通常要求数据是整数，范围比较集中

2.除留余数法：根据数据个数开辟一块空间，key%空间大小，算出映射位置。

优点：适用场景一下就广了，不受限制

缺点：存在哈希冲突———需要解决哈希冲突，哈希冲突越多，效率下降越厉害

解决哈希冲突的方法：

1.闭散列——开发定址法：

a、线性探测法

b、二次探测法

2.开散列：哈希桶/拉链法







开散列：

```cpp
template<calss K,class V>
struct HashNode
{
    HashNode<K,V>*_next;
    pair<K,V>_kv;
    
    
    HashNode(const pair<K,V>&kv)
        :_kv(kv),_next(nullptr)
        {}
}
template<class K>
struct Hash
{
    K operator()(const K&key)
    {
        return key;
    }
}

template<>
struct Hash<string>
{
    //string类型进行模板的特化
	size_t operator()(string s)
	{
		size_t value = 0;
		for (int i = 0; i < s.size(); i++)
		{
			value += s[i];
			value *= 131;
		}
		return value;
	}
};

   


template<class K,class V,class HashFunc=Hash<K>> 
class HashTable
{
    typedef HashNode<K,V> Node;
    public:
    HashTable(){}
    
    bool Insert(cosnt pair<K,V>kv)
    {
        if(Find(kv.first))
            return false;
        HashFunc hf;
        if(_table.zie()==_n)
        {
            //负载因子到1时，进行增容
            vector<Node*>newtable;
            size_t newsize=_table.size()==? 10:_table.size()*2;
            newtable.resize(newsize);
            //遍历旧表的位置，重新计算映射位置，挂到新表中
            for(int i=0;i<_tbale.size();i++)
            {
                if(_table[i]!=nullptr)
                {
                    Node*cur=_table[i];
                    while(cur)
                    {
                        int index=hf(cur->_kv.first)%newtable.size();
                        Node*next=cur->_next;
                        cur->_next=newtable[index];
                        newtaable[index]=cur;
                        cur=next;
                    }
                    _table[i]=nullptr;
                }
            }
            swpa(_table,newtable);
        }
        size_t index=hf(kv.first)%_table.size();
        Node*newnode=new Node(kv);
        //头插
        newnode.next=_table[index];
        _table[index]=newnode;
        ++_n;
        return true;
    }
    
    
    Node*Find(constK*key)
    {
        if(!_table.size())
            return false;
        HashFunc hf;
        size_t index=hf(key)%_table.size();
        Node*cur=_table[index];
        while(cur)
        {
            if(cur->_kc.first==key)
            {
                return cur;
            }
            else
            {
                cur=cur->_next;
            }
        }
        return nullptr;
    }
    
    bool Erase(const K&key)
    {
  		HashFunc hf;
        size_t index=hf(key)%_table.size();
		Node*prec=nullptr;
        Node*cur=_tab;e[index];
        while(cur)
        {
            if(cur->_kv.first==key)
            {
                if(_table[iindex]==cur)
                {
                    _table[index]=cur->next;
                }
                else
                {
                    prev->_next=cur->_next;
                }
                delete cur;
                _n--;
                return cur;
            }
            prev=cur;
            cur=cur->_next;
        }
        return false;
            
     
        _n--;
        return true;
    }
    
    
    private:
    vectro<Node*>_table;
   	size_t _n=0;//有效数据的个数
}
```

如何控制哈希冲突：

1.控制负载因子，负载因在越小，冲突的概率越小，效率越高，但是浪费的空间就越多，反之，则冲突概率越高，效率越低

负载因子=表中有效数据个数/表的大小

闭散列的开放定址法，负载因子不能超过1，一般控制在[0.0,0.7]之间

开散列的哈希桶负载因子可以超过1，一般建议控制在[0.0,1.0]之间

实际中哈希桶结构更加实用：

a.空间利用率高

b.极端情况下可控

极端情况：数据不多，负载因子很低，但是这些数据大部分冲突了

把冲突数据多的桶，改成红黑树结构(超过一定长度(java>8)，就换成红黑树)

```cpp
template<calss T>
struct HashNode
{
    HashNode<T>*_next;
    T _data;
    
    
    HashNode(const T&kv)
        :_data(kv),_next(nullptr)
        {}
}
template<class K>
struct Hash
{
    K operator()(const K&key)
    {
        return key;
    }
}

template<>
struct Hash<string>
{
    //string类型进行模板的特化
	size_t operator()(string s)
	{
		size_t value = 0;
		for (int i = 0; i < s.size(); i++)
		{
			value += s[i];
			value *= 131;
		}
		return value;
	}
};

   

//迭代器
template<class K,class T,class KeofT,class HashFunc=Hash<K>> 
struct _HTITerator
{
    typedef HashNode<T>Node;
    typedef _HTITerator<K,T,KeyofT,HashFunc>Self;
    Node*_node;
    Self& operator++()
    {
        if(_node->_next)
        {
			_node=_node->_next;
        }
    }
}

template<class K,class T,class KeofT,class HashFunc=Hash<K>> 
class HashTable
{
    typedef HashNode<T> Node;
    public:
    typedef HTITerator<K,T,KeyOfT,HashFunc>;
    
    HashTable(){}
    
    bool Insert(cosnt T&kv)
    {
        if(Find(kv.first))
            return false;
        HashFunc hf;
        if(_table.zie()==_n)
        {
            //负载因子到1时，进行增容
            vector<Node*>newtable;
            size_t newsize=_table.size()==? 10:_table.size()*2;
            newtable.resize(newsize);
            //遍历旧表的位置，重新计算映射位置，挂到新表中
            for(int i=0;i<_tbale.size();i++)
            {
                if(_table[i]!=nullptr)
                {
                    Node*cur=_table[i];
                    while(cur)
                    {
                        int index=hf(cur->_kv.first)%newtable.size();
                        Node*next=cur->_next;
                        cur->_next=newtable[index];
                        newtaable[index]=cur;
                        cur=next;
                    }
                    _table[i]=nullptr;
                }
            }
            swpa(_table,newtable);
        }
        size_t index=hf(kv.first)%_table.size();
        Node*newnode=new Node(kv);
        //头插
        newnode.next=_table[index];
        _table[index]=newnode;
        ++_n;
        return true;
    }
    
    
    Node*Find(const T&key)
    {
        KeyOfT kot;
        if(!_table.size())
            return false;
        HashFunc hf;
        size_t index=hf(kot(key))%_table.size();
        Node*cur=_table[index];
        while(cur)
        {
            if(cur->_kc.first==key)
            {
                return cur;
            }
            else
            {
                cur=cur->_next;
            }
        }
        return nullptr;
    }
    
    bool Erase(const K&key)
    {
        KeyOfT kot;
  		HashFunc hf;
        size_t index=hf(kot(key))%_table.size();
		Node*prec=nullptr;
        Node*cur=_tab;e[index];
        while(cur)
        {
            if(kot(cur->_data)==key)
            {
                if(_table[iindex]==cur)
                {
                    _table[index]=cur->next;
                }
                else
                {
                    prev->_next=cur->_next;
                }
                delete cur;
                _n--;
                return cur;
            }
            prev=cur;
            cur=cur->_next;
        }
        return false;
            
     
        _n--;
        return true;
    }
    
    
    private:
    vectro<Node*>_table;
   	size_t _n=0;//有效数据的个数
}
```

Unorder_Set

```cpp
template<class K>
class unordered_set
{
    public:
    struct MapKeyOfT
    {
        const K&operatro()(K&kv)
        {
          return kv ; 
        }
    }
    bool Insert(const K&k)
    {
        _bt.Insert(k);
        return true;
    }
    private:
    HashTable<K,const K>_ht;
    
}
```

unorder_map

```cpp
template<class K,class V>
class unordered_map
{
    public:
    struct MapKeyOfT
    {
        const K&operatro()(cosnt pair<K,V>kv)
        {
          return kv.first ; 
        }
    }
    bool Insert(const pair<K,V>&kv)
    {
        _bt.Insert(kv);
        return true;
    }
    private:
    HashTable<K,pair<const K,V>MapOfT>_ht;
    
}
```

