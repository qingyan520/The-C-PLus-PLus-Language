哈希



unordered_map

unordered_set

前面这两个底层是哈希表，建立某种映射关系，为C++11提供,遍历时没有顺序



map/set底层是红黑树



unordered系列关联式容器

unordered_map

1.unordered_map是存储<key,value>键值对的关联式容器，其容许通过keys快速的索引到与其对应的value

2.unordered_map中，键值通常唯一的标识元素，而映射值是一个对象，其内容与此键关联，键值和映射值的类型可能不同

3.unordered_map没有对<key,value>按照任何特定的顺序排序，为了在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中

4.unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面的效率比较低

5.unordered_maps实现了直接访问操作符operator[]，它容许使用key作为参数直接访问value

6.它的迭代器至少是前向迭代器

```cpp
#include<iostream>
#include<unordered_set>
#include<unordered_map>
#include<time.h>
#include<set>
using namespace std;
namespace std
{
    void test_unordered_set()
    {
        unordered_set<int>us;
        us.insert(1);
        us.insert(5);
        us.insert(0);
        us.insert(2);
        us.insert(1);
        //迭代器遍历
        //遍历结果是无序的
        unordered_set<int>::iterator it = us.begin();
        while (it != us.end())
        {
            cout << *it << " ";
            ++it;
        }
        for (auto e : us)
        {
            cout << e << " ";
        }
        cout << endl;
        auto pos = us.find(2);
        //auto pos find(us.begin(),us.end(),2)//通用算法，有点事每个容器都可以使用，泛型编程，暴力查找，时间复杂度是O(N)
        //unordered_set中的find是unordered_map专用查找算法，使用了哈希特性进行查找，效率高,查找效率是O(1)
        //类似的，如果是set，查找效率是O(logN)
        //上面两种查找方式：
        //第一种
        if (pos != us.end())
        {
            cout << "找到了" << endl;
        }
        else
        {
            cout << "未找到" << endl;
        }

    }

    void test_unordered_map()
    {
        //不会根据key进行排序
        unordered_map<int, int>m;
        int arr[]{ 5,2,3,4,1,0 };
        for (auto e : arr)
        {
            m.insert(make_pair(e, e));
        }

        auto it = m.begin();
        while (it != m.end())
        {
            cout << it->first << ":" << it->second << endl;
        }

        for (auto e : m)
        {
            cout << e.first << ":" << e.second << endl;
        }
    }

    //增删查改的效率
    void test_op()
    {
        int N = 300000000;
        srand(time(0));
        vector<int>v;
        v.reserve(N);
        for (int i = 0; i < N; i++)
        {
            v.push_back(rand());
        }

        unordered_set<int>us;
        set<int>s;
        size_t begin1 = clock();
        for (auto e : v)
        {
            us.insert(e);
        }
        size_t end1 = clock();
        size_t begin2 = clock();
        for (auto e : v)
        {
            s.insert(e);
        }
        size_t end2 = clock();
        cout << "unordered_set_insert:" << end1 - begin1 << endl;
        cout << "set_insert:" << end2 - begin2 << endl << endl;;

        size_t begin3 = clock();
        for (auto e : v)
        {
            us.find(e);
        }
        size_t end3 = clock();

        size_t begin4 = clock();
        for (auto e : v)
        {
            s.find(e);
        }
        size_t end4 = clock();

        cout << "unordered_set_find:" << end3 - begin3 << endl;
        cout << "set_find:" << end4 - begin4 << endl << endl;;

        size_t begin5 = clock();
        for(auto e:v)
        {
            us.erase(e);
        }
        size_t end5 = clock();

        size_t begin6 = clock();
        for (auto e : v)
        {
            s.erase(e);
        }
        size_t end6 = clock();

        cout << "unordered_set_erase:" << end5 - begin5 << endl;
        cout << "set_erase:" << end6 - begin6 << endl;

    }

}
int main()
{
    std::test_op();

    return 0;
}
```

序列是容器：vector/list/deque 纯粹的存储数据

关联式容器：map/set/unordered_map/unordered_set 存储数据+查找数据

