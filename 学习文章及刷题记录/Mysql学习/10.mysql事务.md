mysql事务

事物的四个特性(ACID)：原子性，一致性，隔离性，持久性

为什么会存在事务：11



事务的提交方式：

自动提交

手动提交

```sql
show variables like 'autocommit';
```

设置mysql的自动提交方式

```sql
set autocommit =0;
```

查看隔离级别

```sql
select @@tx_isolation;
```

将隔离级别设置为 READ UNCOMMIT

```sql
set global transaxtion isolation level READ UNCOMMITTED;
```

隔离级别设置之后，重启会话



```
	start transaction;

`	begin:启动事务
·	
	
```

一个事务被提交就不能被回滚了

如果默认事务时自动提交的话，如果我们后续手动启动begin,默认自动提交是无效的。

我们之前所写的单条DML SQL语句，在mysql中默认就是一个事务！默认是自动提交的，

只要输入begin或者start transaction，事务必须通过commit提交，才会持久化，与是否设置autocommit无关

事务可以手动回滚，同时操作异常，MySQL会自动回滚

对于InnoDB每一天sql语句都默认封装成事务，自动提交，select 有特殊情况，因为mysql又MVCC

注意事项：

如果没有设置保存点，也可以回滚，只能回滚到事务开始的位置，可以实验rollback

事务被提交了，就不能回滚了

隔离性：



隔离级别：

读未提交

读提交

可重复读

串行化

```cpp
	查看全局隔离级别
	se @@global.tx_isolation;
	
	set session transaction isolation REPEATABEL READ;

	set global transaction isolation level read uncommitted; 
```

一个事务执行中，读到另一个事务未提交的数据，叫做脏读

读提交：

存在不可重复读问题





可重复读(MySQL默认隔离级别):

存在幻读问



串行化





多版本并发控制(MVCC)是一种用来解决读写冲突的无锁并发控制

为事务分配

DB_TRX_ID6:byte,最近修改事务ID



Read View

事务进行快照读操作的时候产生的读视图，在该事务执行的快照数据库系统当前的一个快照，记录并维护系统当前很活跃事务的Id，

```cpp
	m_ids;//一张列表，用来维护Read View生成时刻，系统正活跃的事务ID
	up_limit_id;//记录m_ids列表中书屋ID最小的ID
	low_limit_id;//ReadView生成时刻系统
```









修改了视图，对基表有影响

修改了基表，对视图有影响







用户管理

show databases;

use mysql

select * from user limit \G;

```sql
	#创建用户
	create user sjw@‘%’ identified by  '123456';
	#查看用户
	select User,Host authentication_string from user;
	#用户赋权
	grant 权限列表 on 库.表 to '用户名'
	show databases;
	
	grant select on scott.emp to sjw@'%';
	grant delete on scott.emp to sjw@'%';
	
	#回收权限
	revoke 权限列表 on 库.对象名 from 
	用户名@'登录位置';
	
```

创建用户

```sql
	
```

删除用户

```sql
	
```

用户赋权

```sql
	
```

