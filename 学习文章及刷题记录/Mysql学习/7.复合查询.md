7.复合查询

```sql
查询工资高于500或者岗位为manger的孤雁，同时满足首字母为大写J
select ename,sal job from emp where sal>500 or (job=manger and ename like 'J%')
```

按照部门号升序而员工工资降序排序

```sql
select ename,deptno,sal from emp order by deptno ，sal desc;
```

使用年薪排序

```sql
select ename,sal*12+ifnull(comm,0) 年薪from deptno order by 年薪; 
```

显示最高工资的员工的名字和岗位

```sql
select * from emp where sal=(select max(sal) from emp);
```

查询工资高于平均工资的姓名

```sql
select name,sal where sal>(select avg(sal) from emp) order by sal;
```

显示每个部门的最高工资和平均工资

```sql
select deptno, max(sal),avg(sal) from emp group by deptno;
```

显示工资低于2000的部门号和它的平均工资

```sql
select deptno,avg(sal) my_avg from emp group by deptno having my_avg<2000;
```

显示每种岗位雇人数及平均工资

```sql
select job, count(*) person ,avg(sal)from emp group by(job); 
```





结论：一般而言，我们所进行的后续多表查询，都应该是笛卡尔积表的子集

```sql
select * from emp,dept where emp.deotno=detp.deptno;
```

显示部门号为为10的部门明，员工名和工资

```sql
selecft deptno,ename sal from emp,dept where dept.deptno=emp.deptno;
```



自连接

一张表和别人笛卡尔积，当然可以和自己笛卡尔积

```sql
select* from emp ,emp emp_bak;

select ename,empno from emp worker,emp leader ehere worder.mgr=leader.empno and work.enmae='ford';
```

子查询:嵌套入其它sql中的select语句



多行子查询

```sql
in关键字：
查询和10号部门的工作岗位的雇员的名字，岗位，工资，部门号，但是不包括自己
select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno<>10;
```

```sq

显示工资比部门30的所有员工工资高的员工的姓名，工资和部门号

select ename,sgl,deptno from emp where sal> all(select distinct sal from emp where deptno=30 )
```

```sql
any关键字：比其中一个怎么咋们样
显示工资比部门30的任意员工工资高的员工的姓名，工资和部门号(包括自己部门的员工)
select ename,sal,deptno from emp where sal >any (select distinct sal from emp where deptno=30)
```



```sql
查询和SMITH的部门和岗位完全相同的所有雇员,不包括本人

select * from where (deptno,job) (select deptno,job from emp where ename='SMITH') and ename<>'SMITH';
```

