mysql表设计原则

关系型数据库表的关系

一对一的关系：

子表增加一列，关联父表的主键，增加一个中间表



范式设计

第一范式：

每一列都要保持原子特性

第二范式：

属性完全依赖于主键———主要争对联合主键

非主属性完全依赖于主关键字

第三范式：

属性不依赖于其它非主属性

BC范式：每一个表中只有一个候选键

第四范式：消除表中的多值依赖，减少维护数据一致性

范式越高，表越多，带来的问题：

1.查询时需要连接多个表，增加了sql语句查询的复杂度

2.查询时需要连接多个表，降低了数据库查询性能

因此，凡是并不是越高越好，视具体情况而定，第三范式已经很大程度上减少了了数据冗余，并且防止了数据冗余，基本预防了数据插入异常，更新异常和删除异常了

应用数据库范式带来的好处：

1。减少数据冗余(这是最主要的好处)

2.消除异常(插入异常，更新异常，删除异常)

3.让数据组织更加和谐



mysql引擎区别

myIsam与InnoDB的区别





mysql索引

索引的核心是提高查询的速度

缺点：索引并不是越多越好，

索引的分类：

物理上分为聚簇索引和非聚簇索引

逻辑上分为普通索引，唯一键索引，主键索引，单列索引，多列索引，全文索引

普通索引：数量是不限制的，但是一张表的一次sql查询只能用到一个索引

唯一键索引：用unique修饰的字段，

主键索引：用Primary Key修饰的字段会自动创建索引(MyISAM,InnoDB不设置主键会自动添加主键的)

单列索引：在一个字段上创建索引

多列索引：在表的多个字段上创建索引(uid+cid，多列索引必须使用到第一个列，才能用到多列索引，否则索引用不上)

全文索引：实验FULLTEXT参数可以设置全文索引，支支持CHAR，VARCHAR和TEXT类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度(线上项目支持专门的搜索功能，给后台服务器增减专门的搜索引擎支持快速高效的搜索  elasticserach检测es)



索引的创建和删除

创建表的时候指定索引字段

```sql
	创建表的时候自定索引字段
	create table index1(id int,name varchar(20),sex ENUM('male','female'),
                       index(id)，index(sex));
```

在已经创建的表上添加索引

```
	create INDEX 索引名 ON 表名(列名)
	create index id on index1;
```

删除索引

```sql
DROP index 索引名 on 表名
```

1. 经常座位where条件过滤的字段考虑添加索引
2. 字符串创建缩影时，尽量规定索引的长度，而不能让索引值的长度key_len过长
3. 过滤条件where字段如果涉及类型强转或者使用聚合函数，mysql函数，表达式求值会忽略索引





索引的底层实现原理

B树

数据，索引=>磁盘 MySQL Server 

花费磁盘I/O =>读到内存当中

MySQL读取内存一般为16k,也是内存页面的整数倍



B树是m阶树

  

好处就是更少的磁盘IO次数

为什么MYSQL索引(MyISAM,INnnoDB)底层选择B+树而不是B树呢？

1.索引+数据内容分散在不同的节点上，离根节点近，搜索就快，离根节点远，搜索的就慢，花费的磁盘IO次数不平均，每一行数据搜索花费的时间也不平均

2.每一个非叶子节点上，不仅仅要存储索引(key)，还要存储所营职所在的那一行的date数据，一个节点所能存放的索引key值的个数，比只存储key值的节点的个数要少的多

3.这棵树不方便做范围搜索，整表搜索看起来也不方便

由上面三个原因导致我们来使用B+树来构建索引树



1.B+树每一个非叶子节点只存放key,不存放data，好处就是一个节点存放的key值更多，B+树在理论上来说层数会更低一些，搜索的效率会更好一些

2.叶子节点上存储了所有的索引值《=》数据data：搜索每一个索引对应的值data，都需要跑到叶子节点上，这样搜索每一行记录搜索的时间会变得平均

3.叶子节点被穿在一个链表当中，形成了一个有序的链表，如果要进行索引树的搜索或者是整表搜索，直接遍历有序链表即可，或者做范围插叙的时候们直接遍历叶子节点的有序链表即可

主键索引和二级索引树

InnoDB存储引擎：数据和索引放在一起 student.frm student.ibd(数据和索引文件)

![image-20220510103918850](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220510103918850.png)

```
select * from student where name='lingfen';
	//回表查询
	1.先搜索name的二级索引树，找到lingfen对应的主键	uid:4
	2.在拿uid=4回表在主键索引树上搜索uid那一行的记录
```

```sql
	select * from student where age=20 order by name;
	如果只给age添加索引，行不行，还有什么没有考虑到吗？
	create index_union on student(age,name);
	key:age+name 多列索引(联合索引) 先按照age排序，再按照name排序，age相同，再次按照name排序
	所以不行，如果只有age索引，会有useing filesort排序，需要创建age,name的多列索引
	查询时一定要使用第一个列age
```

聚簇索引和非聚簇索引

场景：uid是主键，name二级索引

索引和数据放在一起：InnoDB

数据和索引分开存放：MyISAM节点的data值存放数据的地址



自适应哈希索引的数据维护也是要耗费性能的，并不是说自适应哈希索引在任何情况下都可以提高性能，根据参数指标，来具体分析是否打开或者关闭自适应哈希索引

```
show engine innodb status\G
能看到两个比较重要的信息：
1.RW-latch等待的线程数量(自适应哈希索引默认分配了8个分区)，同一个线程等待线程过多
2.走自适应哈希搜索的频率(低)和二级索引树搜索的频率(高)

关闭自适应哈希索引
```



索引常见问题

索引的优化和sql优化时，如何切入

explain分析sql语句，判断是否用到索引或者是否建立了索引

流程：从什么地方能够获取那些运行时间长，耗费性能的sql,然后用explain分析它

慢查询日志：

slow_query_log

```sql
show variables like 'slow_query%';

#打开慢查询日志
set global slow_query_loh=ON;

show variables like 'long_query%';

set long_query_time=1;
```

步骤：

1.打开慢查询日志，设置合理的，业务可以指向的慢查询日志

2.压测执行各种业务

3.查询慢查询日志，找出所有执行耗时的sql

4.用explain分析这些耗时的sql语句

5.举例子

```
show variables like 'profiling';

set profiling=on;

show profi
```



mysql事务

事务的相关概念

一个事务室友一条或者多条对数据库操作的sql语句所组成的一个不可分割的单元，只有当食物中所有操作执行完成事务才会被提交给数据库，如果有部分事务失败，那么事务就要回退到最初的状态，因此，事务要么全部执行成功，要么全部失败，事务的基本特点：

1.事务是一组sql语句的执行，要么全部成功，要么全部失败，不能出现部分成功，部分失败的结果，保证事务执行的原子操作

2.事务的所有sql语句全部执行，才能提交(commit)事务，把结果写回磁盘中

3.事务执行的过程中，有的sql出现错误，那么事务必须回滚(rollback)到最初的状态

MyISAM:不支持事务

InnoDB:最大的特点：支持事务，支持行锁

事务的ACID特性：

事物的原子性：

事务是一个不可分割的整体，事务必须具有源自特性。即当修改数据时，要么全部执行，要么全部执行，即不容许事务部分的完成

事务的一致性：

一个事务执行之前和执行之后，数据库数据必须保证一致性状态，数据库的一致性状态必须由用户负责，有并发控制机制实现

事务的隔离性：

当两个或多个事务并发执行时，为了保证数据的安全性，将一个事务内部的操作与其它事务的操作隔离起来，不被其它正在执行的事务所看到，使得并发执行的各个事务之间不能相互影响

事务的持久性：

事务完成以后，DBMS保证它对数据库中的数据修改是永久性的，即使数据库因为故障出错，也应该能够恢复数据

ACD是由事务的redo log 和undo log机制来执行的

隔离性是由mysql的锁机制来实现的

mysql最重要的是日志，不是数据



事务的并发存在的问题

事务处理不经隔离，并发执行事务可能发送一下问题：

脏读：以恶搞事务读取了另一个事务未提交的数据。例如事务A和事务B并发执行时，事务A更新后，事务B查询读取到A尚未提交的数据，此时事务A回滚，则事务B读到的数据就是无效的脏数据(事务B读取了事务A尚未提交的数据)

不可重复度：一个事务的操作导致另一个事务前后两次读取到不同的数据。例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A跟新操作更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样(事务B读取了事务A已提交的数据)

虚读：以恶搞事务的操作导致另一个事务前后两次的查询数据量不同，例如当事务A和事务B并发执行时，当事务B查询读取到数据后，事务A新增或者删除列一条满足事务B查询条件的记录，此时事务B再去查询，发现

```sql
	设置事务自动提交
	set autocommit=0;
	#0代表手动提交事务，1代表自动提交事务，上面设置事务为手动提交
```

```sql
	begin:开启一个事务
	commit:提交一个事务
	rollback:回滚一个事务到初始的位置
	savepoint point1;设置一个名字为point1的保存点
	rollback to point1:事务回滚到保存点point1，而不是回滚到初始状态
	set TX_ISOLATION='REPEATABLE-READ'设置事务的隔离级别
	select @@TX_ISOLATION;查询事务的隔离级别
```



事务的隔离级别

mysql支持的四种隔离级别

读未提交(REAAD-UNCOMMITED)

读提交(READ-COMMITED)

可重复读(REPEATABLE-READ)

串行化(SERIALIZABLE)



 事务隔离级别的实现原理：锁+MVCC

串行化  ：锁实现，给所有事务都排个序，并发效率低，数据安全性高

读为提交：没有任何并发控制，并发效率高，数据安全性最低



```
	已提交读+可重复读结合了：
	1.数据的安全性&一致性+并发的效率
	MVCC多版本并发控制机制实现的
```

mysql默认是可重复读

Oracle是已提交读



Mysql锁机制

表级锁：对整张表加锁，开销小，加锁块，不会出现死锁，锁粒度大，发生锁冲突的概率高，并发度低

行级锁：对某行记录加锁，开销大，枷锁满，会出现死锁，锁定力度最小，发生锁冲突的概率最低，并发度高



排它锁和共享锁

排它锁：又称X锁，写锁

共享锁：又称S锁，读锁

X和S锁之间由西夏关系：SS是兼容的，SX，XX之间是互斥的

```
	select * from user where id=7 for update;
	#获取写锁
	#获取之后其他人就不能获取了，相当去独占锁
	
```

​	innoDB的行锁是加在索引项上的，是给索引加锁，并不是给单纯的行记录加锁，索引如果过滤条件没有索引的话，使用的就是表锁，而不是行锁

========>InnoDB 行锁  表锁



串行化隔离级别如何解决幻读问题

幻读：

间隙锁(gap lock)解决幻读问题：





需要安装的东西：

g++10

git

gcc

vim 插件

新建sjw用户

mysql安装

创建chat数据库

muduo网络库安装

