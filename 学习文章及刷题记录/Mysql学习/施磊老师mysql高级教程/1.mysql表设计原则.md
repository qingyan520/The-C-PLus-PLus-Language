mysql表设计原则

关系型数据库表的关系

一对一的关系：

子表增加一列，关联父表的主键，增加一个中间表



范式设计

第一范式：

每一列都要保持原子特性

第二范式：

属性完全依赖于主键———主要争对联合主键

非主属性完全依赖于主关键字

第三范式：

属性不依赖于其它非主属性

BC范式：每一个表中只有一个候选键

第四范式：消除表中的多值依赖，减少维护数据一致性

范式越高，表越多，带来的问题：

1.查询时需要连接多个表，增加了sql语句查询的复杂度

2.查询时需要连接多个表，降低了数据库查询性能

因此，凡是并不是越高越好，视具体情况而定，第三范式已经很大程度上减少了了数据冗余，并且防止了数据冗余，基本预防了数据插入异常，更新异常和删除异常了

应用数据库范式带来的好处：

1。减少数据冗余(这是最主要的好处)

2.消除异常(插入异常，更新异常，删除异常)

3.让数据组织更加和谐



mysql引擎区别

myIsam与InnoDB的区别





mysql索引

索引的核心是提高查询的速度

缺点：索引并不是越多越好，

索引的分类：

物理上分为聚簇索引和非聚簇索引

逻辑上分为普通索引，唯一键索引，主键索引，单列索引，多列索引，全文索引

普通索引：数量是不限制的，但是一张表的一次sql查询只能用到一个索引

唯一键索引：用unique修饰的字段，

主键索引：用Primary Key修饰的字段会自动创建索引(MyISAM,InnoDB不设置主键会自动添加主键的)

单列索引：在一个字段上创建索引

多列索引：在表的多个字段上创建索引(uid+cid，多列索引必须使用到第一个列，才能用到多列索引，否则索引用不上)

全文索引：实验FULLTEXT参数可以设置全文索引，支支持CHAR，VARCHAR和TEXT类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度(线上项目支持专门的搜索功能，给后台服务器增减专门的搜索引擎支持快速高效的搜索  elasticserach检测es)



索引的创建和删除

创建表的时候指定索引字段

```sql
	创建表的时候自定索引字段
	create table index1(id int,name varchar(20),sex ENUM('male','female'),
                       index(id)，index(sex));
```

在已经创建的表上添加索引

```
	create INDEX 索引名 ON 表名(列名)
	create index id on index1;
```

删除索引

```sql
DROP index 索引名 on 表名
```

1. 经常座位where条件过滤的字段考虑添加索引
2. 字符串创建缩影时，尽量规定索引的长度，而不能让索引值的长度key_len过长
3. 过滤条件where字段如果涉及类型强转或者使用聚合函数，mysql函数，表达式求值会忽略索引





索引的底层实现原理

B树

数据，索引=>磁盘 MySQL Server 

花费磁盘I/O =>读到内存当中

MySQL读取内存一般为16k,也是内存页面的整数倍



B树是m阶树

  

好处就是更少的磁盘IO次数

为什么MYSQL索引(MyISAM,INnnoDB)底层选择B+树而不是B树呢？

1.索引+数据内容分散在不同的节点上，离根节点近，搜索就快，离根节点远，搜索的就慢，花费的磁盘IO次数不平均，每一行数据搜索花费的时间也不平均

2.每一个非叶子节点上，不仅仅要存储索引(key)，还要存储所营职所在的那一行的date数据，一个节点所能存放的索引key值的个数，比只存储key值的节点的个数要少的多

3.这棵树不方便做范围搜索，整表搜索看起来也不方便

由上面三个原因导致我们来使用B+树来构建索引树



1.B+树每一个非叶子节点只存放key,不存放data，好处就是一个节点存放的key值更多，B+树在理论上来说层数会更低一些，搜索的效率会更好一些

2.叶子节点上存储了所有的索引值《=》数据data：搜索每一个索引对应的值data，都需要跑到叶子节点上，这样搜索每一行记录搜索的时间会变得平均

3.叶子节点被穿在一个链表当中，形成了一个有序的链表，如果要进行索引树的搜索或者是整表搜索，直接遍历有序链表即可，或者做范围插叙的时候们直接遍历叶子节点的有序链表即可

主键索引和二级索引树

InnoDB存储引擎：数据和索引放在一起 student.frm student.ibd(数据和索引文件)

![image-20220510103918850](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220510103918850.png)

```
select * from student where name='lingfen';
	//回表查询
	1.先搜索name的二级索引树，找到lingfen对应的主键	uid:4
	2.在拿uid=4回表在主键索引树上搜索uid那一行的记录
```

```sql
	select * from student where age=20 order by name;
	如果只给age添加索引，行不行，还有什么没有考虑到吗？
	create index_union on student(age,name);
	key:age+name 多列索引(联合索引) 先按照age排序，再按照name排序，age相同，再次按照name排序
	所以不行，如果只有age索引，会有useing filesort排序，需要创建age,name的多列索引
	查询时一定要使用第一个列age
```

聚簇索引和非聚簇索引

场景：uid是主键，name二级索引

索引和数据放在一起：InnoDB

数据和索引分开存放：MyISAM节点的data值存放数据的地址
