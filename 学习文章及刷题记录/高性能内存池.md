### 高性能内存池

借鉴tcmalloc(ThreadCaching Malloc)，即线程缓存的malloc，实现了高效的多线程内存管理，用于替代系统的内存分配相关的函数(malloc，free)



池化技术：向系统先申请过量的资源，然后自己管理，以备不时之需，之所以申请过量资源，是因为每次申请资源都有较大的开销，那边不如提前申请好，提高程序运行效率

在计算机中除了内存池，还有连接池，线程池，对象池等，以线程池为例，它的主要思想是，先启动若干数量的线程，让他们处于睡眠状态，当接收到客户端请求时，唤醒某个沉睡的线程，让它处理客户端请求，当处理完请求之后，线程又进入了休眠状态

内存池：程序预先向系统申请一大块足够的内存，此后，当系统需要申请内存的时候，不是直接向操作习题申请，而是向内存池中申请，当释放的时候，不返回给操作系统，而是返回给内存池，当程序退出时，内存池才将申请的内存真正释放

内存池解决问题：

1.主要解决效率问题

2.内存碎片问题

malloc实际就是一个内存池





定长内存池

固定大小的内存申请管理

特定：

性能达到极致

不考虑内存碎片等问题

ConcurrMemoryPool项目名称



```cpp
//ObjectPool.h
#pragma once
#include<iostream>
#include<vector>
#include<windows>
using std::cout;
using std::endl;
template<class T>
class ObjectPool{
    private:
    char*_memory=nullptr;//指向大块内存的指针
    void*_freeList=nullptr;//换回来过程中连接的自由链表指针
    size_t _remainBytes=0;//大块内存被切分过程中剩余字节数
    public:
    T*New()
    {
        //优先把还回来的内存块对象重复利用
        T*_obj==nullptr;
        if(_freeList)
        {
            void*next=*(void**)_freeList;
            obj=_freeList;
        }
        //剩余内存不够一个对象大小时，重新开一个大块空间
        if(_remainBytes<sizeof(T))
        {
            _memory=(char*)malloc(128*1024);
            
            _remainBytes=128*1024;
            if(_memory==nullptr)
            {
                throw bad_alloc();
            }
            _obj=(T*)_memory;
            size_t objsize=sizeof(T)<sizeof(void*)? sizeof(void*):sizeof(T);
        	_memory+=objsize;
        	_remainBytes-=objsize;
        }
        //定位new,显示调用T的构造函数初始阿虎
        new(obj) T;
        return _obj;
    }
    
    
    void Delete(T*obj)
    {
        //显示调用析构函数清理对象
    	obj->~T();
        //头插
        *(void**)obj=_freelist;
        _freeList=obj;
        
    }
};


//测试性能
void Test()
{
    
}
```

test.h

```

```

#### 高并发内存池整体框架设计

thread cache整体设计

thread cache

自由链表：管理切好的小块内存

```cpp
//Common.h
#include<iostream>
#include<assert.h>
sttatic const size_t MAX_BYTES=256*1204;
//管理切分好的小对象的自由链表
void*&NextObj(void*obj){
    return *(**)obj;
}
class FreeList{
    public:
    void Push(void*obj){
        //头插
        NextObj(obj)=_freeList;
        _freeList=obj;
        
    }
    void*Pop(){
        assert(_freeList);
        void*obj=_freeList;
        _freeList=NextObj(obj);
        
    }
    private:
    void*_freeList;
};


class SizeClass{
  public:
    
};
```



```cpp
//threadCache .h
#include"Common.h"
class ThreadCache{
    public:
    void*Allocate(size_t size);
    
    void Deallocate(void*ptr,size_t size);
    private:
    FreeList _freeLists[]
  	  
};
```

```cpp
//threadCache.cpp
#include"threadCache.h"
void*ThreadCache::Allocate(size_t size){
    assert(size<=MAX_BYTES);
    
}


void ThreadCache::Deallocate(void*ptr,size_t size){
    
}
```



central cache

page cache

