设计模式

模式分类

从目的来看：

创建型：将对象的部分创建工作

结构性：

从范围看：

类模式处理类与子类的静态关系

对象模式处理对象间的动态关系

重构关键技法：

静态———>动态

早绑定———–>晚绑定

继承————>组合

编译时依赖———>运行时依赖

紧耦合—————>松耦合



组件写作模式

组件写作主要通过晚期绑定，来实现框架之间的松耦合，是二者之间协作时常用的模式

在软件构建过程中，对于某一项任务，它常常有着稳定的结构，但是它的各个子步骤之间却有很多改变的需求，而无法和二五的整体结构同时实现

如何在确定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求

Template Method模板方法

Strategy

Observer/Event

 

例如

```cpp
//template1_lib.cpp
//程序库开发人员
class Library{
    public:
    
    void Step1()
    {
        
    }
    
    void Step3(){
        
    }
    
    void Step5(){
        
    }
};
```

```cpp
//应用程序开发
class Application{
    public:
    bool Step2(){
        //...
    }
    
    void Step4(){
        //....
    }
};



int main()
{
    Library lib();
    Aoolication app();
    Application();
    
    lib.Step1();
    if(app.Step2())
    {
        lib.Step3();
    }
    for(int i=0;i<4;i++)
    {
        app.Step4();
    }
    
    lib.Step5();
}
```

上面例子框架基本固定，只要Application中step2和step4会做变化，那么我们可以写出下面这种样子

```cpp
class Libary{
    public:
    //稳定的template method
    void Run()
    {
        Step(1);
        
        if(Step2()){//支持变化====>虚函数的多态调用
            Step3();
        }
        for(int i=0;i<4;i++)
        {
            Step4();//支持变化===>虚函数的多态调用
        }
        
        Step5();
    }
    
    virtual ~Library()
    {
        
    }
    
    protected:
    void Step1(){
     //...   
    }
    
 	void Step3(){
        
    }   
    
    void Step5()
    {
        
    }
    
    virtual bool Step2()=0;//变化
    virtual void Step4()=0;//变化
    
};

//应用程序开发人员
class Application{
    
};



int main()
{
    Library*pLib=new Application();
    pLib->Run();
    return 0;
}

```

定义一个操作中的算法的骨架(稳定)，而将不稳定的算法放到子类中，Template Method使得子类可改变(复用)一个算法的结构即可重定义(override重写)某些特定步骤



总结：

Template Method模式是一种非常常用的基础性设计模式， 在面向对象系统中有大量的应用，它用最简洁的机制(虚函数)为应用程序提供了灵活的扩展点，是代码复用方面的实现结构

被template method调用的虚函数，一般被设置为protected方法





Strategy策略模式

➢在软件构建过程中, 某些对象使用的算法可能多种多样,经常改
变,如果将这些算法都编码到对象中,将会使对象变得异常复杂;
而且有时候支持不使用的算法也是- -个性能负担。
➢如何在运行时根据需要透明地更改对象的算法?将算法与对象本
身解耦,从而避免上述问题?

定义一系列算法,把它们一一个个封装起来,并且使它们可互
相替换(变化)。该模式使得算法可独立于使用它的客户程
序(稳定)而变化(扩展,子类化)。

```cpp
//税率计算,税率会一直变化
enum TaxBase{
  	CN_Tax,
    US_Tax,
    DE_Tax，
    TR_Tax     //更改
};


class SalesOrder{
    TaxBase tax;
    public:
   	double CalulateTax()
    {
        if(tax==CN_Tax)
        {
            //.......
        }
        else if(tax==US_Tax)
        {
            //......
        }
        else if(tax==DE_Tax)
        {
            //.....
        }
    }
}
```

设计模式strategy实现

```cpp
class TaxStrategy
{
	public:
    virtual double Calulate(const Contex&contex)=0;
    virtual ~TaxStrategy()
    {
        
    }
}

class CNTax:public TaxStrategy
{
    public:
    virtual double Calculate(const Context&context)
    {
        //.....
    }
}


class DETax:public TaxStrategy
{
    public:
    virtual double Calculate(const Context&context)
    {
        //.....
    }
}

//*************
class FRTax:public TaxStrategy{
    public:
    virtual double Calculate(const Context&context)
    {
        //.....
    }
};
    
class SalesOrder{
  private:
    TaxStrategy*strategy;
    public:
    SalesOrder(StrateFactory*strategyFactory)
    {
        this->strategy=strategyFactory->NewStrategy();
    }
    
    ~SalesOrder()
    {
        delete this->strategy;
    }
    
    public:
    double CalculateTax()
    {
        Context context();
        double val=strategy->Calulate(context);//多态调用
    }
};
```

![image-20220503165326352](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220503165326352.png)

要点总结

➢Strategy及其子类为组件提供了一系列可重用的算法,从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。

➢Strategy模式提供了用条件判断语句以外的另-种选择,消除条件判断语句,就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。

➢如果Strategy对象没有实例变量,那么各个上下文可以共享同一个Strategy对象,从而节省对象开销。

​	要点总结➢Strategy及其子类为组件提供了一系列可重用的算法,从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。➢Strategy模式提供了用条件判断语句以外的另-种选择,消除条件判断语句,就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。➢如果Strategy对象没有实例变量,那么各个上下文可以共享同一个Strategy对象,从而节省对象开销。



Observer观察者模式

➢在软件构建过程中, 我们需要为某些对象建立- -种“通知依赖关
系”一一个对象(目标对象)的状态发生改变,所有的依赖对
象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密,
将使软件不能很好地抵御变化。
➢使用面向对象技术,可以将这种依赖关系弱化,并形成- -种稳定
的依赖关系。从而实现软件体系结构的松耦合。

```cpp
class FileSplitter{
	string m filePath;
	int m fileNumber;
public:
	FileSplitter(const string& filePath, int 	fileNumber) :
	m_ filePath(filePath),
	m_ fileNumber(fileNumber){}
    
	void split(){
	//1.读取大文件
	//2.分批次向小文件中写入
	for (int i = 0; i < m_ fileNumber; i++){
	//...
	}
};


class MainForm : public Form
{
	TextBox* txtFilePath;
	TextBox* txtF ileNumber;
public:
	void Button1_ Click(){
		string filePath = txtFilePath- >getText();
		int number = atoi(txtF ileNumber->getText().c_ str());
		FileSplitter splitter(filePath, number);
		splitter. split();
	}
};
```



定义对象间的一-种一-对多(变化)的依赖关系,以便当一个定义对象间的一-种一-对多(变化)的依赖关系，以便当一个
对象(Subject)的状态发生改变时,所有依赖于它的对象都对象(学科)的状态发生改变时，所有依赖于它的对象都
得到通知并自动更新。得到通知并自动更新.

![image-20220504204341937](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220504204341937.png)

要点总结要点总结
➢使用面向对象的抽象, Observer模式使得我们可以独立地改变目➢使用面向对象的抽象，观察者模式使得我们可以独立地改变目
标与观察者,从而使= C者之间的依赖关系达致松耦合。标与观察者，从而使=C者之间的依赖关系达致松耦合.
➢目标发送通知时,无需指定观察者,通知(可以携带通知信息作➢目标发送通知时，无需指定观察者，通知(可以携带通知信息作
为参数)会自动传播。为参数)会自动传播.
➢观察者自己决定是否需要订阅通知，目标对象对此一无所知。➢观察者自己决定是否需要订阅通知，目标对象对此一无所知.

>Observer模式是基于事件的UI框架中非常常用的设计模式,也是观察者模式是基于事件的UI框架中非常常用的设计模式，也是
>MVC模式的一个重要组成部分。MVC模式的一个重要组成部分。





单一职责模式：

➢在软件组件的设计中，如果责任划分的不清晰，使用继承得到的➢在软件组件的设计中，如果责任划分的不清晰，使用继承得到的
结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，
这时候的关键是划清责任。这时候的关键是划清责任.

Decorator装饰模式

动态(组合)地给一个对象增加一些额外的职责。就增加功动态(组合)地给一个对象增加一些额外的职责.就增加功
能而言，Decorator模式比生成子类(继承)更为灵活(消能而言，Decorator模式比生成子类(继承)更为灵活(消
除重复代码&减少子类个数)。除重复代码&减少子类个数)。

![image-20220505150102668](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220505150102668.png)

![image-20220629122537363](https://raw.githubusercontent.com/qingyan520/Cloud_img/master/img/image-20220629122537363.png)
