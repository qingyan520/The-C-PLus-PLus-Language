智能指针

```cpp
//智能指针：保证资源的自动释放
//利用栈上的变量出作用域自动调用析构函数的特征。来做到资源释放

template<class T>
class CSmartPtr{
    public:
    CSmartPtr(T*ptr=nullptr)
        :mptr(ptr){}
    ~CSmartptr(){
        delete mptr;
     T&operator*()
     {
         return *mptr;
     }
     
     T* operaotr->()
     {
         return mptr;
     }
    }
    private:
    T*mptr;
}
int main()
{
    CSmartPtr<int>ptr1(new int);
    
}
```

带引用计数的指针指针：shared_ptr

```

```

shared_ptr利用引用计数解决多个智能指针解决同一个资源

```
shared_ptr:强智能指针：可以改变资源的引用计数
weak_ptr:若指针指针，不会改变资源的引用计数
weak_ptr=>shared_ptr
```

强智能指针循环引用（交叉引用）是什么问题，什么结果，如何解决

造成new出来的资源无法释放

```cpp
class B;
class A
{
	public:
	A(){
	cout<<"A()"<<endl;
	}
	~A()
	{
	cout<<"~A()"<<endl;
	}
	shared_ptr<B>_ptr;
}
class B
{
	public:
	B()
	{
		cout<<"B()"<<endl;
	}
	~B()
	{
		cout<<"~B()"<<endl;
	}
	shared_ptr<A>_ptrb;
}

int main()
{
	shared_ptr<A>pa(new A());
    shared_ptr<B>pb(new B());
    pa->_ptrb=pb;
    pb->ptra=pa;
}


class B;
class A
{
	public:
	A(){
	cout<<"A()"<<endl;
	}
	~A()
	{
	cout<<"~A()"<<endl;
	}
	weak_ptr<B>_ptr;
}
class B
{
	public:
	B()
	{
		cout<<"B()"<<endl;
	}
	~B()
	{
		cout<<"~B()"<<endl;
	}
	weak_ptr<A>_ptrb;
}

int main()
{
	shared_ptr<A>pa(new A());
    shared_ptr<B>pb(new B());
    pa->_ptrb=pb;
    pb->ptra=pa;
}
```

智能指针的删除器

```cpp
智能指针能够保证资源的绝对释放
shared_ptr<int>(new int[1000],[&](int*ptr)->(){
    delete []ptr;
})
```

