//# 深入理解C++类和对象（中）
//
//> 如果一个类里面什么也不写，那么它里面真的什么都没有吗？
//>
//> 答案是否定的，如果一个类是空类，那么编译器会为我们提供6个默认成员函数，分别为构造函数，析构函数拷贝构造函数，赋值用算符重载函数，& 操作符重载，const修饰的取地址操作符重载，那么接下来本片文章将带你来理解这6个默认成员函数
//
//### 1.构造函数
//
//构造函数是一个特殊的成员函数，类名与函数名相同，主要完成对对象的初始化
//
//特点：
//
//1.函数名与类名相同
#include<iostream>
using namespace std;
class Person
{
public:
	Person()
	{
		arr = (int*)malloc(sizeof(int) * 1);
	}
	~Person()
	{
		
		free(arr);
		cout << "Person的析构函数的调用" << endl;
	}
	int* arr;
};
int main()
{
	Person p;
	return 0;
}
//2.没有返回值，也不写void
//
//3.对象实例化时编译器会自动调用对应的构造函数
//
//4.构造函数可以重载
//
//5.如果类中没有显式定义构造函数，则C++编译器会自动生成一个默认的构造函数，一旦用户显式定义了编译器就不会自动生成
//
//6.无参的构造函数和全缺省的构造函数都称为默认构造函数，标签默认构造函数只能有一个。注意：无参构造函数，全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数
//
//### 2.析构函数
//
//在对象销毁时自动调用析构函数，完成对类的一些资源的清理工作
//
// 
//特点：
//
//1.析构函数名是在类名前面加上字符~
//
//2.无参数，没有返回值，不写void
//
//3.一个类有且只有一个析构函数，系统会自动生成默认的析构函数
//
//4.对象生命周期结束时，C++编译系统自动调用析构函数
//
//5.如果有成员变量是在堆区创建出来的，我们要在析构函数中手动释放
//
//### 3.拷贝构造函数
//
//特点：
//
//1.拷贝构造函数是构造函数的一个重载形式
//
//2.拷贝构造函数的参数有且只有一个必须使用引用传参，使用传值方式会引发无穷递归调用
//
//3.若显示定义，系统生成默认的拷贝构造函数，默认的拷贝构造函数对象按内存存储字节序完成拷贝，这种拷贝我们称为浅拷贝，或者值拷贝
//
//### 4.赋值运算符重载
//
//
//
//1.赋值运算符重载：
//
//在C++中默认提供对赋值运算符的重载
//
//例如：
//
//赋值有算符主要有以下几点：
//
//1.参数类型
//
//2.返回值
//
//3.检测是否自己给自己赋值
//
//4.返回 * this
//
//5.一个类如果没有显示定义赋值运算符，编译器也会自动生成一个，完成对象按字节序的值拷贝
//
//2.其它运算符的重载
//
//C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有返回值类型，函数名及其参数列表，其返回值类型与参数列表与普通的函数类似
//
//函数名字：关键字operator + 操作符 + （参数列表）
//
//函数原型：返回值类型 operator+操作符 + （参数列表）
//
//注意：
//
//1.不能通过连接其它符号创建新的操作符
//
//2.重载操作符必须有一个类类型或者枚举类型的操作数
//
//3.用于内置类型的操作数，其含义不能改变，例如： + ，不能改变其含义
//
//4.作为类成员的重载函数时，其形式看起来比操作数数目少1的成员函数的操作符有一个默认的形参this，限定为第一个参数
//
//5. * 、.、 ：：、sizeof、 ? : 、 注意以上5个运算符不能重载
//
//
//
//前置++运算符重载
//
//后置++运算符重载
//
//前置--运算符重载
//
//后置--运算符重载
//
//“ > ”运算符重载
//
//== 运算符重载
//
//">="运算符重载
//
//“ < "运算符重载
//
//	“ <= ”运算符重载
//
//	”！ = “运算符重载
//
//	5. & 操作符重载及const修饰的 & 操作符重载
//
//	1.const修饰类的成员函数
//
//	将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数中的this指针，表明该成员函数中不能对类的任何成员进行修改
//
//	2. & 及const取地址操作符重载
//
//	这两个默认成员函数一般不用重新定义，编译器会默认生成
//
//	这两个运算符一般不需要重载，使用编译器生成的默认取地址的宠爱即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容